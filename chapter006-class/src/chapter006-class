	chapter006 class
	
	-- Table of contents --
		6.1 object oriented programming
		6.2 object and class
		6.3 declaration of class
		6.4 creation of object and class variable
		6.6 composition member of class
		6.6 field
		6.7 constructor
		6.8 method
		6.9 instance member and this
		6.10 static member and static
		6.11 final field and constant
		6.12 package
		6.13 access modifier
		6.14 getter and setter method
		6.15 anotation
	-----------------------
	
	6.1 OOP(object oriented programming)
		- 부품에 해당하는 객체들을 먼저 만들고 ,이것들을 하났기 조립해서 완성된 프로그램을 만드는 기법
	
	6.1.1 about object
		* object : 물리적으로 존재하거나 추상적으로 생각할 수 있는 것 중에서
				   자신의 속성을 가지고있고 다른 것과 식별 가능한 것
				   ex) 자동차, 자전거, 책, 사람 / 학과, 강의, 주문 등
				 : 속성(field)과 동작(method)으로 구성되어 있다.
				   ex)  사람 -> (속성) 이름, 나이 등 / (동작) 웃다, 걷다 등
				   		자동차 -> (속성) 색상, 모델명 등 / (동작) 달린다, 멈춘다
		* Object Modeling : 현실세계의 객체를 소프트웨어 객체로 설걔하는 것
		
	6.1.2 interaction of object
		- 객체들은 각각 독립적으로 존재하고, 다른 객체와 서로 상호작용 하면서 동작한다.
		* 메소드 호출 : 객체가 다른 객체의 기능을 이용하는것
		- 객체들 사이의 상호작용 수단은 메소드이다. 객체가 다른 객체의 기능을 이용하며 상호작용한다.
		- '객체.메소드이름(매개값)' : 메소드 호출의 방법, 도트연산자(.)는 객체의 필드와 메소드에 접근할 때 사용한다.
		- 매개값은 메소드를 실행하기 위해 필요한 데이터이다.
		- 객체의 상호작용은 객체 간의 메소드 호출ㅇ르 의미하며 매개값과 리턴값을 통해서 데이터를 주고 받는다.
		
	6.1.3 relationship between objects
		- 객체는 개별적으로 사용될 수 있지만, 대부분 다른 객체와 관계를 맺고 있다.
		- 관계의 종류에는 집합관계, 사용관계, 상속관계가 있다.
		- 집합 관계에 있는 객체는 하나는 부품이고 하나는 완성품에 해당한다.
		  ex) 자동차, 엔진, 타이어, 핸들
		- 사용관계는 객체 간의 상호작용을 말한다. 객체는 다른 객체의 메소드를 호출하여 원하는 결과를 얻어낸다.
		  ex) 사람, 자동차(달린다, 멈춘다)
		- 상속관계는 상위(부모) 객체를 기반으로 하위(자식) 객체를 생성하는 관계를 말한다.
		- 일반적으로 상위 객체는 종류를 의미하고, 하위 객체는 구체적인 사물에 해당한다.
		  ex) 기계(상위), 자동차(하위)
		- 객체 지향 프로그래밍은 만들고자 하는 완성품인 객체를 모델링하고, 집합 관계에 있는 부품 객체와 사용 관계에 있는
		  객체를 하나씩 설계한 후 조립하는 방식으로 프로그램을 개발하는 기법이다.
		  
	6.1.4 characteristic of object oriented programming
		1) 캡슐화(Encapsulation)
			- 객체의 필드, 메소드를 하나로 묶고, 실제 구현 내용을 감추는 것
			- 외부 객체는 객체 내부의 구조를 알지 못하며 객체가 노출해서 제공하는 필드와 메소드만 이용할 수 있다.
			- 외부의 잘못된 사용으로 인해 객체가 손상되지 않도록 하는데 목적이있다.
			- 캡슐화된 멤버를 노출시킬 것인지, 숨길 것인지를 결정하기 위해 접근 제한자를 사용한다.
			* Access Modifier : 객체의 필드와 메소드의 사용 범위를 제한함으로서 외부로부터 보호하는 것
			
		2) 상속(Inheritance)
			- 상위 객체는 자기가 가지고 있는 필드와 메소드를 하위 객체에게 물려주어 하위 객체가 사용할 수 있도록 한다.
			- 상속은 상위 객체를 재사용해서 하위 객체를 쉽고 빨리 설계할 수 있도록 도와주고,
			  이미 잘 개발된 객체를 사용해서 새로운 객체를 만들기 때문에 반복된 코드의 중복을 줄여준다.
			- 상속은 사위 개체의 수정으로 모든 하위객체들의 수정 효과를 가져오므로 유지 보수 시간을 최소화 시켜 주기도 한다.
		
		3) 다형성(Polymorphism)
			- 다형성은 같은 타입이지만 실행 결과가 다양한 객체를 이용할 수 있는 성질을 말한다.
			- 코드 측면에서 다형성은 하나의 타입에 여러 객체를 대입함으로써 다양한 기능을 이용할 수 있도록 한다.
			- 자바는 다형성을 위해 부모 클래스 또는 인터페이스의 타입 변환을 허용한다.
			- 부모 타입에는 모든 자식 객체가 대입될 수 있고, 인터페이스 타입에는 모든 구현 객체가 대입될 수 있다.
			- 다형성의 효과로 객체는 부품화가 가능하다
			
	
	6.2 object and class
		- 클래스는 객체의 설계도이다.
		- 클래스에는 객체를 생성하기 위한 필드와 메소드가 정의되어있다.
		- 클래스로부터 만들어진 객체를 해당 클래스의 인스턴스(instance)라고 한다.
		- 클래스로부터 객체를 만드는 과정을 인스턴스화라고 한다.
		- 하나의 클래스로부터 여러 개의 인스턴스를 만들 수 있다.
		- 객체 지향 프로그래밍 개발의 단계
			(1) 클래스 설계
			(2) 객체 생성
			(3) 생성된 객체 이용
		- main() 메소드가 없는 클래스는 객체 생성 과정을 거쳐 사용해야 한다.
		
		
	6.3  declaration of class 
		- 자바의 식별자 작성 규칙
		----------------------------------------------------------
			번호		작성규칙								예
			1		하나 이상의 문자로 이루어져야한다.			Car, SportsCar
			2		첫 번째 글자는 숫자가 올 수 없다.			Car, 3Car(x)
			3		'$', '_'외의 특수문자는 사용할 수 없다. 	$Car, _Car, @Car(x), #Car(x)
			4		자바 키워드는 사용할 수 없다.				int(x), for(x)
		----------------------------------------------------------
		- 클래스의 이름은 영어 대소문자를 구분한다.
		- 관례적으로 단일 단어라면 첫 자를 대문자로 하고 나머지는 소문자로 작성한다.
		- 서로 다른 단어가 혼합된 이름을 사용한다면 각 단어의 첫 머리 글자는 대문자로 작성하는 것이 관례이다.
		ex) Carculator, Car, Member, ChatClient, ChatServer, Web_Browser
		- "클래스이름.java"로 소스 파일을 생성해야 한다.(소스파일 이름 역시 대소문자를 구분한다)
		- 소스 파일 생성 후 소스 파일에 클래스를 선언한다
		----------------------------------------------------------
			public class 클래스이름 {
			
			}
			
			* public class : 클래스 선언시 사용하는 키워드, 반드시 소문자로 작성해야한다.
			* {} : 클래스 선언의 시작과 끝을 알려준다.
		----------------------------------------------------------
		- 일반적으로 소스 파일 당 하나의 클래스를 선언한다. 하지만, 두 개 이상의 클래스 선언도 가능하다.
		- 두 개 이상의 클래스가 선언된 소스 파일을 컴파일하면 바이트 코드 파일은(.class) 클래스를 선언한 개수만큼 생긴다.
		- 결국 소스파일은 클래스 선언을 담고 있는 저장 단위일 뿐, 클래스 자체가 아니다.
		- 파일 이름과 동일한 이름의 클래스 선언에만 public 접근 제한자를 붙일 수 있다.
		- 소스 파일 하나당 동일한 이름의 클래스 하나를 선언하는 것을 권장한다.
		
		
	6.4 creation of object and class variable
		- 클래스를 선언한 다음, 컴파일을 했다면(이클립스에서는 저장) 객체를 생성할 설계도가 만들어진 샘이다.
		- 클래스로부터 객체를 생성하는 방법은 'new'연산자를 사용하는 것이다.
			ex) new 클래스명();
		- 'new'는 클래스로부터 객체를 생성시키는 연산자이다. 
		- 'new' 연산자 뒤에는 생성자가 오는데, 생성자는 클래스() 형태를 가지고 있다.
		- 'new' 연산자로 생성된 객체는 메모리 힙(heap) 영역에 생성된다.
		- 'new' 연산자는 힙 영역에 객체를 생성시킨 후, 객체의 주소를 리턴하도록 되어있다.
		- 리턴 받은 객체의 주소를 참조 타입인 클래스 변수에 저장해두면, 변수를통해 객체를 사용할 수 있다.
			ex) 클래스 변수 = new 클래스();
		참고) Student.java, StudentExample.java
		- 클래스의 용도
			(1) 라이브러리(API : Application Program Interface)용 클래스
				: 다른 클래스에서 이용할 목적으로 설계
			(2) 실행용 클래스
				: 프로그램의 실행 진입점인 main() 메소드를 제공하는 역할
			: 프로그램 전체에서 사용되는 클래스가 100개라면 99개는 라이브러리이고 단 하나가 실행클래스이다.
	
	6.5 composition member of class
		- 구성 멤버에는 필드, 생성자, 메소드가 있다.
		- 구성 멤버들을 생략되거나 복수 개가 작성될 수 있다.
		
	6.5.1 Field
		- 객체의 고유 데이터, 부품 객체, 상태 정보를 저장하는 곳이다.
		- 선언 형태는 변수와 비슷하지만, 필드를 변수라고 부르지 않는다.
		- 변수는 생성자와 메소드 내에섬나 사용되고 생성자와 메소드가 실행 종료되면 자동 소면도니다.
		- 필드는 생성자와 메소드 전체에서 사용되며 객체가 소멸되지 않는 한 객체와 함께 존재한다.
			
	6.5.2 Constructor
		- 'new'연산자로 호출되는 특별한 중괄호 {}블록이다.
		- 객체 생성 시 초기화를 담당한다.
		- 필드를 초기화하거나, 메소드를 호출해서 객체를 사용할 준비를 한다.
		- 생성자는 메소드와 비슷하게 생겼지만, 클래스 이름으로 되어있고 리턴타입이 없다.
	
	6.5.3 Method
		- 객체의 동작에 해당하는 중괄호 {} 블록을 말한다.
		- 중괄호 블록이 가지고 있는 이름이 메소드 이름이다.
		- 메소드를 호출하게 되면 중괄호 블록에 있는 모든 코드들이 일괄적으로 실행된다.
		- 필드를 읽고 수정하는 역할도 하지만, 다른 객체를 생성해서 다양한 기능을 수행하기도 한다.
		- 객체 간의 데이터 전달의 수단으로 사용된다.
		- 외부로부터 매개값을 받거나, 실행 후 어떤 값을 리턴할 수도 있다.
	
	6.6 Field
		- 필드는 객체의 고유 데이터, 객체가 가져야	할 부품, 객체의 연재 상태 데이터를 저장하는 곳이다.
			ex) 자동차 객체 [고유데이터(제작회사, 모델, 색깔, 최고속도)], [상태(현재 속도, 엔진 회전수)],
				[부품(차체, 엔진, 타이어)]
	
	6.6.1 declaration of field
		- 필드 선언은 생성자와 메소드 중괄호 블록 내부를 제외하고 클래스 중괄호 {}블록 어디서든 가능하다.
			ex) 타입 필드 [= 초기값] ;  // 초기값은 선언 이후 대입할 수 있다.
		- 타입에는 기본 타입(byte, short, int, long, float, double, boolean)과
		  참조 타입(배열, 클래스, 인터페이스)이 모두 올 수 있다.
		- 필드의 초기값은 필드 선언시 주어질 수도 있고, 생략될 수도 있다.
		- 초기값이 지정되지 않은 필드들은 객체 생성시 자동으로 기본 초기값으로 설정된다.
		 (byte, short, int -> 0 / char -> \u0000(빈 공백) / long -> 0L / float -> 0.0F /
		  double -> 0.0 / boolean -> false / 배열, 클래스, 인터페이스 -> null)
		참고) FieldInitValue.java, FieldInitvalueExample.java
	
	6.6.2 using field
		- 필드값을 읽고, 변경하는 작업
		- 클래스 내부의 생성자나 메소드에서 사용할 경우 단순히 필드 이름으로 읽고 변경한다.
		- 클래스 외부에서 사용할 경우 우선적으로 객체를 생성한 뒤 필드를 사용해야 한다.
		- 필드는 객체에 소속된 데이터이므로 객체가 존재하지 않으면 필드도 존재하지 않는다.
		참고) Car.java, CarExample.java 
		
	
	6.7 Constructor
		- 생성자는 new 연산자와 같이 사용되어 클래스로부터 객체를 생성할 때 호출되어 객체의 초기화를 담당한다.
		* 객체 초기화 : 필드를 초기화하거나, 메소드를 호출해서 객체를 사용할 준비를 하는 것을 말한다.
		- 생성자를 실행시키지 않고는 클래스로부터 객체를 만들 수 없다.
		- new 연ㅅ나자에 의해 생성자가 성공적으로 실행되면 힙(heap)영역에 객체가 생성되고 객체의 주소가 리턴된다.
		
	6.7.1 default constructor
		- 모든 클래스는 생성자가 반드시 존재하며, 하나 이상을 가질 수 있다.
		- 클래스 내부에 생성자 선언을 생략되어있다면 컴파일러는 기본 생성자를 바이트 코드에 자동 추가시킨다.
			ex) [public] 클래스(){}
		- 기본 생성자로 인해 생성자를 따로 선언하지 않아도 new 연산자 뒤에 기본 생성자를 호출해서 객체를 생성할 수 있다.
		- 클래스에 명시적으로 선언한 생성자가 한 개라도 있으면 컴파일러는 기본 생성자를 추가하지 않는다.
		- 생성자를 명시적으로 선언한 이유는 객체를 다양하게 초기화하기 위해서이다.
		
	6.7.2 declaration of constructor
		- 생성자를 명시적으로 선언하는 방법은 다음과 같다
		----------------------------------------------------------
			클래스( 매개변수선언, ... ) {
				// 생성자 블록
				// 객체의 초기화코드
			}
		----------------------------------------------------------
		- 생성자는 메소드와 비슷한 모양을 가지고 있으나, 리턴타입이 없고 클래스 이름과 동일하다.
		- 생성자 블록 내부에는 객체 초기화 코드가 작성되는데, 일반적으로 필드에 초기값을 저장하거나
		  메소드를 호출하여 객체 사용 전에 필요한 준비를 한다.
		- 매개 변수 선언은 생략과 복수 선언이 모두 가능하다.
		- 매개 변수는 new 연산자로 생성자를 호출할 때 외부의 값을 생성자 블록 내부로 전달한느 역할을 한다.
		- 클래스에 생성자가 명시적으로 선언되어 있을 경우에는 반드시 선언된 생성자를 호출해서 객체를 생성해야 한다.
		참고) CarConstructor.java, CarconstructorExample.java
		
	6.7.3 field initialization 
		- 클래스로부터 객체가 생성될 떄 필드는 기본 초기값으로 자동 설정된다.
		- 임의의 초기값을 주는 방법에는 선언시 대입하는 방법과 생성자에서 초기값을 대입하는 방법이 있다.
		- 필드 선언시 초기값을 부여하면 동일한 클래스로부터 생성되는 객체들은 객체 생성 시점에 모두 같은 데이터를 갖게 된다.
		  ( 객체 생성 후 변경이 가능하다. )
		- 객체 생성 시 외부에서 제공되는 다양한 값들로 초기화되어야 한다면 생성자에서 초기화 해야한다.
		참고) Korean.java, KoreanExample.java
		- 생성자의 매개변수 이름은 관례적으로 필드와 동일한 이름을 사용한다.
		- 이 경우 필드와 매개변수의 이름이 동일하기 때문에 생성자 내부에서 해당 필드에 접근 할 수 없다.
		  (동일한 이름의 매개 변수가 사용 우선순위가 높기 때문이다.)
		- 필드 앞에 'this.'를 붙여서 해결한다. (this는 객체 자신을 의미한다.)
		----------------------------------------------------------
			public Korean(String name, String ssn){
				this.name = name;	// this.name -> 필드 , name -> 매개 변수
				this.ssn = ssn;		// this.ssn -> 필드 , ssn -> 매개 변수
			}
		----------------------------------------------------------
		
	6.7.4 constructor overloading
		- 외부에서 제공되는 다양한 데이터들을 이용해서 객체를 초기하하려면 생성자도 다양화되어야 한다.
		* 생성자 오버로딩 : 매개변수를 달리하는 생성자를 여러 개 선언하여 다양한 방법으로 객체를 생성할 수 있도록하는 것
		- 생성자 매개 변수의 타입과 개수, 선언된 순서가 똑같은 경우 매개 변수 이름만 바꾸는 것은 생성자 오버로딩이 아니다.
		- 생성자가 오버로딩 되어있을 경우, new 연산자로 생성자를 호출할 때 제공되는 매개값의 타입과 수에 의해 
		  호출될 생성자가 결정된다.
		참고) CarOverloading.java, CarOverloadingExample.java 
		
	6.7.5 call another constructor(this())
		- 생성자 오버로딩이 많아질 경우 생성자 간의 중복된 코드가 발생할 수 있다.
		- 필드 초기화 내용은 한 생성자에만 집중적으로 작성하고 나머지 생성자는 초기화 내용을 가지고 있는 생성자를
		  호출하는 방법으로 개선할 수 있다.
		- 생성자에서 다른 생성자를 호출할 때에는 this()코드를 사용한다.
		----------------------------------------------------------
			클래스([매개변수선언, ...]) {
				this( 매개변수, ..., 값, ...); 	// 클래스의 다른 생성자를 호출한다.
				실행문;
			}
		----------------------------------------------------------
		- this()는 자신의 다른 생성자를 호출하는 코드로 반드시 생성자의 첫줄에서만 허용된다.
		- this()의 매개값은 호출되는 생성자의 매개 변수 타입에 맞게 제공해야 한다.
		- this() 다음에는 추가적인 실행 문들이 올 수 있다.
		참고) CarThisMethod.java, CarThisMethodExample.java
		
	
	6.8 Method
		- 메소드는 객체의 동작에 해당한느 중괄호 {}블록을 말한다.
		- 중괄호 블록의 이름은 메소드 이름이다.
		- 메소드를 호출하게되면 중괄호 블록에 있는 모든 코드들이 일괄적으로 실행된다.
		- 메소드는 필드를 읽고 수정하는 역할도 하지만, 다른 객체를 생성해서 다양한 기능을 수행하기도 한다.
		- 메소드는 객체간의 데이터 전달의 수단으로 사용된다.
		- 외부로 부터 매개값을 받을 수 도 있고, 실행 후 어떤 값을 리턴할 수도 있다.
	
	6.8.1 declaration of method
		- 메소드 선언은 선언부(리턴타입, 메소드이름, 매개변수선언)와 실행 블록으로 구성된다.
		- 시그너처(signature) : 메소드 선언부
		1) return type
			- 메소드가 실행 후 리턴하는 값의 타입
			- 리턴값이 있을 수도 있고 없을 수도 있다.
			- 실행 후 결과를 호출한 곳에 넘겨줄 경우에는 리턴값이 있어야 한다.
			- 리턴 값이 없는 메소드는 리턴 타입에 void가 와야한다.
			- 리턴 값이 있는 메소드는 리턴 값의 타입이 리턴타입에 와야한다.
			- 리턴 값이 있는 메소드를 호출할 때에는 리턴된 값을 저장하기 위해서는 변수가 선언되어야 한다.
			  (이때 변수는 리턴 값과 타입이 동일해야 한다.)
			- 리턴 타입이 있다고 해서 반드시 리턴 값을 변수에 저장할 필요는 없다.
		2) method name
			- 메소드 이름은 자바 식별자 규칙에 맞게 작성한다
				(1) 숫자로 시작하면 안되고, $와 _를 제외한 특수 문자를 사용할 수 없다.
				(2) 관례적으로 메소드명은 소문자로 작성한다
				(3) 서로 다른 단억 ㅏ혼합된 이름이라면 뒤이어 오는 단어의 첫 머리 글자는 대문자로 작성한다
		3) declaration of parameter
			- 메소드가 실행할 때 필요한 데이터를 외부로부터 받기 위해 사용된다.
			- 매개값은 반드시 매개 변수의 타입과 수에 부합되어야 한다
			참고) Calculator.java, CalculatorExample.java
		4) 매개 변수의 수를 모를 경우
			- 메소드의 매개 변수는 개수가 이미 정해져 있는 것이 일반적이지만, 경우에 따라서는 메소드를
			  선언할 때 매개 변수의 개수를 알 수 없는 경우가 있다.
				ex) 여러 개의 수를 모두 합산하는 메소드 -> 몇 개의 매개 변수가 입력될지 알 수 없다.
			- 매개 변수를 배열 타입으로 선언하여 해결한다.
			----------------------------------------------------------
				int sum1(int[] values){ }
				
				int[] values = { 1, 2, 3 };
				int result = sum1(values);
				int result = sum1(new int[] { 1, 2, 3, 4, 5 };
			----------------------------------------------------------
			- 매개 변수를 배열 타입으로 선언하면, 메소드를 호출하기 전에 배열을 생성해야 하는 불편함이 있다.
			  그래서 배열을 생성하지 않고 값의 리스트만 넘겨주는 방법도 있다.
			- 매소드의 매개 변수를 '...'을 사용해서 선언하게 되면, 메소드 호출 시 넘겨준 값의 수에 따라\
			  자동으로 배열이 생성되고 매개값으로 사용된다.
			----------------------------------------------------------
				int sum2(int ... values){ }
				
				int result = sum2(1, 2, 3);
				int result = sum2(1, 2, 3, 4, 5);
			
				'...'으로 선언된 배개 변수는 배열 타입이므로 배열을 직접 매개값으로 사용해도 좋다.
				int[] values = { 1, 2, 3 };
				int result = sum2(values);
				int result = sum2(new int[] { 1, 2, 3, 4, 5 });
			----------------------------------------------------------
			참고) Computer.java	computerExample.java
			
	6.8.2 return
		1) 리턴값이 있는 메소드
			- 메소드 선언에 리턴 타입이 있는 메소드는 반드시 리턴(return)문을 사용해서 리턴 값을 지정해야 한다.
			- return문이 실행되면 메소드는 즉시 종료된다.
			- return문의 리턴값은 리턴 타입이거나 리턴 타입으로 변환될 수 있어야 한다.
				ex) 리턴타입 int -> byte, short, int 타입의 값을 리턴할 수 있다. (자동 타입 변환)
			* 'Unreachable code' 컴파일 에러 : return문 이후에 실행문을 작성할 경우,
											return문 이후의 실행문은 절대 실행되지 않는다. 
			- 조건문 블록 내부에 return문이 선언되어있고 이후 조건문 외부에 선언된 실행문은
			  조건문이 실행되면 실행되지 않고 조건문이 실행되지 않으면 실행된다.
			----------------------------------------------------------
				boolean isLeftGas(){
					if(gas==0){
						System.out.println("gas가 없습니다");
						return false;
					}
					System.out.println("gas가 있습니다");
					return true;
			----------------------------------------------------------
		2) 리턴값이 없는 메소드(void)
			- void로 선언된 리턴값이 없는 메소드에서도 return문을 사용할 수 있다.
			- 리턴값 없이 return문을 사용하면 메소드 실행을 강제로 종료시킨다. ex) return;
			참고) CarReturn.java,	CarReturnExample.java
			
	6.8.3 메소드 호출
		- 메소드는 클래스 내, 외부의 호출에 의해 실행된다.
		- 클래스 내부의 다른 메소드에서 호출할 경우에는 단순한 메소드 이름으로 호출하면 되지만,
		  클래스 외부에서 호출할 경우에는 클래스로부터 객체를 생성한 뒤, 참조 변수를 이용해서 메소드를 호출해야 한다.
		  객체가 존재해야 메소드도 존재하기 때문이다.
		1) 객체 내부에서 호출
			- 클래스 내부에서 다른 메소드를 호출할 경우에는 '메소드( 매개값, ... );'의 형태로 작성한다.
			  메소드가 매개 변수를 가지고 있을 때에는 매개 변수의 타입과 수에 맞게 매개값을 제공한다.
			- 메소드의 리턴값을 저장하는 변수의 타입은 리턴 타입과 동일하거나, 타입 변환이 될 수 있어야 한다.
			참고) CalculatorCallMethod.java,	CalculatorCallMethodExample.java
		2) 객체 외부에서 호출
			- 외부 클래스에서 메소드를 호출하려면 new 연산자를 사용하여 클래스로부터 객체를 생성해야 한다.
			  (객체가 존재하지 않으면 메소드도 존재하지 않는다)	
			- 객체가 생성되었다면 참조변수와 함께 도트(.) 연산자를 사용해서 메소드를 호출할 수 있다.
			- 도트(.) 연산자는 객체 접근 연산자로 객체가 가지고 있는 필드나, 메소드에 접근할 대 사용한다.
			참고) CarCallMethodOutClass.java, CarCallMethodOutClassExample.java
		3) method overloading
			- 클래스 내에 같은 이름의 메소드를 여러개 선언하는 것
			- 메소드 오버로딩의 조건은 매개 변수의 타입, 개수, 순서중 하나가 달라야 한다.
			- 매개값을 다양하게 받아 처리할 수 있도록 하기 위해서이다.
			- 오버로딩된 메소드를 호출할 경우 JVM은 매개값의 타입을 보고 메소드를 선택한다.
			- 매개 변수 타입일 일치하지 않을 경우 JVM은 자동 타입 변환이 가능한지 검사한다.
			- 매개 변수의 타입과 개수, 순서가 똑같을 경우 매개 변수 이름만 바꾸는 것은 메소드 오버로딩이 아니다.
			- 또한 리턴 타입만 다르고 매개 변수가 동일한 경우도 오버로딩이 아니다.(컴파일 오류 발생)
			- 'System.out.println()'은 대표적인 메소드 오버로딩의 예다. println() 메소드는 
			  호출할 때 주어진 매개값의 타입에 따라서 오버로딩 된 println() 메소드를 호출한다.
			참고) CalculatorMethodOverloading.java, CalculatorMethodOverloadingExample.java 
	
	
	6.9 instance member and this
		- 인스턴스 멤버란 객체(instance)를 생성한 후 사용할 수 있는 필드(인스턴스 필드)와 메소드(인스턴스 메소드)를 말한다.
		- 인스턴스 멤버를 외부 클래스에서 사용하기 위해서는 해당 객체(인스턴스)를 생성하고 참조 변수로 접근해야 한다.
		- 인스턴스 필드는 객체마다 따로 존재한다.
		- 인스턴스 메소드는 객체마다 존재하는 것이 아니라 메소드 영역에 저장되고 공유된다.
		- 객체 외부에서 인스턴스 멤버에 접근하기 위해 참조 변수를 사용하는 것과 마찬가지로
		  객체 내부에서도 인스턴스 멤버에 접근하기 위해 this를 사용할 수 있다. this는 객체 자신을 의미한다.
		참고) CarInstanceMemberAndThis.java,	CarInstanceMemberAndThisExample.java
		
	6.10 static member and static
		- 정적 멤버는 클래스에 고정된 멤버로서 객체를생성하지 않고 사용할 수 있는 필드와 메소드를 말한다.
		- 각각 정적 필드, 정적 메소드라고 부른다. 클래스에 소속된 멤버이기 때문에 클래스 멤버라고도 한다.
		
	6.10.1 declaration of static member
		- 필드와 메소드 선언 시 static 키워드를 추가적으로 붙인다.
			ex) static 타입 필드 [= 초기값];	// 정적 필드
				static 리턴타입 메소드( 매개변수선언, ... ) { ... }	// 정적 메소드
		- 클래스 로더가 클래스(바이트 코드)를 로딩해서 메소드 메모리 영역에 적재할 때 클래스별로 관리된다.
		- 클래스의 로딩이 끝나면 바로 사용할 수 있다.
		- 필드를 선언할 때 객체마다 가지고 있어야 할 데이터라면 인스턴스 필드로 선언하고,
		  각 객체들이 공용적으로 사용하는 데이터라면 정적 필드로 선언하는 것이 좋다.
		  	ex) 계산기 클래스에서 원의 넓이나 둘레를 구할 때 필요한 파이(3.14195...)는
		  		객체마다 가지고 있을 필요가 없는 변하지 않는 공용적인 데이터이므로 정적필드로 선언하는 것이 좋다.
		- 메소드를 선언할 때 메소드가 인스턴스 필드를 이용해서 실행해야 한다면 인스턴스 메소드로 선언하고,
		  인스턴스 필드를 이용하지 않는 다면 정적 메소드로 선언한다.
		  	ex) 계산기 클래스에서 사칙연산 기능은 인스턴스 필드를 이용하기 보다는
		  		외부에서 주어진 매개값들을 가지고 사직연산을 수행하므로 정적 메소드로 선언하는 것이 좋다.
		
	6.10.2 using static member
		- 클래스가 메모리로 로딩되면 정적 멤버를 바로 사용할 수 있다.
		- 클래스 이름과 함께 도트(.) 연산자로 접근한다.
			ex) 클래스명.필드명;	클래스명.메소드명(매개값, ...);
		- 원칙적으로는 클래스명으로 접근해야 하지만 객체 참조 변수로도 접근할 수 있다.
		  ( 클래스명으로 접근하는 것을 권장한다 )
		참고) UsingStaticMember.java, UsingStaticMemberRuntime.java
		
	6.10.3 static initialization block
		- 정적 필드는 필드 선언과 동시에 초기값을 주는 것이 보통이다.
		- 정적 필드는 생성자에서 초기화 할 수 없다.
		- 초기화 작업이 필요한 경우 정적 블록(static block)에서 한다.  
			ex) static { ... }
		- 정적 블록은 클래스가 메모리로 로딩될 때 자동적으로 실행된다.
		- 클래스 내에 여러개가 선언 될 수 있다. 선언된 순서대로 실행된다
		참고) TelevisionStaticBlock.java,	TelevisionStaticBlockRuntime.java
		
	6.10.4 정적 메소드와 블록 선언시 주의할 점
		- 정적 메소드와 블록은 객체가 없어도 실행되기 때문에 이들 내부에 인스턴스 멤버를 사용할 수 없다.
		  this 키워드 역시 사용할 수 없다. (컴파일 오류 발생)
		- 정적 메소드와 블록에서 인스턴스 멤버를 사용하기 위해서는 객체를 생성하고 참조 변수로 접근해야 한다.
		----------------------------------------------------------
			static void method() {
				클래스명 변수명 = new 클래스명();	
				변수명.인스턴스필드명 = 10;
				변수명.인스턴스메소드명();
			}
		----------------------------------------------------------
		- main() 메소드도 정적 메소드이므로 객체 생성 없이 인스턴스 필드와 메소드를 사용할 수 없다.
		
	6.10.5 singleton
		- 전체 프로그램에서 단 하나의 객체만 만들도록 제한된 객체
		- 클래스 외부에서 new 연산자로 생성자를 호출할 수 없도록 생성자 앞에 private 접근 제어자를 사용한다.
		- 자신의 타입인 정적 필드를 하나 선언하고 자신의 객체를 생성해 초기화한다.
		  ( 클래스 내부에서는 new 연산자로 생성자 호출이 가능하다.)
		- 정적 필드에도 private 접근 제한자를 명시하여 외부에서 필드 값을 변경하지 못하도록 막는다.
		- 외부에서 호출 할 수 있는 정적 메소드인 getInstance()를 선언하여
		  정적 필드에서 참조하고 있는 자신의 객체를 리턴한다.
		----------------------------------------------------------
			public class 클래스명 {
				// static field
				private static 클래스명 singleton = new 클래스명();
				
				// constructor
				private 클래스명(){}
				
				// static method
				static 클래스명 getInstance(){
					return singleton;
			}
		---------------------------------------------------------- 
		- 외부에서 객체를 얻은 유일한 방법은 getInstance() 메소드를 호출하는 것이다.
		- getInstance() 메소드는 단 하나의 객체만 리턴하므로 여러 변수에 각각 호출하더라도
		  모든 변수는 동일한 객체를 참조한다.
		참고) Singleton.java, SingletonRuntime.java
		
	
	6.11 final field and static final
	6.11.1 final field
		- 초기값이 저장되면 이것이 최종적인 값이 되어서 프로그램 실행 도중에 수정할 수 없는 필드
			ex) final 타입 필드명 [= 초기값];
		- final field의 초기값은 필드 선언시에 부여하거나 생성자를 통해서 부여하는 방법 뿐이다.
		- 단순 값이라면 필드 선언시에 부여한다.
		- 객체 생성시 외부 데이터로 초기화해야 한다면 생성자에서 초기값을 지정한다.
		참고) PersonFinalField.java,	PersonFinalFieldRuntime.java
		
	6.11.2 static final
		- final field : 객체마다 저장되고, 생성자의 매개값을 통해서 여러가지 값을 가질 수 있다.
		- constant(상수) : 불변의 값을 저장하는 필드, 공용성을 가지고 있으며 여러가지 값으로 초기화될 수 없다.
						: 'static final 타입 상수명 [= 초기값];'와 같이 선언한다.
						: 초기값이 단순 값이라면 선언시에, 복잡한 초기화일 경우 정적 블록에서 부여한다.
						: 상수 이름은 모두 대문자로 작성하는 것이 관례이다. 2개 이상의 단어가 쓰이면 '_'로 구분한다.
		----------------------------------------------------------
			static final 타입 상수;
			static {
				상수 = 초기값;
			}
			
			static final double PI = 3.14159;
			static final double EARTH_SURFACE_AREA;
		----------------------------------------------------------
		참고) EarthStaticFinal.java,	EarthStaticFinalRuntime.java
		
		
	6.12 package
		- 클래스를 체계적으로 관리하기 위해 패키지를 만들어 클래스를 저장한다.	ex) 파일시스템의 폴더
		- 패키지는 클래스의 일부분으로서 클래스를 유일하게 만들어주는 식별자 역할도 한다.
		- 클래스의 전체 이름은 '패키지명.클래스명', 상하위를 도트(.)를 사용하여 표현한다.
			ex) '상위패키지.하위패키지.클래스명'
	
	6.12.1 declaration of package
		- 패키지는 클래스를 컴파일하는 과정에서 자동적으로 생성된다. ( 클래스에 선언되어있는 패키지 선언을 참고한다 )
		----------------------------------------------------------
			package 상위패키지.하위패키지;
			
			public class 클래스명 { ... }
		----------------------------------------------------------
		- 패키지명 규칙
			(1) 숫자로 시작해서는 안된다.
			(2) $, _ 를 제외한 특수 문자를 사용할 수 없다.
			(3) java로 시작하는 패키지는 사용할 수 없다.(자바 표준 API에서만 사용한다.)
			(4) 모두 소문자로 작성하는 것이 관례이다.
			(5) 여러 회사가 참여하는 대규모 프로젝트에서는 패키지 명의 중복을 피하기위해
				회사의 도메인 이름으로 패키지를 만든다. (도메인 이름 역순으로 패키지 이름을 짓는다.)
					ex) com.eclipse.프로젝트명
	
	6.12.2 패키지 선언이 포함된 클래스 컴파일
		- 패키지 선언이 포함된 클래스를 명령 프롬프트에서 컴파일 하기위해서는
		  'javac' 명령어 다음에 '-d'옵션을 추가하고 페키지가 생성될 경로를 지정해야 한다.
		  ----------------------------------------------------------
		  	javac -d .				클래스명.java	-> 현재 폴더 내에 생성
		  	javac -d ..\bin			클래스명.java -> 현재 폴더와 같은 위치의 bin 폴더에 생성
		  	javac -d C:\Temp\bin	클래스명.java -> C:\Temp\bin 폴더에 생성
		  ----------------------------------------------------------
		참고)ApplicationDeclarationOfPackage.java
		
	6.12.3 이클립스에서 패키지 생성과 클래스 생성
		- 이클립스에서는 패키지만 따로 생성할 수 있고, 클래스를 생성할 때 동시에 생성시킬 수도 있다.
		- 이클립스 패키지 생성방법
		  [프로젝트의 src폴더 선택 -> 메뉴 -> File -> New -> Package] 또는 [src폴더 오른쪽 클릭 -> New -> Package ]
		  -> [Name] 입력난에 상위 패키지와 하위 패키지를 도트(.)로 입력해서 구분 -> [Finish]
		- 이클립스는 기본적으로 패키지를 Flat 방식으로 표시한다.
		- 상하위 패키지를 계층적으로 보고자 한다면,
		  [Package Explorer 우측 상단 역 삼각형 버튼 -> Package Presentation -> Hierarchical]을 선택한다.
		- 클래스 생성 방법
		  [해당 패키지 선택 -> 메뉴 -> File -> New -> Class] or [해당 패키지 선택 -> 마우스 오른쪽 버튼 -> New -> Class ]
		- 이클립스는 src에 있는 모든 내용을 컴파일해서 bin 폴더에 생성시킨다.
		- Navigator 뷰에서 bin 폴더를 확인할 수 있다. ([Window -> Show View -> Navigator])
		- 이클립스는 패키지 선언이 없는 클래스를 default 패키지에 포함시킨다. default패키지는 사실상 패키지가 없다는 뜻이다.
		  
	6.12.4 import
		- 같은 패키지의 클래스들은 아무런 조건 없이 다른 클래스를 사용할 수 있다.
		- 다른 패키지에 속하는 클래스를 사용하려면 패키지와 클래스를 모두 기술하는 방법과
		  import문을 사용하는 방법이 있다.
		- import문은 패키지 선언과 클래스 선언 사이에 작성한다.
		- 동일한 패키지에 포함된 다수의 클래스를 사용해야한다면 클래스명을 생략하도 '*'을 사용한다.
		- import문의 개수는 제한이 없다.
		- import문으로 지정된 패키지의 하위 패키지는 import 대상에서 제외된다.
		- 하위 패키지의 클래스를 사용하고자 한다면 import문을 하나 더 작성해야 한다.
		- 서로 다른 패키지에 동일한 클래스 이름이 존재하고 두 패키지가 모두 import되어 있을 경우
		  패키지 이름 전체를 기술하는 방법이 필요하다.
		참고) classTutorial.importTest.hankook.SnowTire.java
		  	 classTutorial.importTest.hankook.Tire.java
		  	 classTutorial.importTest.kumho.BigWidthTire.java
		  	 classTutorial.importTest.kumho.Tire.java
		  	 classTutorial.importTest.hyndai.Engine.java
		  	 classTutorial.importTest.mycompany.Car.java
		  	 
	6.13 access modifier
		- main() 메소드를 가지지 않은 대부분의 클래스는 외부 클래스에서 이용할 목적으로 설계된
		  라이브러리 클래스이다.
		- 라이브러리 클래스를 설계할 때에는 외부 클래스에서 접근할 수 있는 멤버와
		  접근할 수 없는 멤버로 구분해서 설계하는것이 바람직하다.
		- 객체 생성을 막기 위해 생성자를 호출하지 못하게 하거나,
		  객체의 특정 데이터를 보호하기 위해 해당 필드에 접근하지 못하도록 막아야 한다.
		- 특정 메소드를 호출할 수 없도록 제한할 필요가 있다.
		----------------------------------------------------------
			접근 제한		적용 대상						접근할 수 없는 클래스
			public		클래스, 필드, 생성자, 메소드		없음(자유롭게 사용가능하다)
			protected	필드, 생성자, 메소드			자식 클래스가 아닌 다른 패키지에 소속된 클래스
													(같은 패키지 또는 자식 클래스에서 사용할 수 있다.)
			default		클래스, 필드, 생성자, 메소드		다른 패키지에 소속된 클래스
													(같은 패키지에 소속된 클래스에서 사용할 수 있다.)
			private		필드, 생성자, 메소드			모든 외부 클래스
													(같은 클래스의 멤버만 접근할 수 있다.)
		----------------------------------------------------------
		
		
	6.14 Getter, Setter
		- 객체의 데이터를 외부에서 마음대로 읽고 변경할 경우 객체의 무결성(결점이 없는 성질)이 깨어질 수 있다.
		- 무결성을 보장하기 위해 일반적으로 객체지향 프로그래밍에서 객체의 데이터는 객체 외부에서 직접적으로
		  접근하는 것을 막는다.
		- 직접 접근하는 것을 지양하고 메소드를 통해서 데이터를 변경하는 방법을 선호한다.
		- 데이터는 외부에서 접근할 수 없도록 막고 메소드는 공개해서 외부에서 메소드를 통해 데이터에 접근하도록 유도한다.
		- 메소드는 매개값을 검증해서 유효한 값만 데이터로 저장할 수 있기 때문이다.
		- 이러한 역할을 하는 메소드가 Setter이다.
		- 외부에서 객체의 데이터를 읽을 때도 메소드를 사용하는 것이 좋다. 이런 역할을 하는 메소드가 Getter이다.
		- 클래스를 선언할 때 가능하다면 필드를 private로 선언해서 외부로부터 보호하고
		  필드에 대한 Setter와 Getter 메소드를 작성해서 필드값을 안전하게 변경/사용하는 것이 좋다.
		- 필드 타입이 boolean일 경우에는 Getter는 get으로 시작하지 않고 is로 시작하는 것이 관례이다.
		참고) CarGetterAndSetterDeclaration.java,	CarGetterAndSetterDeclarationRuntime.java
		
		
	6.15 annotation
		- 어노테이션은 메타데이터라고 볼 수 있다.
		- 메타데이터란 컴파일 과정과 실행 과정에서 코드를 어떻게 컴파일하고 처리할 것일지를 알려주는 정보이다.
		- 컴파일러에게 코드 문법 에러를 체크하도록 정보를 제공한다.
		- 소프트웨어 개발 툴이 빌드나 배치 시 코드를 자동으로 생성할 수 있도록 정보를 제공한다.
		- 실행 시(런타임 시) 특정 기능을 실행하도록 정보를 제공한다.
		* @Override : 컴파일러에게 메소드가 오버라이드(재정의)된 것임을 알려주어
					  컴파일러가 오버라이드 검사를 하도록 해준다.
					  정확히 오버라이드가 되지 않았다면 컴파일러는 에러를 발생시킨다.
		- 어노테이션은 빌드 시 자동으로 XML 설정 파일을 생성하거나, 배포를 위해 JAR 압축 파일을 생성하는 데에도 사용한다.
		- 실행시 클래스의 역할을 정의하기도 한다.
		
	6.15.1 어노테이션 타입 정의와 적용
		- 어노테이션 타입을 정의하는 방법은 인터페이스를 정의하는 것과 유사하다
		----------------------------------------------------------
			선언->	public @interface AnnotationName { }
		
			사용->	@AnnotationName
		----------------------------------------------------------
		- 어노테이션은 엘리먼트를(element)를 멤버로 가질 수 있다
		- 각 엘리먼트는 타입과 이름으로 구성되며, 디폴트 값을 가질 수 있다.
		----------------------------------------------------------
			public @interface AnnotationName {
				타입 엘리먼트이름() [default값];		// 엘리먼트 선언
			}	
		----------------------------------------------------------
		- 엘리먼트의 타입으로는 기본 데이터 타입이나 String, 열거타입, Class타입 그리고 이들의 배열타입을 사용할 수 있다.
		----------------------------------------------------------
			public @interface AnnotationName {
				String 엘리먼트이름1();
				int 엘리먼트이름2() default 5;
			}
		
			@AnnotationName(엘리먼트이름1 = "값", 엘리먼트이름2 = 3);
			or
			@AnnotationName(엘리먼트이름1 = "값");
		----------------------------------------------------------
		- 엘리먼트이름1은 디폴트 값이 없기 때문에 반드시 값을 기술해야 한다.
		- 엘리먼트이름2는 디폴트 값이 있기 때문에 생략 가능하다.
		- 어노테이션은 기본 엘리먼트인 value를 가질 수 있다.
		----------------------------------------------------------
			public @interface AnnotationName {
				String value();		// 기본 엘리먼트 선언
				int 엘리먼트이름() default 5;
			}
		----------------------------------------------------------
		- value 엘리먼트를 가진 어노테이션을 코드에서 적용할 때는 '@AnnotationName("값");'과 같이 기술한다.
		- value 엘리먼트와 다른 엘리먼트의 값을 동시에 주고자 한다면,
		  '@AnnotationName(value = "값", 엘리먼트이름 = 3);'과 같이 기술한다.	
		  
	6.15.2 어노테이션 적용 대상
		- 어노테이션을 적용할 수 있는 대상은 java.lang.annotation.ElementType 열거 상수로 정의되어있다.
		----------------------------------------------------------
			ElementType 열거 상수			적용 대상
			TYPE						클래스, 인터페이스, 열거타입
			ANNOTATION_TYPE				어노테이션
			FIELD						필드
			CONSTRUCTOR					생성자
			METHOD						메소드
			LOCAL_VALRABLE				로컬 변수
			PACKAGE						패키지
		----------------------------------------------------------
		- 어노테이션이 적용될 대상을 지정할 때에는 @Target 어노테이션을 사용한다.
		- @Target의 기본 엘리먼트인 value는 ElementType 배열을 값으로 가진다.
		  적용될 대상을 복수개로 지정하기 위해서이다.
		----------------------------------------------------------
			@Target({ElementType.TYPE, ElementType.FIELD, ElementType.METHOD})
			public @interface AnnotationName { }
		
			@AnnotationName
			public class ClassName {
				@AnnotationName		
				private String fieldName;
				
				// @AnnotationName			// @Target에 CONSTRUCTOR가 없어 생성자는 적용하지 못한다.
				public ClassName(){ }
				
				@AnnotationName
				public void methodName() { }
			}
		----------------------------------------------------------
		
	6.15.3 어노테이션 유지 정책
		- 어노테이션 정의 시 사용 용도에 따라 @AnnotationName을 어느 범위까지 유지할 것인지 지정해야한다.
		  ( 소스상에서만 유지할 것인지, 컴파일된 클래스까지 유지할 것인지, 런타임 시에도 유지할 것인지 )
		- 어노테이션 유지 정책은 'java.lang.annotation.RetentionPolicy' 열거 상수로 정의되어있다.
		----------------------------------------------------------
			RetentionPolicy 열거 상수		설명
			SOURCE						소스상에서만 어노테이션 정보를 유지한다.
										소스 코드를 분석할 때만 의미가 있으며,
										바이트 코드 파일에는 정보가 남지 않는다.
			CLASS						바이트 코드 파일까지 어노테이션 정보를 유지한다.
										하지만 리플렉션을 이용해서 어노테이션 정보를 얻을 수는 없다.
			RUNTIME						바이트 코드 파일까지 어노테이션 정보를 유지하면서
										리플렉션을 이용해서 런타임 시에 어노테이션 정보를 얻을 수 있다.
		----------------------------------------------------------
		* reflection(리플렉션) : 런타임 시에 클래스의 메타 정보를 얻는 기능이다.
							( 예를 들어 클래스가 가지고 있는 필드가 무엇인지, 어떤 생성자를 갖고 있는지,
							어떤 메소드를 가지고 있는지, 적용된 어노테이션이 무엇인지 알아내는 것이다. )
		- 리플렉션을 이용해서 런타임 시에 어노테이션 정보를 얻으려면 어노테이션 유지 정책을 RUNTIME으로 설정해야 한다.
		- 어노테이션 유지 정책을 지정할 때에는 '@Retention'어노테이션을 사용한다
		- '@Retention'의 기본 엘리먼트인 value는 RetentionPolicy타입이므로 3가지 열거 상수 중 하나를 지정하면 된다.
		----------------------------------------------------------
			@Target({ElementType.TYPE, ElementType.FIELD, ElementType.METHOD})
			@Retention(RetentionPolicy.RUNTIME)
			public @interface AnnotationName {
			}
		----------------------------------------------------------
		
	6.15.4 런티임 시 어노테이션 정보 사용하기
		- 어노테이션 자체는 아무런 동작을 가지지 않는 단지 표식일 뿐이지만, 리플렉션을 이용해서
		  어노테이션의 적용 여부와 엘리먼트 값을 읽고 적절히 처리할 수 있다.
		- 클래스에 적용된 어노테이션 정보를 얻기위해서는 'java.lang.Class'를 사용한다.
		- 필드, 생성자, 메소드에 적용된 어노테이션 정보를 얻으려면 Class의 메소드를 통해서
		  'java.lang.reflect' 패키지의 Field, Constructor, Method 타입의 배열을 얻어야 한다.
		----------------------------------------------------------
			리턴 타입			메소드명(매개 변수)			설명		
			Field[]			getFields()				필드 정보를 Field 배열로 리턴한다.
			Constructor[]	getConstructors()		생성자 정보를 Constructor 배열로 리턴한다.
			Method[]		getDeclaredMethods()	메소드 정보를 Method 배열로 리턴한다.
		----------------------------------------------------------
		- 각 Class, Field, Constructor, Method가 가지고 있는 메소드를 호출해서
		  적용된 어노테이션 정볼르 얻을 수 있다.
		----------------------------------------------------------
			리턴 타입			메소드명(매개변수)
			boolean			isAnnotationPresent(Class<? extends Annotation> annotationClass)
							지정한 어노테이션이 적용되었는지 여부, Class에서 호출했을 때 상위 클래스에 적용된
							경우에도 true를 리턴한다.
			Annotation		getAnnotation(Class<T> annotationClass)
							지정한 어노테이션이 적용되어 있으면 어노테이션을 리턴하고 그렇지 않다면 null을 리턴한다. 
							Class에서 호출했을 때 상위 클래스에 적용된 경우에도 어노테이션을 리턴한다.
			Annotation[]	getAnnotations()
							적용된 모든 어노테이션을 리턴한다. Class에서 호출했을 때 상위 클래스에 적용된 어노테이션도
							모두 포함한다. 적용된 어노테이션이 없을 경우 길이가 0인 배열을 리턴한다.
			Annotation[]	getDeclaredAnnotations()
							직접 적용된 모든 어노테이션을 리턴한다. Class에서 호출했을 때 상위 클래스에 적용된
							어노테이션은 포함되지 않는다.
		----------------------------------------------------------
		참고) PrintAnnotation.java,	ServiceAnnotation.java,	PrintAnnotationRuntime.java
				
		
			
						