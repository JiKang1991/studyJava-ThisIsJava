	chapter006 class
	
	-- Table of contents --
		6.1 object oriented programming
		6.2 object and class
		6.3 declaration of class
		6.4 creation of object and class variable
		6.6 composition member of class
		6.6 field
		6.7 constructor
		6.8 method
		6.9 instance member and this
		6.10 static member and static
		6.11 final field and constant
		6.12 package
		6.13 access modifier
		6.14 getter and setter method
		6.15 anotation
	-----------------------
	
	6.1 OOP(object oriented programming)
		- 부품에 해당하는 객체들을 먼저 만들고 ,이것들을 하났기 조립해서 완성된 프로그램을 만드는 기법
	
	6.1.1 about object
		* object : 물리적으로 존재하거나 추상적으로 생각할 수 있는 것 중에서
				   자신의 속성을 가지고있고 다른 것과 식별 가능한 것
				   ex) 자동차, 자전거, 책, 사람 / 학과, 강의, 주문 등
				 : 속성(field)과 동작(method)으로 구성되어 있다.
				   ex)  사람 -> (속성) 이름, 나이 등 / (동작) 웃다, 걷다 등
				   		자동차 -> (속성) 색상, 모델명 등 / (동작) 달린다, 멈춘다
		* Object Modeling : 현실세계의 객체를 소프트웨어 객체로 설걔하는 것
		
	6.1.2 interaction of object
		- 객체들은 각각 독립적으로 존재하고, 다른 객체와 서로 상호작용 하면서 동작한다.
		* 메소드 호출 : 객체가 다른 객체의 기능을 이용하는것
		- 객체들 사이의 상호작용 수단은 메소드이다. 객체가 다른 객체의 기능을 이용하며 상호작용한다.
		- '객체.메소드이름(매개값)' : 메소드 호출의 방법, 도트연산자(.)는 객체의 필드와 메소드에 접근할 때 사용한다.
		- 매개값은 메소드를 실행하기 위해 필요한 데이터이다.
		- 객체의 상호작용은 객체 간의 메소드 호출ㅇ르 의미하며 매개값과 리턴값을 통해서 데이터를 주고 받는다.
		
	6.1.3 relationship between objects
		- 객체는 개별적으로 사용될 수 있지만, 대부분 다른 객체와 관계를 맺고 있다.
		- 관계의 종류에는 집합관계, 사용관계, 상속관계가 있다.
		- 집합 관계에 있는 객체는 하나는 부품이고 하나는 완성품에 해당한다.
		  ex) 자동차, 엔진, 타이어, 핸들
		- 사용관계는 객체 간의 상호작용을 말한다. 객체는 다른 객체의 메소드를 호출하여 원하는 결과를 얻어낸다.
		  ex) 사람, 자동차(달린다, 멈춘다)
		- 상속관계는 상위(부모) 객체를 기반으로 하위(자식) 객체를 생성하는 관계를 말한다.
		- 일반적으로 상위 객체는 종류를 의미하고, 하위 객체는 구체적인 사물에 해당한다.
		  ex) 기계(상위), 자동차(하위)
		- 객체 지향 프로그래밍은 만들고자 하는 완성품인 객체를 모델링하고, 집합 관계에 있는 부품 객체와 사용 관계에 있는
		  객체를 하나씩 설계한 후 조립하는 방식으로 프로그램을 개발하는 기법이다.
		  
	6.1.4 characteristic of object oriented programming
		1) 캡슐화(Encapsulation)
			- 객체의 필드, 메소드를 하나로 묶고, 실제 구현 내용을 감추는 것
			- 외부 객체는 객체 내부의 구조를 알지 못하며 객체가 노출해서 제공하는 필드와 메소드만 이용할 수 있다.
			- 외부의 잘못된 사용으로 인해 객체가 손상되지 않도록 하는데 목적이있다.
			- 캡슐화된 멤버를 노출시킬 것인지, 숨길 것인지를 결정하기 위해 접근 제한자를 사용한다.
			* Access Modifier : 객체의 필드와 메소드의 사용 범위를 제한함으로서 외부로부터 보호하는 것
			
		2) 상속(Inheritance)
			- 상위 객체는 자기가 가지고 있는 필드와 메소드를 하위 객체에게 물려주어 하위 객체가 사용할 수 있도록 한다.
			- 상속은 상위 객체를 재사용해서 하위 객체를 쉽고 빨리 설계할 수 있도록 도와주고,
			  이미 잘 개발된 객체를 사용해서 새로운 객체를 만들기 때문에 반복된 코드의 중복을 줄여준다.
			- 상속은 사위 개체의 수정으로 모든 하위객체들의 수정 효과를 가져오므로 유지 보수 시간을 최소화 시켜 주기도 한다.
		
		3) 다형성(Polymorphism)
			- 다형성은 같은 타입이지만 실행 결과가 다양한 객체를 이용할 수 있는 성질을 말한다.
			- 코드 측면에서 다형성은 하나의 타입에 여러 객체를 대입함으로써 다양한 기능을 이용할 수 있도록 한다.
			- 자바는 다형성을 위해 부모 클래스 또는 인터페이스의 타입 변환을 허용한다.
			- 부모 타입에는 모든 자식 객체가 대입될 수 있고, 인터페이스 타입에는 모든 구현 객체가 대입될 수 있다.
			- 다형성의 효과로 객체는 부품화가 가능하다
			
	
	6.2 object and class
		- 클래스는 객체의 설계도이다.
		- 클래스에는 객체를 생성하기 위한 필드와 메소드가 정의되어있다.
		- 클래스로부터 만들어진 객체를 해당 클래스의 인스턴스(instance)라고 한다.
		- 클래스로부터 객체를 만드는 과정을 인스턴스화라고 한다.
		- 하나의 클래스로부터 여러 개의 인스턴스를 만들 수 있다.
		- 객체 지향 프로그래밍 개발의 단계
			(1) 클래스 설계
			(2) 객체 생성
			(3) 생성된 객체 이용
		- main() 메소드가 없는 클래스는 객체 생성 과정을 거쳐 사용해야 한다.
		
		
	6.3  declaration of class 
		- 자바의 식별자 작성 규칙
		----------------------------------------------------------
			번호		작성규칙								예
			1		하나 이상의 문자로 이루어져야한다.			Car, SportsCar
			2		첫 번째 글자는 숫자가 올 수 없다.			Car, 3Car(x)
			3		'$', '_'외의 특수문자는 사용할 수 없다. 	$Car, _Car, @Car(x), #Car(x)
			4		자바 키워드는 사용할 수 없다.				int(x), for(x)
		----------------------------------------------------------
		- 클래스의 이름은 영어 대소문자를 구분한다.
		- 관례적으로 단일 단어라면 첫 자를 대문자로 하고 나머지는 소문자로 작성한다.
		- 서로 다른 단어가 혼합된 이름을 사용한다면 각 단어의 첫 머리 글자는 대문자로 작성하는 것이 관례이다.
		ex) Carculator, Car, Member, ChatClient, ChatServer, Web_Browser
		- "클래스이름.java"로 소스 파일을 생성해야 한다.(소스파일 이름 역시 대소문자를 구분한다)
		- 소스 파일 생성 후 소스 파일에 클래스를 선언한다
		----------------------------------------------------------
			public class 클래스이름 {
			
			}
			
			* public class : 클래스 선언시 사용하는 키워드, 반드시 소문자로 작성해야한다.
			* {} : 클래스 선언의 시작과 끝을 알려준다.
		----------------------------------------------------------
		- 일반적으로 소스 파일 당 하나의 클래스를 선언한다. 하지만, 두 개 이상의 클래스 선언도 가능하다.
		- 두 개 이상의 클래스가 선언된 소스 파일을 컴파일하면 바이트 코드 파일은(.class) 클래스를 선언한 개수만큼 생긴다.
		- 결국 소스파일은 클래스 선언을 담고 있는 저장 단위일 뿐, 클래스 자체가 아니다.
		- 파일 이름과 동일한 이름의 클래스 선언에만 public 접근 제한자를 붙일 수 있다.
		- 소스 파일 하나당 동일한 이름의 클래스 하나를 선언하는 것을 권장한다.
		
		
	6.4 creation of object and class variable
		- 클래스를 선언한 다음, 컴파일을 했다면(이클립스에서는 저장) 객체를 생성할 설계도가 만들어진 샘이다.
		- 클래스로부터 객체를 생성하는 방법은 'new'연산자를 사용하는 것이다.
			ex) new 클래스명();
		- 'new'는 클래스로부터 객체를 생성시키는 연산자이다. 
		- 'new' 연산자 뒤에는 생성자가 오는데, 생성자는 클래스() 형태를 가지고 있다.
		- 'new' 연산자로 생성된 객체는 메모리 힙(heap) 영역에 생성된다.
		- 'new' 연산자는 힙 영역에 객체를 생성시킨 후, 객체의 주소를 리턴하도록 되어있다.
		- 리턴 받은 객체의 주소를 참조 타입인 클래스 변수에 저장해두면, 변수를통해 객체를 사용할 수 있다.
			ex) 클래스 변수 = new 클래스();
		참고) Student.java, StudentExample.java
		- 클래스의 용도
			(1) 라이브러리(API : Application Program Interface)용 클래스
				: 다른 클래스에서 이용할 목적으로 설계
			(2) 실행용 클래스
				: 프로그램의 실행 진입점인 main() 메소드를 제공하는 역할
			: 프로그램 전체에서 사용되는 클래스가 100개라면 99개는 라이브러리이고 단 하나가 실행클래스이다.
	
	6.5 composition member of class
		- 구성 멤버에는 필드, 생성자, 메소드가 있다.
		- 구성 멤버들을 생략되거나 복수 개가 작성될 수 있다.
		
	6.5.1 필드(Field)
		- 객체의 고유 데이터, 부품 객체, 상태 정보를 저장하는 곳이다.
		- 선언 형태는 변수와 비슷하지만, 필드를 변수라고 부르지 않는다.
		- 변수는 생성자와 메소드 내에섬나 사용되고 생성자와 메소드가 실행 종료되면 자동 소면도니다.
		- 필드는 생성자와 메소드 전체에서 사용되며 객체가 소멸되지 않는 한 객체와 함께 존재한다.
		
	6.5.2 생성자(Constructor)
		- 'new'연산자로 호출되는 특별한 중괄호 {}블록이다.
		- 객체 생성 시 초기화를 담당한다.
		- 필드를 초기화하거나, 메소드를 호출해서 객체를 사용할 준비를 한다.
		- 생성자는 메소드와 비슷하게 생겼지만, 클래스 이름으로 되어있고 리턴타입이 없다.
	
	6.5.3 메소드(Method)
		- 객체의 동작에 해당하는 중괄호 {} 블록을 말한다.
		- 중괄호 블록이 가지고 있는 이름이 메소드 이름이다.
		- 메소드를 호출하게 되면 중괄호 블록에 있는 모든 코드들이 일괄적으로 실행된다.
		- 필드를 읽고 수정하는 역할도 하지만, 다른 객체를 생성해서 다양한 기능을 수행하기도 한다.
		- 객체 간의 데이터 전달의 수단으로 사용된다.
		- 외부로부터 매개값을 받거나, 실행 후 어떤 값을 리턴할 수도 있다.
	
		