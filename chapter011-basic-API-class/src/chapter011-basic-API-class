	chapter011 basic-API-class
	
	-- Table of contents --
		11.1 Java API document
		11.2 java.lang and java.util package
		11.3 Object class
		11.4 Objects class
		11.5 System class
		11.6 Class class
		11.7 Stirng class
		11.8 StringTokenizer class
		11.9 StringBuffer, StringBuilder class
		11.10 regular expressions and Pattern class
		11.11 Arrays class
		11.12 Wrapper(포장) class
		11.13 Math, Random class
		11.14 Date, Calendar class
		11.15 Format class
		11.16 java.time package
	-----------------------
	
	11.1 Java API document
		* API(Application Programming Interface) : 라이브러리(library)라고 부르기도 하며,
			프로그램 개발에 자주 사용되는 클래스 및 인터페이스의 모음을 말한다. 
			ex) String class, System class
		- API들은 <JDK 설치경로> /jre/lib/rt.jar라는 압축 파일에 저장되어있다.
		* API document : 쉽게 API를 찾아 이용할 수 있도록 문서화한 것
			'http://docs.oracle.com/javase/8/docs/api'
		- 좌측 상단 프레임(패키지 전체 목록)
		- 좌측 하단 프레임(패키지에 속하는 클래스와 인터페이스 목록)
		- 중앙 프레임 (좌측 하단 프레임에서 선택한 클래스나 인터페이스에 대한 상세 설명)
			(1) 상단 부분 : 클래스가 포함된 패키지 정보, 상속정보, 인터페이스 구현 정보
			(2) 중앙 부분 : 클래스의 설명과 사용방법 요약
			(3) 하단 부분 : 필드, 생성자, 메소드 목록
		- 이클립스에서는 자바 에디터에서 클래스를 마우스로 선택한 다음 'F1'키를 누르면
		  자동으로 API 도큐먼트를 보여주는 Help 뷰가 실행된다.
		  
	11.2 java.lang and java.util package
	11.2.1 java.lang package
		- java.lang package는 자바 프로그램의 기본적인 클래스를 담고 있는 패키지이다.
		- java.lang package에 있는 클래스와 인터페이스는 import 없이 사용할 수 있다.
			ex) String, System
		----------------------------------------------------------
		클래스								용도
		Object								- 자바 클래스 최상위 클래스로 사용
			
		System								- 표준 입력 장치(키보드)로 부터 데이터를 입력받을때 사용
											- 표준 출력 장치(모니터)로 출력하기 위해 사용
											- 자바 가상 기계를 종료시킬 때 사용
											- 쓰레기 수집기를 실행 요청할 때 사용
		
		Class								- 클래스를 메모리로 로딩할 때 사용
		
		String								- 문자열을 저장하고 여러가지 정보를 얻을 때 사용
		
		StringBuffer, StringBuilder			- 문자열을 저장하고 내부 문자열을 조작할 때 사용
		
		Math								- 수학 함수를 이용할 때 사용
		
		Wrapper		Byte, Short, Character 	- 기본 타입의 데이터를 갖는 객체를 만들 때 사용
					Integer, Float, Double	- 문자열을 기본 타입으로 변환할 때 사용
					Boolean, Long			- 입력값 검사에 사용
		----------------------------------------------------------
		
	11.2.2 java.util package
		- java.util package는 자바 프로그램 개발에 조미료 같은 역할을 하는 클래스를 담고 있다.
		- java.util package는 컬렉션 클래스들이 대부분을 차지하고 있다.
		----------------------------------------------------------
			클래스				용도
			Arrays				- 배열을 조작(비교, 복사, 정렬, 찾기)할 때 사용
		
			Calendar			- 운영체제의 날짜와 시간을 얻을 때 사용
		
			Date				- 날짜와 시간 정보를 저장하는 클래스
		
			Objects				- 객체 비교, 널(null) 여부 등을 조사할 때 사용
		
			StringTokenizer		- 특정 문자로 구분된 문자열을 뽑아낼 때 사용
		
			Random				- 난수를 얻을 때 사용
		----------------------------------------------------------
	
	
	11.3 Object class
		- 클래스를 선언할 때 extends 키워드로 다른 클래스를 상속하지 않으면 암시적으로
		  'java.lang.Objcet' 클래스를 상속하게 된다.
		- 자바의 모든 클래스는 Object 클래스의 자식이거나 자손 클래스이다.
		  Object는 자바의 최상위 부모 클래스에 해당한다.
		- Objcet 클래스는 필드가 없고, 메소드들로 구성되어있다. 
		  이 메소드들은 모든 클래스가 Objcet를 상속하기 때문에 모든 클래스에서 사용이 가능하다.
	
	11.3.1 equals()
		- 'public boolean equals(Object obj) { ... }'
		- equals() 메소드의 매개 타입은 Object인데, 이것은 모든 객체가 매개값으로 대입될 수 있음을 말한다.
		- Object가 최상위 타입이므로 모든 객체는 Object 타입으로 자동 타입 변환될 수 있기 때문이다.
		- equals() 메소드는 비교 연산자인 '=='과 동일한 결과를 리턴한다.
		  두 객체가 동일한 객체라면 true를 리턴하고 그렇지 않으면 false를 리턴한다.
		----------------------------------------------------------
			Object obj1 = new Object();
			Object obj2 = new Object();
			
			// 아래 두 식의 결과는 동일하다
			boolean result = obj1.equals(obj2);
			boolean result = (obj1 == obj2);
		----------------------------------------------------------
		- 자바에서는 두 객체를 동등 비교할 때 equals() 메소드를 흔히 사용한다.
		- equals() 메소드는 두 객체를 비교해서 논리적으로 동등하면 true를 리턴하고, 그렇지 않으면 false를 리턴한다.
		- 논리적으로 동등하다는 것은 같은 객체이건 다른 객체이건 상관없이 객체가 저장하고 있는 데이터가 동일함을 뜻한다.
		- 예를 들어 String 객체의 equals() 메소드는 String 객체의 번지를 비교하는 것이 아니고,
		  문자열이 동일한지 조사해서 같아면 true를 리턴하고, 그렇지 않다면 false를 리턴한다.
		- 이것이 가능한 이유는 String 클래스가 Object의 equals() 메소드를 재정의(오버라이딩)해서 번지 비교가 아닌
		  문자열 비교로 변경했기 때문이다.
		- Object의 equal() 메소드는 직접 사용되지 않고 하위 클래스에서 재정의하여 논리적으로 동등 비교할 대 이용된다.
		- 예를 들어 Member 객체는 다르지만 id 필드값이 같으면 논리적으로 동등한 객체로 취급하고 싶을 경우
		  Object의 equals() 메소드를 재정의 해서 id 필드 값이 같음을 비교하면 된다.
		- equals() 메소드를 재정의 할 때에는 매개값(비교 객체)이 기준 객체와 동일한 타입의 객체인지 먼저 확인해야 한다.
		- Objcet 타입의 매개 변수는 모든 객체가 배개값으로 제공될 수 있기 때문에 
		  instanceof 연산자로 기준 객체와 동일한 타입인지 제일 먼저 확인해야 한다.
		- 비교 객체가 다른 타입이라면 equals() 메소드는 false를 리턴해야 한다.
		- 비교 객체가 동일한 타입이라면 기준 객체 타입으로 강제 타입 변환해서 필드값이 동일한지 검사하면 된다.
		참고) objectClass.EqualsMember.java
			 objectClass.EqualsMemberExample.java
			 
	11.3.2 hashCode()
		- 객체 해시코드란 객체를 식별할 하나의 정수값을 말한다.
		- Object의 hashCode() 메소드는 객체의 메모리 번지를 이용해서 해시코드를 만들어 리턴하기 때문에
		  객체마다 다른 값을 가지고 있다.
		- 논리적 동등 비교 시 hashCode()를 오버라이딩할 필요성이 있다.
		- 컬렉션 프레임워크에서 HashSet, HashMap, HashTable은 hashCode() 메소드를 실행해서
		  리턴된 해시코드 값이 같은지를 본다. 해시 코드 값이 다르면 다른 객체로 판단하고, 해시코드 값이 같으면
		  equals() 메소드로 다시 비교한다. 그렇기 때문에 hashCode() 메소드가 true가 나와도
		  equals()의 리턴값이 다르면 다른 객체가 된다.
		참고) objectClass.HashCodeKey.java
			 objectClass.HashCodeKeyExample.java
			 objectClass.HashCodeOverridingKey.java
			 objectClass.HashCodeOverridingKeyExample.java
			 objectClass.HashCodeOverridingMember.java
		- 두 개의 객체가 동일한 클래스로 만들어지고 동일한 필드값을 가지고 있다고 하더라도 객체를 생성할때 마다
		  다른 해시코드가 리턴되기 때문에 논리적 동등 비교시 컬렉션 프레임 워크의 HashSet, HashMap, HashTable은
		  두 개의 객체를 서로 다른 객체로 인식한다. 이러한 문제를 해소하기 위해 hashCode()메소드를 재정의하여
		  두 개의 객체가 같은 hashCode 값을 리턴하도록 만들면 두 개의 객체는 동일한 객체가 된다.
		  
	11.3.3 toString()
		- Object 클래스의 toString() 메소드는 객체의 문자 정보를 리턴한다.
		- 객체의 문자 정보란 객체를 문자열로 표현한 값을 말한다.
		- 기본적으로 Object 클래스의 toString() 메소드는 "클래스명@16진수해시코드"로
		  구성된 문자 정보를 리턴한다.
		----------------------------------------------------------
			Object obj = new Object();
			System.out.println(obj.toString());
			
			실행결과 예시 : 'java.lang.Object@de6ced'
		----------------------------------------------------------
		- Object의 toString() 메소드의 리턴값은 자바 애플리케이션에서는 별 값어치가 없는 정보이므로
		  Object의 하위 클래스는 toString() 메소드를 재정의(오버라이딩)하여 간결하고 유익한 정보를 리턴하도록 되어있다.
		- 예를 들어 java.util 패키지의 Date 클래스는 toString() 메소드를 재정의하여
		  현재 시스템의 날짜와 시간 정보를 리턴한다.
		- String 클래스는 toString() 메소드를 오버라이딩하여 저장하고 있는 문자열을 리턴한다.
		참고) objectClass.ToStringExample.java
			 objectClass.ToStringSmartPhone.java
			 objectClass.ToStringSmartPhoneExample.java
		
	11.3.4 clone()
		- 객체 복제는 원본 객체의 필드값과 동일한 값을 가지는 새로운 객체를 생성하는 것을 말한다.
		- 원본 객체를 안전하게 보호하기 위해서 객체를 복제한다.
		- 신뢰하지 않는 영역으로 원본 객체를 넘겨 작업할 경우 원본 객체의 데이터가 훼손될 수 있기 때문에
		  복제된 객체를 만들어 신뢰하지 않는 영역으로 넘기는 것이 좋다.
		- 복제된 객체의 데이터가 훼손되더라도 원본 객체는 아무런 영향을 받지 않기 때문에
		  안전하게 데이터를 보호할 수 있게 된다.
		- 객체를 복제하는 방법에는 얕은 복제와 깊은 복제가 있다.
		
		1) thin clone(얕은 복제)
		- 얕은 복재란 단순히 필드 값을 복사해서 객체를 복제하는 것을 말한다.
		- 필드값만 복제하기 때문에 필드가 기본타입일 경우 값 복사가 일어나고,
		  필드가 참조 타입일 경우에는 객체의 번지가 복사된다.
		- Object의 clone() 메소드는 자신과 동일한 필드값을 가진 얕은 복제된 객체를 리턴한다.
		- 이 메소드로 객체를 복제하려면 원본 객체는 반드시 'java.lang.Cloneable'인터페이스를 구현하고 있어야 한다.
		- 메소드 선언이 없음에도 불구하고 Cloneable 인터페이스를 명시적으로 구현하는 이유는 클래스 설계자가
		  복제를 허용한다는 의도적인 표시를 하기 위해서이다.
		  클래스 설계자가 복제를 허용하지 않는다면 Cloneable 인터페이스를 구현하지 않으면 된다.
		- Cloneable 인터페이스를 구현하지 않으면 clone() 메소드를 호출할 때
		  CloneNotSupportedException 예외가 발생하여 복제가 실패된다.
		- clone()은 CloneNotSupportedException 예외 처리가 필요한 메소드이기 때문에
		  try-catch 구문이 필요하다
		----------------------------------------------------------
			try {
				Object obj = clone();
			} catch(CloneNotSupportedException e) { }
		----------------------------------------------------------
		참고) objectClass.ThinCloneMember.java
			 objectClass.ThinCloneMemberExample.java
			 
		2) deep clone(깊은 복제)
		- 얕은 복제의 경우 참조 타입 필드는 번지만 복제되기 때문에 원본 객체의 필드와 복제 객체의 필드는
		  같은 객체를 참조하게 된다.
		- 만약 복제 객체에서 참조 객체를 변경하면 원본 객체도 변경된 객체를 가지게 된다. 이것이 얕은 복제의 단점이다.
		- 깊은 복제란 참조하고 있는 개체도 복제하는 것을 말한다.
		- 깊은 복제를 하려면 Objcet의 clone() 메소드를 재정의해서 참조 객체를 복제하는 코드를 직접 작성해야 한다.
		참고) objcetClass.DeepCloneMember.java
			 objectClass.DeepCloneMemberExample.java
			 objcetClass.DeepCloneCar.java
			 
	11.3.5 finalize()
		- 참조하지 않는 배열이나 객체는 쓰레기 수집기(Garbage Collector)가 힙 영역에서 자동적으로 소멸시킨다.
		- 쓰레기 수집기는 객체를 소멸하기 직전에 마지막으로 객체의 소멸자(finalize())를 실행시킨다.
		- 소멸자는 Objcet의 finalize() 메소드를 말하는데, 기본적으로 실행 내용이 없다.
		- 만약 객체가 소멸되기 전에 마지막으로 사용했던 자원(데이터 연결, 파일 등)을 닫고 싶거나 중요한 데이터를
		  저장하고 싶다면 Object의 finalize()를 재정의 할 수 있다.
		참고) objectClass.FinalizeCounter.java
			 objectClass.FinalizeExample.java
				
		- 한두 개의 객체를 쓰레기로 만들었다고 해서 쓰레기 수집기가 실행되는 것은 아니다.
		- garbage collector는 메모리가 부족할 때 그리고 CPU가 한가할 때에 JVM에 의해서 자동 실행된다.
		- finalize() 메소드가 호출되는 시점은 명확하지 않으며, 일정한 순서로 호출하지 않는다.
		  또한 쓰레기 데이터를 전부 소멸시키는 것이 아니라 메모리의 상태를 보고 일부만 소멸시킨다.
		- 코드에서 'System.gc()'를 선언하면 가급적 빨리 garbage collector를 실행 시켜 달라고 JVM에게 요청하는 것이다.
		- 프로그램이 종료될 때 즉시 자원을 해제하거나 즉시 데이터를 최종 저장해야 한다면, 일반 메소드에서 작성하고
		  프로그램이 종료될 때 명시적으로 finalize() 메소드를 호출하는 것이 좋다.
		  
	
	11.4 Objects class
		- 객체 비교, 해시코드 생성, null 여부, 객체 문자열 리턴 등의 연산을 수행하는 정적 메소드들로 구성된
		  Object의 유틸리티 클래스이다.
		----------------------------------------------------------
			리턴타입		메소드(매개 변수)						설명
			int			compare(T a, T b, Comparator<T> c)	두 객체 a와 b를 Comparator를 사용해서 비교한다.
			
			boolean		deepEquals(Object a, Object b)		두 객체의 깊은 비교(배열의 항목까지 비교한다.)
			
			boolean		equals(Object a, Object a)			두 객체의 얕은 비교(번지만 비교한다.)
			
			int			hash(Object... values)				매개값이 저장된 배열의 해시코드를 생성한다.
			
			int			hashCode(Object o)					객체의 해시코드를 생성한다.
			
			boolean		isNull(Object obj)					객체가 null인지 조사한다.
			
			boolean		nonNull(Object obj)					객체가 null이 아닌지 조사한다.
			
			T			requireNonNull(T obj)				객체가 null인 경우 예외 발생
			
			T			requireNonNull(T obj,				객체가 null인 경우 예외 발생
						 String message)					(주어진 예외 메시지 포함)
				
			T			requireNonNull(T obj,				객체가 null인 경우 예외 발생
						 Supplier<String> messageSupplier)	(람다식이 만든 예외 메시지 포함)
						
			String		toString(Object o)					객체의 toString() 리턴값 리턴
			
			String		toString(Object o,					객체의 toString() 리턴값 리턴, 첫 번째
						 String nullDefault)				매개값이 null일 경우 두 번째 매개값 리턴
			----------------------------------------------------------
			
	11.4.1 compare(T a, T b, Comparator<T> c)
		- Objects.compare(T a, T b, Comparator<T> c) 메소드는 두 객체를 비교자(Comparator)로
		  비교해서 int 값을 리턴한다.
		- java.util.Comparator<T>는 제네릭 인터페이스 타입으로 두 객체를 비교하는
		  Compare(T a, T b) 메소드가 정의되어 있다.
		* T : 비교할 객체 타입
		- compare() 메소드의 리턴 타입은 int이며, a가 b보다 작으면 음수, 크면 양수를 리턴하도록 구현 클래스를 만들어야 한다.
		----------------------------------------------------------
			public interface Comparator<T> {
				int compare(T a, T b);
			}
		----------------------------------------------------------
		참고) objectsClass.CompareStudentComparator.java
			 objectsClass.CompareExample.java
			 objectsClass.CompareStudent.java
			 
	11.4.2 equals() and deepEquals()
		- Objects.equals(Object a, Object b)는 두 객체의 동등을 비교하여 a와 b가 모두 null일 경우
		  true를 리턴하고, a와 b가 모두 null이 아닐경우 a.equals(b)의 리턴값을 리턴한다.
		----------------------------------------------------------
			a			b			Objects.equals(a, b)
			not null	not null	a.equals(b)의 리턴값
			null		not null	false
			not null	null		false
			null		null		true
		----------------------------------------------------------
		- Objects.deepEquals(Object a, Object b)는 두 객체의 동등을 비교하여 a와 b가 서로 다른 배열일 경우,
		  항목 값이 모두 같다면 true를 리턴한다.
		- Arrays.deepEquals(Object[] a, Object[] b)와 동일하다.
		----------------------------------------------------------
			a						b						Objects.deepEquals(a, b)
			not null(not array)		not null(not array)		a.equals(b)의 리턴값
			not null(array)			not null(array)			Arrays.deepEquals(a, b)의 리턴값
			null					not null				false
			null					null					true
		----------------------------------------------------------
		참고) objectsClass.EqualsAndDeepEqualsExample.java
		
	11.4.3 to create hashcode ( hash(), hashCode() )
		- Objects.hash(Object... values) 메소든느 매개값으로 주어진 값들을 이용해서 해시 코드를 생성하는 역할을 한다.
		- 주어진 매개값드로 배열을 생성하고 Arrays.hashCode(Object[])를 호출해서 해시코드를 얻고 이 값을 리턴한다.
		- hash() 메소드는 츨래스가 hashCode()를 재정의할 때 리턴값을 생성하기 위해 사용하면 좋다.
		- 클래스가 여러 가지 필드를 가지고 있을 때 이 필드들로부터 해시코드를 생성하게 되면
		  동일한 필드값을 가지는 객체는 동일한 해시코드를 가질 수 있다.
		----------------------------------------------------------
			@Override
			public int hashCode() {
				return Objects.hash(field1, field2, field3);
			}
		----------------------------------------------------------
		- Objects.hashCode(Object o)는 매개값으로 주어진 객체의 해시코드를 리턴하기 때문에
		  o.hashCode()의 리턴값과 동일하다.
		- 차이점은 매개값이 null이면 0을 리턴한다.
		참고) objectsClass.HashCodeExample.java
			 objectsClass.Student.java
			 
	11.4.4 isNull(), nonNull(), requireNonNull()
		- Objects.isNull(Object obj)는 매개값이 null일 경우 true를 리턴한다.
		- Objects.nonNull(Object obj)는 매개값이 not null일 경우 true를 리턴한다.
		- ObjectsrequireNonNull()는 3가지 경우로 오버로딩 되어있다.
		----------------------------------------------------------
			리턴 타입		메소드(매개 변수)					설명
			T			requireNonNull(T obj)			not null -> obj
														null -> NullPointerException
			T			requireNonNull(T obj,			not null -> obj
						  String message)				null -> NullPointerException(message)
			T			requireNonNoll(T obj,			not null -> obj
						  Supplier<String> msgSupplier	null -> NullPointerException(msgSupplier.get())
		----------------------------------------------------------
		참고) objectsClass.NullExample.java
		
	11.4.5 toString()
		- Object.toString()은 객체의 문자 정보를 리턴하는데 2가지 경우로 오버로딩 되어있다.
		----------------------------------------------------------
			리턴 타입		메소드(매개 변수)					설명
			String		toString(Object o)				not null -> o.toString()
														null -> "null"
			String		toString(Object o,				not null -> o.toString()
			 String nullDefault)						null -> nullDefault
		----------------------------------------------------------
		- 첫 번째 매개값이 not null이면 toString()으로 얻은 값을 리턴하고,
		  null이면 "null" 또는 두번째 매개값인 nullDefault를 리턴한다.
		참고) objectsClass.ToStringExample.java
		
	
	11.5 System Class
		- 자바 프로그램은 운영체제상에서 바로 실행되는 것이 아니라 JVM 위에서 실행된다. 따라서 운영체제의 모든 기능을
		  자바 코드로 직접 접근하기란 어렵다.
		- java.lang package에 속하는 System 클래스를 이용하면 운영체제의 일부 기능을 이용할 수 있다.
		- 프로그램 종료, 키보드로부터 입력, 모니터로 출력, 메모리 정리, 현재 시간 읽기, 시스템 프로퍼티 읽기,
		  환경 변수 읽기 등이 가능하다.
		- System 클래스의 모든 필드와 메소드는 정적(static) 필드와 정적(static) 메소드로 구성되어 있다.
		
	11.5.1 exit()
		- 경우에 따라서는 강제적으로 JVM을 종료시킬 때도 있다. 이때 System 클래스의 exit()메소드를 호출하면 된다.
		- exit() 메소드는 현재 실행하고 있는 프로세스를 강제 종료 시키는 역할을 한다.
		- exit() 메소드는 int 매개값을 지정하도록 되어있는데 이 값을 종료 상태값이라고 한다.
		- 일반적으로 정상 종료일 경우 0으로 지정하고 비정상 종료일 경우 0이외의 다른 값을 준다.
			ex) System.exit(0);
		- 어떤 값을 주더라도 종료가 되는데, 만약 특정 값이 입력되었을 경우에만 종료하고 싶다면 자바의 보안관리자를
		  직접 설정해서 종료 상태값을 확인하면 된다.
		- exit() 메소드에서 종료 상태값을 조사해서 특정 값이 입력되지 않으면 SecurityException을 발생시켜
		  System.exit()를 호출한 곳에서 예외 처리를 할 수 있도록 해준다.
		- checkExit()가 정상적으로 실행되면 JVM은 종료가 된다.
		----------------------------------------------------------
			System.setSecurityManager(new SecurityManager(){
				@Override
				public void checkExit(int status) {
					if(status != 5) {
						throw new SecurityException();
					}
				}
			});
		----------------------------------------------------------
		참고) objectsClass.ExitExample.java
		
	11.5.2 gc()(Garbage Collector)
		- 자바는 개발자가 메모리를 직접 코드로 관리하지 않고 JVM이 알아서 자동으로 관리한다.
		 - JVM은 메모리가 부족할 때와 CPU가 한가할 때에 Garbage Collector를 실행시켜 사용하지 않는 객체를 자동 제거한다.
		 - Garbage Collector는 개발자가 직접 코드로 실행시킬 수 없고,
		   System.gc() 메소드로 JVM에게 가능한한 빨리 실행해 달라고 요청할 수는 있다.
		 - System.gc() 메소드가 호출되면 쓰레기 수집기가 바로 실행되는 것은 아니지만
		   JVM은 빠른 시간 내에 실행시키기 위해 노력한다.
		 - 쓰레기가 생길 때마다 Garbage Collector가 동작한다면 정작 수행되어야 할 프로그램의 속도가 떨어지기 때문에
		   성능 측면에서 좋지 않다.
		 - 메모리가 충분하다면 굳이 Garbage Collector를 실행할 필요가 없다.
		 참고) systemClass.GcExample.java
		 
	11.5.3 currentTimeMillis(), nanoTime()
		- currentTimeMillis() 메소드와 nanoTime() 메소드는 컴퓨터의 시계로부터 현재 시간을 읽어서
		  밀리세컨드(1/1000초) 단위와 나노세컨드(1/10^9초)단위의 long 값을 리턴한다.
		  	ex) long time = System.currentTimeMillis();
		  		long time = System.nanoTime();
		- 리턴값은 주로 프로그램의 실행 소요 시간 측정에 사용된다.
		- 프로그램 시작시 시각을 읽고, 프로그램이 끝날 대 시각을 읽어서 차이를 구하면
		  프로그램 실행 소요 시간이 나온다.
		참고) systemClass.SystemTimeExample.java
	
	11.5.4 getProperty()
		- 시스템 프로퍼티(System Property)는 JVM이 시작할 때 자동 설정되는 시스템의 속성값을 말한다.
		- 예를 들어 운영체제의 종류 및 자바 프로그램을 실행시킨 사용자 아이디, JVM의 버전,
		  운영체제에서 사용되는 파일 경로 구분자 등이 여기에 속한다.
		- 시스템 프로퍼티는 키(key)와 값(value)으로 구성되어있다.
		----------------------------------------------------------
			키(key)			설명								값(value)
			java.version	자바의 버전						1.8.0_20
			java.home		사용하는 JRE의 파일 경로				<jdk 설치경로>\jre
			os.name			Operating system name			Windows 10
			file.separator	File separator("\" on UNIX)		\
			user.name		사용자의 이름						사용자 계정
			user.home		사용자의 홈 디렉토리					C:\Users\사용자 계정
			user.dir		사용자가 현재 작업 중인 디렉토리 경로	다양
		----------------------------------------------------------
		- 시스템 프로퍼티를 읽어오기 위해서는 System.getProperty() 메소드를 이용하면 된다.
		  이 메소드는 시스템 프로퍼티의 키 이름을 매개값으로 받고, 해당 키에 대한 값을 물자열로 리턴한다.
			ex) String value = System.getProperty(String key);
		참고) systemClass.GetPropertyExample.java
		
		- System.getProperties() 메소드는 모든(키, 값) 쌍을 저장하고 있는 Properties 객체를 리턴한다.
		  이 객체의 keySet() 메소드를 호출하면 키만으로 구성된 Set 객체를 얻을 수 있다.
		  for문은 Set객체로부터 키를 하나씩 얻어내여 문자열로 변환한 다음, System.getProperty() 메소드로
		  값을 얻어 키와 값을 모두 출력한다.
		  
	11.5.5 getenv()
		- 대부분의 운영체제는 실행되는 프로그램들에게 유요한 정보를 제공할 목적으로
		  환경 변수(Environment Variable)를 제공한다.
		- 환경 변수는 프로그램 상의 변수가 아니라 운영체제에서 이름(Name)과 값(Value)으로 관리되는 문자열 정보다.
		- 환경 변수는 운영체제가 설치될 때 기본적인 내용이 설정되고, 사용자가 직접 설정하거나
		  응용프로그램이 설치될 때 자동적으로 추가 설정 되기도 한다.
		- 사용자가 환경 변수를 설정하는 방법은 운영체제마다 조금씩 다르며, Windows 계열의 운영체제에서는
		  [ 제어판 -> 시스템 및 보안 -> 시스템 -> 고급시스템 설정 -> 시스템 속성 -> 고급
		   -> 환경 변수 -> 시스템 변수 (새로 만들기, 편집, 삭제) ] 를 이용해서 설정한다.
		- 자바 프로그램에서는 환경 변수의 값이 필요할 경우 System.getenv() 메소드를 사용한다.
		  매개값으로 환경 변수 이름을 주면 값을 리턴한다.
			ex) String value = System.getenv(String name);
		참고) systemClass.SystemEnvExample.java
		
	
	11.6 Class class
		- 자바는 클래스와 인터페이스의 메타 데이터를 java.lang 패키지에 소속된 class 클래스로 관리한다.
		- 메타 데이터란 클래스의 이름, 생성자 정보, 필드 정보, 메소드 정보를 말한다.
		
	11.6.1 getClass(), forName()
		- 프로그램에서 Class 객체를 얻기 위해서는 Object 클래스가 가지고 있는 getClass() 메소드를 이용하면 된다.
		- Object는 모든 클래스의 최상위 클래스이므로 모든 클래스에서 getClass() 메소드를 호출할 수 있다.
			ex) Class clazz = obj.getClass();
		- getClass() 메소드는 해당 클래스로 객체를 생성 했을 때만 사용할 수 있다.
		- 정적 메소드인 forName()을 이용하면 객체를 생성하기 전에 직접 Class 객체를 얻을 수 있다.
		  ( Class는 생성자를 감추고 있기 때문에 new 연산자로 객체를 생성할 수 없다. )
		- forName() 메소드는 클래스 전체 이름(패키지가 포함된 이름)을 매개값으로 받고 Class 객체를 리턴한다.
		----------------------------------------------------------
			try {
				Class clazz = Class.forname(String classname);
			} catch (ClassNotFoundException e) {
			}
		----------------------------------------------------------
		- Class.forName() 메소드는 매개값으로 주어진 클래스를 찾지 못하면 ClassNotFoundException 예외를
		  발생시키기 때문에 예외 처리가 필요하다.
		참고) classClass.GetClassAndForNameExample.java
		
	11.6.2 reflection
		- Class 객체를 이용하면 클래스의 생성자, 필드, 메소드 정보를 알아낼 수 있다.
		  이것을 리플랙션(Reflection)이라고 한다.
		- Class 객체는 리플렉션을 위해 getDeclaredConstructors(), getDeclaredFields(),
		  getDeclaredMethods()를 제공하고 있다.
		  	ex)	Constructor[] constructors = clazz.getDeclaredConstructors();
		  		Field[] fields = clazz.getDeclaredFields();
		  		Method[] methods = clazz.getDeclaredMethods();
		- Constructor, Field, Method 클래스는 모두 java.lang.reflect 패키지에 소속되어 있다.
		- getDeclaredFields(), getDeclaredMethods()는 클래스에 선언된 멤버만 가져오고
		  상속된 멤버는 가져오지 않는다.
		- getFields(), getMethods() 메소드를 활용하여 상속된 멤버를 얻을 수 있다. 단, public 멤버만 가져온다.
		참고) classClass.ReflectionExample.java
		
	11.6.3 newInstance()
		- Class 객체를 이용하면 new 연산자를 사용하지 않아도 동적으로 객체를 생성할 수 있다.
		- 이 방법은 코드 작성 시에 클래스 이름을 결정할 수 없고, 런타임 시에 클래스 이름이 결정되는 경우에
		  매우 유용하게 사용된다.
		- Class.forName() 메소드로 Class 객체를 얻은 다음 newInstance() 메소드를 호출하면 Object 타입의
		  객체를 얻을 수 있다.
		----------------------------------------------------------
			try {
				Class clazz = Class.forName("런타임 시 결정되는 클래스 이름");
				Object obj = clazz.newInstance();
			} catch(ClassNotFoundException e) {
			} catch(InstantiationException e) {
			} catch(IllegalAccessException e) {
			}
		----------------------------------------------------------
		- newInstance() 메소드는 기본 생성자를 호출해서 객체를 생성하기 때문에 반드시 클래스에 기본 생성자가 존재해야 한다.
		- 매개 변수가 있는 생성자를 호출하고 싶다면 reflection으로 Constructor 객체를 얻어
		  newInstance() 메소드를 호출하면 된다.
		- 해당 클래스가 추상 클래스이거나 인터페이스일 경우 InstantiationException 예외가 발생한다.
		- 생성자가 접근 제한자로 인해 접근할 수 없을 경우 IllegalAccessException 예외가 발생한다.
		- newInstance() 메소드의 리턴 타입은 Object이므로 이것을 원래 클래스 타입으로 변환해야만 메소드를 사용할 수 있다.
		- 클래스 타입을 모르는 상태에서는 강제 타입 변환을 하지 못하므로 인터페이스를 사용한다.
		- 예를 들어 execute() 메소드를 선언하고있는 Action 인터페이스가 있고,
		  이를 구현하는 SendAction 클래스와 ReceiveAction클래스가 있다고 가정해보자
		- Class.forName() 메소드의 매개값으로 "SendAction" 또는 "ReceiveAction"을 주면 Class 객체가 만들어지고,
		  Class 객체의 newInstance() 메소드로 Object 객체를 얻을 수 있다.
		- 얻어진 객체는 모두 Action 인터페이스를 구현하고 있기 때문에 Action 인터페이스 타입으로 변환하여
		  execute() 메소드를 호출하면, 개별 클래스의 실체 메소드인 execute() 메소드가 실행된다.
		----------------------------------------------------------
			Class clazz = Class.forName("SendAction" 또는 "ReceiveAction");
			Action action = (Action) clazz.newInstance();
			action.execute();
		----------------------------------------------------------
		참고) classClass.NewInstanceAction.java
			 classClass.NewInstanceSendAction.java
			 classClass.NewInstanceReceiveAction.java
			 classClass.NewInstanceExample.java
			 
	
	11.7 String class
	11.7.1 String constructor
		- 자바의 문자열은 java.lang 패키지의 String 클래스의 인스턴스로 관리된다.
		- 소스상에서 문자열 리터럴은 String 객체로 자동 생성되지만, String 클래스의 다양한 생성자를 이용해서
		  직접 String 객체를 생성할 수도 있다. 
		- String 클래스는 Deprecated(비권장)된 생성자를 제외하고 약 13개의 생성자를 제공한다.
		- Deprecated는 예전 자바 버전에선느 사용되었으나, 현재 버전과 차후 버전에서는 사용하지 말라는 뜻이다.
		- 어떤 생성자를 이용해서 String 객체를 생성할지는 제공되는 매개값의 타입에 달려있다.
		- 파일의 내용을 익거나, 네트워크를 통해 받는 데이터는 보통 byte[] 배열이므로 이것을 문자열로 변환하기 위해
		  다음의 생성자들이 자주 사용된다.
		----------------------------------------------------------
			// 배열 전체를 String 객체로 생성
			String str = new String(byte[] bytes);
			// 지정한 문자셋으로 디코딩
			String str = new String(byte[] bytes, String charseName);
			
			// 배열의 offset 인덱스 위치부터 length만큼 String 객체로 생성
			String str = new String(byte[] bytes, int offset, int length);
			// 지정한 문자셋으로 디코딩
			String str = new String(byte[] bytes, int offset, int length, String charseName);
		----------------------------------------------------------
		참고) stringClass.ConstructorByteToStringExample.java
		
		- System.in.read() 메소드는 키보드에서 입력한 내용을 매개값으로 주어진 바이트 배열에 저장하고
		  읽은 바이트 수를 리턴한다.
		  	ex)	Hello + enter button	->	Hello + 캐리지리턴(\r) + 라인피드(\n)
		  		->	72(H), 101(e), 108(l), 108(l), 111(o), 13(\r), 10(\n)
		  		-> 	바이트 배열에 저장 -> 7 리턴
		- 영어는 알파벳 한 자가 1바이트로 표현되지만, 한글과 기타 다른 나라 언어는 2바이트로 표현되기 때문에
		  입력된 문자 수와 읽은 바이트 수가 다를 수 있다.
		참고) stringClass.ConstructorKeyboardToStringExample.java
		
	11.7.2 String method
		- String은 문자열의 추출, 비교, 찾기, 분리, 변환 등과 같은 다양한 메소드를 가지고 있다.
		----------------------------------------------------------
			리턴 타입		메소드명(매개 변수)					설명
			char		charAt(int index)				특정 위치의 문자 리턴
			
			boolean		equals(Object anObject)			두 문자열을 비교
			
			byte[]		getBytes()						byte[]로 리턴
			
			byte[]		getBytes(Charset charset)		주어진 문자셋으로 인코딩한 byte[]로 리턴
			
			int			indexOf(String st)				총 문자의 수를 리턴
			
			String		replace(CharSequence target,	target 부분을 replacement로 대치한
							CharSequence replacement)	새로운 문자열을 리턴
							
			String		subString(int beginIndex)		beginIndex 위치에서 끝까지 잘라낸
														새로운 문자열을 리턴
			String		substring(int beginIndex,		beginIndex 위치에서 endIndex 전까지 잘라낸
							int endIndex)				새로운 문자열을 리턴
							
			String		toLowerCase()					알파벳 소문자로 변환한 새로운 문자열을 리턴
			
			String		toUpperCase()					알파벳 대문자로 변환한 새로운 문자열을 리턴
			
			String		trim()							앞뒤 공백을 제거한 새로운 문자열을 리턴
			
			String		valueOf(int i)					기본 타입값을 문자열로 리턴
						valueOf(double d)
		----------------------------------------------------------
		
		1) charAt()
			- charAt() 메소드는 매개값으로 주어진 인덱스의 문자를 리턴한다. 
			  (인덱스 : 0 ~ "문자열 길이 - 1"까지의 번호)
			----------------------------------------------------------
				String subject = "자바 프로그래밍";
				char charValue = subject.charAt(3);		// charValue = "프"
			----------------------------------------------------------
			참고) stringClass.CharAtExample.java
			
		2) equals()
			- 기본 타입(byte, char, short, int, long, float, double, boolean) 변수의 값을 비교할 때에는
			  == 연산자를 사용한다.
			- 문자열을 비교할 때는 == 연산자를 사용하면 원하지 않는 결과가 나올 수 있다.
			----------------------------------------------------------
				String strVar1 = new String("자바");
				String strVar2 = "자바";
				String strVar3 = "자바";
		
				- 자바는 문자열 리터럴이 동일하다면 동일한 String 객체를 참조하도록 되어있다.
				  strVar2와 strVar3는 동일한 String 객체를 참조한다.
				  strVar1은 new 연산자로 생성된 다를 객체를 참조한다.
				- strVar1과 strVar2의 == 연산은 false를 산출하고
				  strVar2와 strVar3의 == 연산은 true를 산출한다.
				- == 연산자는 각 변수에 저장된 번지를 비교하기 때문에 이러한 결과가 나온다.
			----------------------------------------------------------
			- String 객체의 문자열만을 비교하고 싶다면 == 연산자 대신에 equals() 메소드를 사용해야 한다.
			- 원래 equals()는 Object의 번지 비교 메소드이지만,
			  String 클래스가 오버라이딩해서 문자열을 비교하도록 변경했다.
			참고) stringClass.EqualsExample.java
			
		3) getBytes()
			- 네트워크로 문자열일 전송하거나, 문자열을 암호화할 때 문자열을 바이트 배열로 반환한다.
				ex) byte[] bytes = "문자열".getBytes(); or "문자열".getBytes(Charset charset);
			- getBytes() 메소드는 시스템의 기본 문자셋으로 인코딩 된 바이트 배열을 리턴한다.
			- 특정 문자셋으로 인코딩된 바이트 배열을 얻으려면 getBytes(Charset charset) 메소드를 사용한다.
			----------------------------------------------------------
				try{
					byte[] bytes = "문자열".getBytes("EUC-KR");
					byte[] bytes = "문자열".getBytes("UTF-8");
	 			} catch (UnsupportedEncodingException e) {
	 			}
	 		----------------------------------------------------------
	 		- 인코딩하는 문자셋에 따라 바이트 배열의 크기가 달라진다.
	 		- EUC-KR은 getBytes()와 마찬가지로 알파벳은 1바이트, 한글은 2바이트로 변환한다.
	 		- UTF-8은 알파벳은 1바이트, 한글은 3바이트로 변환한다.
	 		- 잘못된 문자셋을 매개값으로 줄 경우 'java.io.UnsupportedEncodingException'예외가 발생하므로
	 		  예외처리가 필요하다.
	 		- 시스템의 기본 문자셋으로 인코딩된 바이트 배열의 경우 String(byte[] bytes)로 디코딩한다.
	 		- 이외의 문자셋으로 인코딩된 바이트 배열의 경우 String(byte[] bytes, String charsetName)로
	 		  디코딩해야 한다.
	 		참고) stringClass.GetBytesExample.java
	 		
	 	4) indexOf()
	 		- indexOf() 메소드는 매개값으로 주어진 문자열이 시작되는 인덱스를 리턴한다.
	 		- 주어진 문자열이 포함되어있지 않으면 -1을 리턴한다.
	 		----------------------------------------------------------
	 			String subject = "자바 프로그래밍";
	 			int index = subject.indexOf("프로그래밍");		// index = 3
	 		----------------------------------------------------------
	 		- indexOf() 메소드는 if문의 조건식에서 특정 문자열이 포함되어 있는지 여부에 따라 실행 코드를
	 		  달리할 때 자주 사용된다. -1값을 리턴하면 특정 문자열이 포함되어 있지 않다는 뜻이다.
	 		----------------------------------------------------------
	 			if(문자열.indexOf("찾는문자열") != -1) {
	 				// 포함되어있는 경우
	 			} else {
	 				// 포함되어 있지 않은 경우
	 			}
	 		----------------------------------------------------------
	 		참고) stringClass.IndexOfExample.java
	 		
	 	5) length()
	 		- length() 메소드는 문자열의 길이(문자의 수)를 리턴한다.
	 		----------------------------------------------------------
	 			String subject = "자바 프로그래밍";
	 			int length = subject.length();		// length = 8
	 		----------------------------------------------------------
	 		참고) stringClass.LengthExample.java
	 		
	 	6) replace()
	 		- replace() 메소드는 첫번째 매개값인 문자열을 찾아 두 번째 매개값인 문자열로 대치한
	 		  새로운 문자열을 생성하고 리턴한다.
	 		----------------------------------------------------------
	 			String oldStr = "자바 프로그래밍";
	 			String newStr = oldStr.replace("자바", "JAVA");
	 		----------------------------------------------------------
	 		- String 객체의 문자열은 변경이 불가한 특성을 갖기 때문에 replace() 메소드가 리턴하는 문자열은
	 		  원래 문자열의 수정본이 아니라 완전히 새로운 문자열이다.
	 		  (newStr 변수는 새로 생성된 "JAVA 프로그래밍" 문자열을 참조한다.)
	 		참고) stringClass.RepalceExample.java
	 		
	 	7) substring()
	 		- substring() 메소드는 주어진 인덱스에서 문자열을 추출한다.
	 		- substring(int beginIndex, int endIndex)는 주어진 시작과 끝 인덱스 사이의 문자열을 추출한다.
	 		  (endIndex에 해당하는 문자열은 추출하지 않는다)
	 		- substring(int beginIndex)는 주어진 인덱스부터 끝까지 문자열을 추출한다.
	 		----------------------------------------------------------
	 			String ssn = "123456-456789";
	 			String firstNum = ssn.substring(0, 6);		// firstNum = 123456
	 			String secondNum = ssn.substring(7);		// secondNum = 456789
	 		----------------------------------------------------------
	 		참고) stringClass.SubstringExample.java
	 			
	 