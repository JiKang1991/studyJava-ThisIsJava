	chapter011 basic-API-class
	
	-- Table of contents --
		11.1 Java API document
		11.2 java.lang and java.util package
		11.3 Object class
		11.4 Objects class
		11.5 System class
		11.6 Class class
		11.7 Stirng class
		11.8 StringTokenizer class
		11.9 StringBuffer, StringBuilder class
		11.10 regular expressions and Pattern class
		11.11 Arrays class
		11.12 Wrapper(포장) class
		11.13 Math, Random class
		11.14 Date, Calendar class
		11.15 Format class
		11.16 java.time package
	-----------------------
	
	11.1 Java API document
		* API(Application Programming Interface) : 라이브러리(library)라고 부르기도 하며,
			프로그램 개발에 자주 사용되는 클래스 및 인터페이스의 모음을 말한다. 
			ex) String class, System class
		- API들은 <JDK 설치경로> /jre/lib/rt.jar라는 압축 파일에 저장되어있다.
		* API document : 쉽게 API를 찾아 이용할 수 있도록 문서화한 것
			'http://docs.oracle.com/javase/8/docs/api'
		- 좌측 상단 프레임(패키지 전체 목록)
		- 좌측 하단 프레임(패키지에 속하는 클래스와 인터페이스 목록)
		- 중앙 프레임 (좌측 하단 프레임에서 선택한 클래스나 인터페이스에 대한 상세 설명)
			(1) 상단 부분 : 클래스가 포함된 패키지 정보, 상속정보, 인터페이스 구현 정보
			(2) 중앙 부분 : 클래스의 설명과 사용방법 요약
			(3) 하단 부분 : 필드, 생성자, 메소드 목록
		- 이클립스에서는 자바 에디터에서 클래스를 마우스로 선택한 다음 'F1'키를 누르면
		  자동으로 API 도큐먼트를 보여주는 Help 뷰가 실행된다.
		  
	11.2 java.lang and java.util package
	11.2.1 java.lang package
		- java.lang package는 자바 프로그램의 기본적인 클래스를 담고 있는 패키지이다.
		- java.lang package에 있는 클래스와 인터페이스는 import 없이 사용할 수 있다.
			ex) String, System
		----------------------------------------------------------
		클래스								용도
		Object								- 자바 클래스 최상위 클래스로 사용
			
		System								- 표준 입력 장치(키보드)로 부터 데이터를 입력받을때 사용
											- 표준 출력 장치(모니터)로 출력하기 위해 사용
											- 자바 가상 기계를 종료시킬 때 사용
											- 쓰레기 수집기를 실행 요청할 때 사용
		
		Class								- 클래스를 메모리로 로딩할 때 사용
		
		String								- 문자열을 저장하고 여러가지 정보를 얻을 때 사용
		
		StringBuffer, StringBuilder			- 문자열을 저장하고 내부 문자열을 조작할 때 사용
		
		Math								- 수학 함수를 이용할 때 사용
		
		Wrapper		Byte, Short, Character 	- 기본 타입의 데이터를 갖는 객체를 만들 때 사용
					Integer, Float, Double	- 문자열을 기본 타입으로 변환할 때 사용
					Boolean, Long			- 입력값 검사에 사용
		----------------------------------------------------------
		
	11.2.2 java.util package
		- java.util package는 자바 프로그램 개발에 조미료 같은 역할을 하는 클래스를 담고 있다.
		- java.util package는 컬렉션 클래스들이 대부분을 차지하고 있다.
		----------------------------------------------------------
			클래스				용도
			Arrays				- 배열을 조작(비교, 복사, 정렬, 찾기)할 때 사용
		
			Calendar			- 운영체제의 날짜와 시간을 얻을 때 사용
		
			Date				- 날짜와 시간 정보를 저장하는 클래스
		
			Objects				- 객체 비교, 널(null) 여부 등을 조사할 때 사용
		
			StringTokenizer		- 특정 문자로 구분된 문자열을 뽑아낼 때 사용
		
			Random				- 난수를 얻을 때 사용
		----------------------------------------------------------
	
	
	11.3 Object class
		- 클래스를 선언할 때 extends 키워드로 다른 클래스를 상속하지 않으면 암시적으로
		  'java.lang.Objcet' 클래스를 상속하게 된다.
		- 자바의 모든 클래스는 Object 클래스의 자식이거나 자손 클래스이다.
		  Object는 자바의 최상위 부모 클래스에 해당한다.
		- Objcet 클래스는 필드가 없고, 메소드들로 구성되어있다. 
		  이 메소드들은 모든 클래스가 Objcet를 상속하기 때문에 모든 클래스에서 사용이 가능하다.
	
	11.3.1 equals()
		- 'public boolean equals(Object obj) { ... }'
		- equals() 메소드의 매개 타입은 Object인데, 이것은 모든 객체가 매개값으로 대입될 수 있음을 말한다.
		- Object가 최상위 타입이므로 모든 객체는 Object 타입으로 자동 타입 변환될 수 있기 때문이다.
		- equals() 메소드는 비교 연산자인 '=='과 동일한 결과를 리턴한다.
		  두 객체가 동일한 객체라면 true를 리턴하고 그렇지 않으면 false를 리턴한다.
		----------------------------------------------------------
			Object obj1 = new Object();
			Object obj2 = new Object();
			
			// 아래 두 식의 결과는 동일하다
			boolean result = obj1.equals(obj2);
			boolean result = (obj1 == obj2);
		----------------------------------------------------------
		- 자바에서는 두 객체를 동등 비교할 때 equals() 메소드를 흔히 사용한다.
		- equals() 메소드는 두 객체를 비교해서 논리적으로 동등하면 true를 리턴하고, 그렇지 않으면 false를 리턴한다.
		- 논리적으로 동등하다는 것은 같은 객체이건 다른 객체이건 상관없이 객체가 저장하고 있는 데이터가 동일함을 뜻한다.
		- 예를 들어 String 객체의 equals() 메소드는 String 객체의 번지를 비교하는 것이 아니고,
		  문자열이 동일한지 조사해서 같아면 true를 리턴하고, 그렇지 않다면 false를 리턴한다.
		- 이것이 가능한 이유는 String 클래스가 Object의 equals() 메소드를 재정의(오버라이딩)해서 번지 비교가 아닌
		  문자열 비교로 변경했기 때문이다.
		- Object의 equal() 메소드는 직접 사용되지 않고 하위 클래스에서 재정의하여 논리적으로 동등 비교할 대 이용된다.
		- 예를 들어 Member 객체는 다르지만 id 필드값이 같으면 논리적으로 동등한 객체로 취급하고 싶을 경우
		  Object의 equals() 메소드를 재정의 해서 id 필드 값이 같음을 비교하면 된다.
		- equals() 메소드를 재정의 할 때에는 매개값(비교 객체)이 기준 객체와 동일한 타입의 객체인지 먼저 확인해야 한다.
		- Objcet 타입의 매개 변수는 모든 객체가 배개값으로 제공될 수 있기 때문에 
		  instanceof 연산자로 기준 객체와 동일한 타입인지 제일 먼저 확인해야 한다.
		- 비교 객체가 다른 타입이라면 equals() 메소드는 false를 리턴해야 한다.
		- 비교 객체가 동일한 타입이라면 기준 객체 타입으로 강제 타입 변환해서 필드값이 동일한지 검사하면 된다.
		참고) objectClass.EqualsMember.java
			 objectClass.EqualsMemberExample.java
			 
	11.3.2 hashCode()
		- 객체 해시코드란 객체를 식별할 하나의 정수값을 말한다.
		- Object의 hashCode() 메소드는 객체의 메모리 번지를 이용해서 해시코드를 만들어 리턴하기 때문에
		  객체마다 다른 값을 가지고 있다.
		- 논리적 동등 비교 시 hashCode()를 오버라이딩할 필요성이 있다.
		- 컬렉션 프레임워크에서 HashSet, HashMap, HashTable은 hashCode() 메소드를 실행해서
		  리턴된 해시코드 값이 같은지를 본다. 해시 코드 값이 다르면 다른 객체로 판단하고, 해시코드 값이 같으면
		  equals() 메소드로 다시 비교한다. 그렇기 때문에 hashCode() 메소드가 true가 나와도
		  equals()의 리턴값이 다르면 다른 객체가 된다.
		참고) objectClass.HashCodeKey.java
			 objectClass.HashCodeKeyExample.java
			 objectClass.HashCodeOverridingKey.java
			 objectClass.HashCodeOverridingKeyExample.java
			 objectClass.HashCodeOverridingMember.java
		- 두 개의 객체가 동일한 클래스로 만들어지고 동일한 필드값을 가지고 있다고 하더라도 객체를 생성할때 마다
		  다른 해시코드가 리턴되기 때문에 논리적 동등 비교시 컬렉션 프레임 워크의 HashSet, HashMap, HashTable은
		  두 개의 객체를 서로 다른 객체로 인식한다. 이러한 문제를 해소하기 위해 hashCode()메소드를 재정의하여
		  두 개의 객체가 같은 hashCode 값을 리턴하도록 만들면 두 개의 객체는 동일한 객체가 된다.
		  
	11.3.3 toString()
		- Object 클래스의 toString() 메소드는 객체의 문자 정보를 리턴한다.
		- 객체의 문자 정보란 객체를 문자열로 표현한 값을 말한다.
		- 기본적으로 Object 클래스의 toString() 메소드는 "클래스명@16진수해시코드"로
		  구성된 문자 정보를 리턴한다.
		----------------------------------------------------------
			Object obj = new Object();
			System.out.println(obj.toString());
			
			실행결과 예시 : 'java.lang.Object@de6ced'
		----------------------------------------------------------
		- Object의 toString() 메소드의 리턴값은 자바 애플리케이션에서는 별 값어치가 없는 정보이므로
		  Object의 하위 클래스는 toString() 메소드를 재정의(오버라이딩)하여 간결하고 유익한 정보를 리턴하도록 되어있다.
		- 예를 들어 java.util 패키지의 Date 클래스는 toString() 메소드를 재정의하여
		  현재 시스템의 날짜와 시간 정보를 리턴한다.
		- String 클래스는 toString() 메소드를 오버라이딩하여 저장하고 있는 문자열을 리턴한다.
		참고) objectClass.ToStringExample.java
			 objectClass.ToStringSmartPhone.java
			 objectClass.ToStringSmartPhoneExample.java
		
	11.3.4 clone()
		- 객체 복제는 원본 객체의 필드값과 동일한 값을 가지는 새로운 객체를 생성하는 것을 말한다.
		- 원본 객체를 안전하게 보호하기 위해서 객체를 복제한다.
		- 신뢰하지 않는 영역으로 원본 객체를 넘겨 작업할 경우 원본 객체의 데이터가 훼손될 수 있기 때문에
		  복제된 객체를 만들어 신뢰하지 않는 영역으로 넘기는 것이 좋다.
		- 복제된 객체의 데이터가 훼손되더라도 원본 객체는 아무런 영향을 받지 않기 때문에
		  안전하게 데이터를 보호할 수 있게 된다.
		- 객체를 복제하는 방법에는 얕은 복제와 깊은 복제가 있다.
		
		1) thin clone(얕은 복제)
		- 얕은 복재란 단순히 필드 값을 복사해서 객체를 복제하는 것을 말한다.
		- 필드값만 복제하기 때문에 필드가 기본타입일 경우 값 복사가 일어나고,
		  필드가 참조 타입일 경우에는 객체의 번지가 복사된다.
		- Object의 clone() 메소드는 자신과 동일한 필드값을 가진 얕은 복제된 객체를 리턴한다.
		- 이 메소드로 객체를 복제하려면 원본 객체는 반드시 'java.lang.Cloneable'인터페이스를 구현하고 있어야 한다.
		- 메소드 선언이 없음에도 불구하고 Cloneable 인터페이스를 명시적으로 구현하는 이유는 클래스 설계자가
		  복제를 허용한다는 의도적인 표시를 하기 위해서이다.
		  클래스 설계자가 복제를 허용하지 않는다면 Cloneable 인터페이스를 구현하지 않으면 된다.
		- Cloneable 인터페이스를 구현하지 않으면 clone() 메소드를 호출할 때
		  CloneNotSupportedException 예외가 발생하여 복제가 실패된다.
		- clone()은 CloneNotSupportedException 예외 처리가 필요한 메소드이기 때문에
		  try-catch 구문이 필요하다
		----------------------------------------------------------
			try {
				Object obj = clone();
			} catch(CloneNotSupportedException e) { }
		----------------------------------------------------------
		참고) objectClass.ThinCloneMember.java
			 objectClass.ThinCloneMemberExample.java
			 
		2) deep clone(깊은 복제)
		- 얕은 복제의 경우 참조 타입 필드는 번지만 복제되기 때문에 원본 객체의 필드와 복제 객체의 필드는
		  같은 객체를 참조하게 된다.
		- 만약 복제 객체에서 참조 객체를 변경하면 원본 객체도 변경된 객체를 가지게 된다. 이것이 얕은 복제의 단점이다.
		- 깊은 복제란 참조하고 있는 개체도 복제하는 것을 말한다.
		- 깊은 복제를 하려면 Objcet의 clone() 메소드를 재정의해서 참조 객체를 복제하는 코드를 직접 작성해야 한다.
		참고) objcetClass.DeepCloneMember.java
			 objectClass.DeepCloneMemberExample.java
			 objcetClass.DeepCloneCar.java
			 
	11.3.5 finalize()
		- 참조하지 않는 배열이나 객체는 쓰레기 수집기(Garbage Collector)가 힙 영역에서 자동적으로 소멸시킨다.
		- 쓰레기 수집기는 객체를 소멸하기 직전에 마지막으로 객체의 소멸자(finalize())를 실행시킨다.
		- 소멸자는 Objcet의 finalize() 메소드를 말하는데, 기본적으로 실행 내용이 없다.
		- 만약 객체가 소멸되기 전에 마지막으로 사용했던 자원(데이터 연결, 파일 등)을 닫고 싶거나 중요한 데이터를
		  저장하고 싶다면 Object의 finalize()를 재정의 할 수 있다.
		참고) objectClass.FinalizeCounter.java
			 objectClass.FinalizeExample.java
				
		- 한두 개의 객체를 쓰레기로 만들었다고 해서 쓰레기 수집기가 실행되는 것은 아니다.
		- garbage collector는 메모리가 부족할 때 그리고 CPU가 한가할 때에 JVM에 의해서 자동 실행된다.
		- finalize() 메소드가 호출되는 시점은 명확하지 않으며, 일정한 순서로 호출하지 않는다.
		  또한 쓰레기 데이터를 전부 소멸시키는 것이 아니라 메모리의 상태를 보고 일부만 소멸시킨다.
		- 코드에서 'System.gc()'를 선언하면 가급적 빨리 garbage collector를 실행 시켜 달라고 JVM에게 요청하는 것이다.
		- 프로그램이 종료될 때 즉시 자원을 해제하거나 즉시 데이터를 최종 저장해야 한다면, 일반 메소드에서 작성하고
		  프로그램이 종료될 때 명시적으로 finalize() 메소드를 호출하는 것이 좋다.
		  
	
	11.4 Objects class
		- 객체 비교, 해시코드 생성, null 여부, 객체 문자열 리턴 등의 연산을 수행하는 정적 메소드들로 구성된
		  Object의 유틸리티 클래스이다.
		----------------------------------------------------------
			리턴타입		메소드(매개 변수)						설명
			int			compare(T a, T b, Comparator<T> c)	두 객체 a와 b를 Comparator를 사용해서 비교한다.
			
			boolean		deepEquals(Object a, Object b)		두 객체의 깊은 비교(배열의 항목까지 비교한다.)
			
			boolean		equals(Object a, Object a)			두 객체의 얕은 비교(번지만 비교한다.)
			
			int			hash(Object... values)				매개값이 저장된 배열의 해시코드를 생성한다.
			
			int			hashCode(Object o)					객체의 해시코드를 생성한다.
			
			boolean		isNull(Object obj)					객체가 null인지 조사한다.
			
			boolean		nonNull(Object obj)					객체가 null이 아닌지 조사한다.
			
			T			requireNonNull(T obj)				객체가 null인 경우 예외 발생
			
			T			requireNonNull(T obj,				객체가 null인 경우 예외 발생
						 String message)					(주어진 예외 메시지 포함)
				
			T			requireNonNull(T obj,				객체가 null인 경우 예외 발생
						 Supplier<String> messageSupplier)	(람다식이 만든 예외 메시지 포함)
						
			String		toString(Object o)					객체의 toString() 리턴값 리턴
			
			String		toString(Object o,					객체의 toString() 리턴값 리턴, 첫 번째
						 String nullDefault)				매개값이 null일 경우 두 번째 매개값 리턴
			----------------------------------------------------------
			
	11.4.1 compare(T a, T b, Comparator<T> c)
		- Objects.compare(T a, T b, Comparator<T> c) 메소드는 두 객체를 비교자(Comparator)로
		  비교해서 int 값을 리턴한다.
		- java.util.Comparator<T>는 제네릭 인터페이스 타입으로 두 객체를 비교하는
		  Compare(T a, T b) 메소드가 정의되어 있다.
		* T : 비교할 객체 타입
		- compare() 메소드의 리턴 타입은 int이며, a가 b보다 작으면 음수, 크면 양수를 리턴하도록 구현 클래스를 만들어야 한다.
		----------------------------------------------------------
			public interface Comparator<T> {
				int compare(T a, T b);
			}
		----------------------------------------------------------
		참고) objectsClass.CompareStudentComparator.java
			 objectsClass.CompareExample.java
			 objectsClass.CompareStudent.java
			 
	11.4.2 equals() and deepEquals()
		- Objects.equals(Object a, Object b)는 두 객체의 동등을 비교하여 a와 b가 모두 null일 경우
		  true를 리턴하고, a와 b가 모두 null이 아닐경우 a.equals(b)의 리턴값을 리턴한다.
		----------------------------------------------------------
			a			b			Objects.equals(a, b)
			not null	not null	a.equals(b)의 리턴값
			null		not null	false
			not null	null		false
			null		null		true
		----------------------------------------------------------
		- Objects.deepEquals(Object a, Object b)는 두 객체의 동등을 비교하여 a와 b가 서로 다른 배열일 경우,
		  항목 값이 모두 같다면 true를 리턴한다.
		- Arrays.deepEquals(Object[] a, Object[] b)와 동일하다.
		----------------------------------------------------------
			a						b						Objects.deepEquals(a, b)
			not null(not array)		not null(not array)		a.equals(b)의 리턴값
			not null(array)			not null(array)			Arrays.deepEquals(a, b)의 리턴값
			null					not null				false
			null					null					true
		----------------------------------------------------------
		참고) objectsClass.EqualsAndDeepEqualsExample.java
		
	11.4.3 to create hashcode ( hash(), hashCode() )
		- Objects.hash(Object... values) 메소든느 매개값으로 주어진 값들을 이용해서 해시 코드를 생성하는 역할을 한다.
		- 주어진 매개값드로 배열을 생성하고 Arrays.hashCode(Object[])를 호출해서 해시코드를 얻고 이 값을 리턴한다.
		- hash() 메소드는 츨래스가 hashCode()를 재정의할 때 리턴값을 생성하기 위해 사용하면 좋다.
		- 클래스가 여러 가지 필드를 가지고 있을 때 이 필드들로부터 해시코드를 생성하게 되면
		  동일한 필드값을 가지는 객체는 동일한 해시코드를 가질 수 있다.
		----------------------------------------------------------
			@Override
			public int hashCode() {
				return Objects.hash(field1, field2, field3);
			}
		----------------------------------------------------------
		- Objects.hashCode(Object o)는 매개값으로 주어진 객체의 해시코드를 리턴하기 때문에
		  o.hashCode()의 리턴값과 동일하다.
		- 차이점은 매개값이 null이면 0을 리턴한다.
		참고) objectsClass.HashCodeExample.java
			 objectsClass.Student.java
			 
	11.4.4 isNull(), nonNull(), requireNonNull()
		- Objects.isNull(Object obj)는 매개값이 null일 경우 true를 리턴한다.
		- Objects.nonNull(Object obj)는 매개값이 not null일 경우 true를 리턴한다.
		- ObjectsrequireNonNull()는 3가지 경우로 오버로딩 되어있다.
		----------------------------------------------------------
			리턴 타입		메소드(매개 변수)					설명
			T			requireNonNull(T obj)			not null -> obj
														null -> NullPointerException
			T			requireNonNull(T obj,			not null -> obj
						  String message)				null -> NullPointerException(message)
			T			requireNonNoll(T obj,			not null -> obj
						  Supplier<String> msgSupplier	null -> NullPointerException(msgSupplier.get())
		----------------------------------------------------------
		참고) objectsClass.NullExample.java
		
	11.4.5 toString()
		- Object.toString()은 객체의 문자 정보를 리턴하는데 2가지 경우로 오버로딩 되어있다.
		----------------------------------------------------------
			리턴 타입		메소드(매개 변수)					설명
			String		toString(Object o)				not null -> o.toString()
														null -> "null"
			String		toString(Object o,				not null -> o.toString()
			 String nullDefault)						null -> nullDefault
		----------------------------------------------------------
		- 첫 번째 매개값이 not null이면 toString()으로 얻은 값을 리턴하고,
		  null이면 "null" 또는 두번째 매개값인 nullDefault를 리턴한다.
		참고) objectsClass.ToStringExample.java
		
	
	11.5 System Class
		- 자바 프로그램은 운영체제상에서 바로 실행되는 것이 아니라 JVM 위에서 실행된다. 따라서 운영체제의 모든 기능을
		  자바 코드로 직접 접근하기란 어렵다.
		- java.lang package에 속하는 System 클래스를 이용하면 운영체제의 일부 기능을 이용할 수 있다.
		- 프로그램 종료, 키보드로부터 입력, 모니터로 출력, 메모리 정리, 현재 시간 읽기, 시스템 프로퍼티 읽기,
		  환경 변수 읽기 등이 가능하다.
		- System 클래스의 모든 필드와 메소드는 정적(static) 필드와 정적(static) 메소드로 구성되어 있다.
		
	11.5.1 exit()
		- 경우에 따라서는 강제적으로 JVM을 종료시킬 때도 있다. 이때 System 클래스의 exit()메소드를 호출하면 된다.
		- exit() 메소드는 현재 실행하고 있는 프로세스를 강제 종료 시키는 역할을 한다.
		- exit() 메소드는 int 매개값을 지정하도록 되어있는데 이 값을 종료 상태값이라고 한다.
		- 일반적으로 정상 종료일 경우 0으로 지정하고 비정상 종료일 경우 0이외의 다른 값을 준다.
			ex) System.exit(0);
		- 어떤 값을 주더라도 종료가 되는데, 만약 특정 값이 입력되었을 경우에만 종료하고 싶다면 자바의 보안관리자를
		  직접 설정해서 종료 상태값을 확인하면 된다.
		- exit() 메소드에서 종료 상태값을 조사해서 특정 값이 입력되지 않으면 SecurityException을 발생시켜
		  System.exit()를 호출한 곳에서 예외 처리를 할 수 있도록 해준다.
		- checkExit()가 정상적으로 실행되면 JVM은 종료가 된다.
		----------------------------------------------------------
			System.setSecurityManager(new SecurityManager(){
				@Override
				public void checkExit(int status) {
					if(status != 5) {
						throw new SecurityException();
					}
				}
			});
		----------------------------------------------------------
		참고) objectsClass.ExitExample.java
		
	11.5.2 gc()(Garbage Collector)
		- 자바는 개발자가 메모리를 직접 코드로 관리하지 않고 JVM이 알아서 자동으로 관리한다.
		 - JVM은 메모리가 부족할 때와 CPU가 한가할 때에 Garbage Collector를 실행시켜 사용하지 않는 객체를 자동 제거한다.
		 - Garbage Collector는 개발자가 직접 코드로 실행시킬 수 없고,
		   System.gc() 메소드로 JVM에게 가능한한 빨리 실행해 달라고 요청할 수는 있다.
		 - System.gc() 메소드가 호출되면 쓰레기 수집기가 바로 실행되는 것은 아니지만
		   JVM은 빠른 시간 내에 실행시키기 위해 노력한다.
		 - 쓰레기가 생길 때마다 Garbage Collector가 동작한다면 정작 수행되어야 할 프로그램의 속도가 떨어지기 때문에
		   성능 측면에서 좋지 않다.
		 - 메모리가 충분하다면 굳이 Garbage Collector를 실행할 필요가 없다.
		 참고) systemClass.GcExample.java
		 
	11.5.3 currentTimeMillis(), nanoTime()
		- currentTimeMillis() 메소드와 nanoTime() 메소드는 컴퓨터의 시계로부터 현재 시간을 읽어서
		  밀리세컨드(1/1000초) 단위와 나노세컨드(1/10^9초)단위의 long 값을 리턴한다.
		  	ex) long time = System.currentTimeMillis();
		  		long time = System.nanoTime();
		- 리턴값은 주로 프로그램의 실행 소요 시간 측정에 사용된다.
		- 프로그램 시작시 시각을 읽고, 프로그램이 끝날 대 시각을 읽어서 차이를 구하면
		  프로그램 실행 소요 시간이 나온다.
		참고) systemClass.SystemTimeExample.java
	
	11.5.4 getProperty()
		- 시스템 프로퍼티(System Property)는 JVM이 시작할 때 자동 설정되는 시스템의 속성값을 말한다.
		- 예를 들어 운영체제의 종류 및 자바 프로그램을 실행시킨 사용자 아이디, JVM의 버전,
		  운영체제에서 사용되는 파일 경로 구분자 등이 여기에 속한다.
		- 시스템 프로퍼티는 키(key)와 값(value)으로 구성되어있다.
		----------------------------------------------------------
			키(key)			설명								값(value)
			java.version	자바의 버전						1.8.0_20
			java.home		사용하는 JRE의 파일 경로				<jdk 설치경로>\jre
			os.name			Operating system name			Windows 10
			file.separator	File separator("\" on UNIX)		\
			user.name		사용자의 이름						사용자 계정
			user.home		사용자의 홈 디렉토리					C:\Users\사용자 계정
			user.dir		사용자가 현재 작업 중인 디렉토리 경로	다양
		----------------------------------------------------------
		- 시스템 프로퍼티를 읽어오기 위해서는 System.getProperty() 메소드를 이용하면 된다.
		  이 메소드는 시스템 프로퍼티의 키 이름을 매개값으로 받고, 해당 키에 대한 값을 물자열로 리턴한다.
			ex) String value = System.getProperty(String key);
		참고) systemClass.GetPropertyExample.java
		
		- System.getProperties() 메소드는 모든(키, 값) 쌍을 저장하고 있는 Properties 객체를 리턴한다.
		  이 객체의 keySet() 메소드를 호출하면 키만으로 구성된 Set 객체를 얻을 수 있다.
		  for문은 Set객체로부터 키를 하나씩 얻어내여 문자열로 변환한 다음, System.getProperty() 메소드로
		  값을 얻어 키와 값을 모두 출력한다.
		  
	11.5.5 getenv()
		- 대부분의 운영체제는 실행되는 프로그램들에게 유요한 정보를 제공할 목적으로
		  환경 변수(Environment Variable)를 제공한다.
		- 환경 변수는 프로그램 상의 변수가 아니라 운영체제에서 이름(Name)과 값(Value)으로 관리되는 문자열 정보다.
		- 환경 변수는 운영체제가 설치될 때 기본적인 내용이 설정되고, 사용자가 직접 설정하거나
		  응용프로그램이 설치될 때 자동적으로 추가 설정 되기도 한다.
		- 사용자가 환경 변수를 설정하는 방법은 운영체제마다 조금씩 다르며, Windows 계열의 운영체제에서는
		  [ 제어판 -> 시스템 및 보안 -> 시스템 -> 고급시스템 설정 -> 시스템 속성 -> 고급
		   -> 환경 변수 -> 시스템 변수 (새로 만들기, 편집, 삭제) ] 를 이용해서 설정한다.
		- 자바 프로그램에서는 환경 변수의 값이 필요할 경우 System.getenv() 메소드를 사용한다.
		  매개값으로 환경 변수 이름을 주면 값을 리턴한다.
			ex) String value = System.getenv(String name);
		참고) systemClass.SystemEnvExample.java
		
	
	11.6 Class class
		- 자바는 클래스와 인터페이스의 메타 데이터를 java.lang 패키지에 소속된 class 클래스로 관리한다.
		- 메타 데이터란 클래스의 이름, 생성자 정보, 필드 정보, 메소드 정보를 말한다.
		
	11.6.1 getClass(), forName()
		- 프로그램에서 Class 객체를 얻기 위해서는 Object 클래스가 가지고 있는 getClass() 메소드를 이용하면 된다.
		- Object는 모든 클래스의 최상위 클래스이므로 모든 클래스에서 getClass() 메소드를 호출할 수 있다.
			ex) Class clazz = obj.getClass();
		- getClass() 메소드는 해당 클래스로 객체를 생성 했을 때만 사용할 수 있다.
		- 정적 메소드인 forName()을 이용하면 객체를 생성하기 전에 직접 Class 객체를 얻을 수 있다.
		  ( Class는 생성자를 감추고 있기 때문에 new 연산자로 객체를 생성할 수 없다. )
		- forName() 메소드는 클래스 전체 이름(패키지가 포함된 이름)을 매개값으로 받고 Class 객체를 리턴한다.
		----------------------------------------------------------
			try {
				Class clazz = Class.forname(String classname);
			} catch (ClassNotFoundException e) {
			}
		----------------------------------------------------------
		- Class.forName() 메소드는 매개값으로 주어진 클래스를 찾지 못하면 ClassNotFoundException 예외를
		  발생시키기 때문에 예외 처리가 필요하다.
		참고) classClass.GetClassAndForNameExample.java
		
	11.6.2 reflection
		- Class 객체를 이용하면 클래스의 생성자, 필드, 메소드 정보를 알아낼 수 있다.
		  이것을 리플랙션(Reflection)이라고 한다.
		- Class 객체는 리플렉션을 위해 getDeclaredConstructors(), getDeclaredFields(),
		  getDeclaredMethods()를 제공하고 있다.
		  	ex)	Constructor[] constructors = clazz.getDeclaredConstructors();
		  		Field[] fields = clazz.getDeclaredFields();
		  		Method[] methods = clazz.getDeclaredMethods();
		- Constructor, Field, Method 클래스는 모두 java.lang.reflect 패키지에 소속되어 있다.
		- getDeclaredFields(), getDeclaredMethods()는 클래스에 선언된 멤버만 가져오고
		  상속된 멤버는 가져오지 않는다.
		- getFields(), getMethods() 메소드를 활용하여 상속된 멤버를 얻을 수 있다. 단, public 멤버만 가져온다.
		참고) classClass.ReflectionExample.java
		
	11.6.3 newInstance()
		- Class 객체를 이용하면 new 연산자를 사용하지 않아도 동적으로 객체를 생성할 수 있다.
		- 이 방법은 코드 작성 시에 클래스 이름을 결정할 수 없고, 런타임 시에 클래스 이름이 결정되는 경우에
		  매우 유용하게 사용된다.
		- Class.forName() 메소드로 Class 객체를 얻은 다음 newInstance() 메소드를 호출하면 Object 타입의
		  객체를 얻을 수 있다.
		----------------------------------------------------------
			try {
				Class clazz = Class.forName("런타임 시 결정되는 클래스 이름");
				Object obj = clazz.newInstance();
			} catch(ClassNotFoundException e) {
			} catch(InstantiationException e) {
			} catch(IllegalAccessException e) {
			}
		----------------------------------------------------------
		- newInstance() 메소드는 기본 생성자를 호출해서 객체를 생성하기 때문에 반드시 클래스에 기본 생성자가 존재해야 한다.
		- 매개 변수가 있는 생성자를 호출하고 싶다면 reflection으로 Constructor 객체를 얻어
		  newInstance() 메소드를 호출하면 된다.
		- 해당 클래스가 추상 클래스이거나 인터페이스일 경우 InstantiationException 예외가 발생한다.
		- 생성자가 접근 제한자로 인해 접근할 수 없을 경우 IllegalAccessException 예외가 발생한다.
		- newInstance() 메소드의 리턴 타입은 Object이므로 이것을 원래 클래스 타입으로 변환해야만 메소드를 사용할 수 있다.
		- 클래스 타입을 모르는 상태에서는 강제 타입 변환을 하지 못하므로 인터페이스를 사용한다.
		- 예를 들어 execute() 메소드를 선언하고있는 Action 인터페이스가 있고,
		  이를 구현하는 SendAction 클래스와 ReceiveAction클래스가 있다고 가정해보자
		- Class.forName() 메소드의 매개값으로 "SendAction" 또는 "ReceiveAction"을 주면 Class 객체가 만들어지고,
		  Class 객체의 newInstance() 메소드로 Object 객체를 얻을 수 있다.
		- 얻어진 객체는 모두 Action 인터페이스를 구현하고 있기 때문에 Action 인터페이스 타입으로 변환하여
		  execute() 메소드를 호출하면, 개별 클래스의 실체 메소드인 execute() 메소드가 실행된다.
		----------------------------------------------------------
			Class clazz = Class.forName("SendAction" 또는 "ReceiveAction");
			Action action = (Action) clazz.newInstance();
			action.execute();
		----------------------------------------------------------
		참고) classClass.NewInstanceAction.java
			 classClass.NewInstanceSendAction.java
			 classClass.NewInstanceReceiveAction.java
			 classClass.NewInstanceExample.java
			 
	
	11.7 String class
	11.7.1 String constructor
		- 자바의 문자열은 java.lang 패키지의 String 클래스의 인스턴스로 관리된다.
		- 소스상에서 문자열 리터럴은 String 객체로 자동 생성되지만, String 클래스의 다양한 생성자를 이용해서
		  직접 String 객체를 생성할 수도 있다. 
		- String 클래스는 Deprecated(비권장)된 생성자를 제외하고 약 13개의 생성자를 제공한다.
		- Deprecated는 예전 자바 버전에선느 사용되었으나, 현재 버전과 차후 버전에서는 사용하지 말라는 뜻이다.
		- 어떤 생성자를 이용해서 String 객체를 생성할지는 제공되는 매개값의 타입에 달려있다.
		- 파일의 내용을 익거나, 네트워크를 통해 받는 데이터는 보통 byte[] 배열이므로 이것을 문자열로 변환하기 위해
		  다음의 생성자들이 자주 사용된다.
		----------------------------------------------------------
			// 배열 전체를 String 객체로 생성
			String str = new String(byte[] bytes);
			// 지정한 문자셋으로 디코딩
			String str = new String(byte[] bytes, String charseName);
			
			// 배열의 offset 인덱스 위치부터 length만큼 String 객체로 생성
			String str = new String(byte[] bytes, int offset, int length);
			// 지정한 문자셋으로 디코딩
			String str = new String(byte[] bytes, int offset, int length, String charseName);
		----------------------------------------------------------
		참고) stringClass.ConstructorByteToStringExample.java
		
		- System.in.read() 메소드는 키보드에서 입력한 내용을 매개값으로 주어진 바이트 배열에 저장하고
		  읽은 바이트 수를 리턴한다.
		  	ex)	Hello + enter button	->	Hello + 캐리지리턴(\r) + 라인피드(\n)
		  		->	72(H), 101(e), 108(l), 108(l), 111(o), 13(\r), 10(\n)
		  		-> 	바이트 배열에 저장 -> 7 리턴
		- 영어는 알파벳 한 자가 1바이트로 표현되지만, 한글과 기타 다른 나라 언어는 2바이트로 표현되기 때문에
		  입력된 문자 수와 읽은 바이트 수가 다를 수 있다.
		참고) stringClass.ConstructorKeyboardToStringExample.java
		
	11.7.2 String method
		- String은 문자열의 추출, 비교, 찾기, 분리, 변환 등과 같은 다양한 메소드를 가지고 있다.
		----------------------------------------------------------
			리턴 타입		메소드명(매개 변수)					설명
			char		charAt(int index)				특정 위치의 문자 리턴
			
			boolean		equals(Object anObject)			두 문자열을 비교
			
			byte[]		getBytes()						byte[]로 리턴
			
			byte[]		getBytes(Charset charset)		주어진 문자셋으로 인코딩한 byte[]로 리턴
			
			int			indexOf(String st)				총 문자의 수를 리턴
			
			String		replace(CharSequence target,	target 부분을 replacement로 대치한
							CharSequence replacement)	새로운 문자열을 리턴
							
			String		subString(int beginIndex)		beginIndex 위치에서 끝까지 잘라낸
														새로운 문자열을 리턴
			String		substring(int beginIndex,		beginIndex 위치에서 endIndex 전까지 잘라낸
							int endIndex)				새로운 문자열을 리턴
							
			String		toLowerCase()					알파벳 소문자로 변환한 새로운 문자열을 리턴
			
			String		toUpperCase()					알파벳 대문자로 변환한 새로운 문자열을 리턴
			
			String		trim()							앞뒤 공백을 제거한 새로운 문자열을 리턴
			
			String		valueOf(int i)					기본 타입값을 문자열로 리턴
						valueOf(double d)
		----------------------------------------------------------
		
		1) charAt()
			- charAt() 메소드는 매개값으로 주어진 인덱스의 문자를 리턴한다. 
			  (인덱스 : 0 ~ "문자열 길이 - 1"까지의 번호)
			----------------------------------------------------------
				String subject = "자바 프로그래밍";
				char charValue = subject.charAt(3);		// charValue = "프"
			----------------------------------------------------------
			참고) stringClass.CharAtExample.java
			
		2) equals()
			- 기본 타입(byte, char, short, int, long, float, double, boolean) 변수의 값을 비교할 때에는
			  == 연산자를 사용한다.
			- 문자열을 비교할 때는 == 연산자를 사용하면 원하지 않는 결과가 나올 수 있다.
			----------------------------------------------------------
				String strVar1 = new String("자바");
				String strVar2 = "자바";
				String strVar3 = "자바";
		
				- 자바는 문자열 리터럴이 동일하다면 동일한 String 객체를 참조하도록 되어있다.
				  strVar2와 strVar3는 동일한 String 객체를 참조한다.
				  strVar1은 new 연산자로 생성된 다를 객체를 참조한다.
				- strVar1과 strVar2의 == 연산은 false를 산출하고
				  strVar2와 strVar3의 == 연산은 true를 산출한다.
				- == 연산자는 각 변수에 저장된 번지를 비교하기 때문에 이러한 결과가 나온다.
			----------------------------------------------------------
			- String 객체의 문자열만을 비교하고 싶다면 == 연산자 대신에 equals() 메소드를 사용해야 한다.
			- 원래 equals()는 Object의 번지 비교 메소드이지만,
			  String 클래스가 오버라이딩해서 문자열을 비교하도록 변경했다.
			참고) stringClass.EqualsExample.java
			
		3) getBytes()
			- 네트워크로 문자열일 전송하거나, 문자열을 암호화할 때 문자열을 바이트 배열로 반환한다.
				ex) byte[] bytes = "문자열".getBytes(); or "문자열".getBytes(Charset charset);
			- getBytes() 메소드는 시스템의 기본 문자셋으로 인코딩 된 바이트 배열을 리턴한다.
			- 특정 문자셋으로 인코딩된 바이트 배열을 얻으려면 getBytes(Charset charset) 메소드를 사용한다.
			----------------------------------------------------------
				try{
					byte[] bytes = "문자열".getBytes("EUC-KR");
					byte[] bytes = "문자열".getBytes("UTF-8");
	 			} catch (UnsupportedEncodingException e) {
	 			}
	 		----------------------------------------------------------
	 		- 인코딩하는 문자셋에 따라 바이트 배열의 크기가 달라진다.
	 		- EUC-KR은 getBytes()와 마찬가지로 알파벳은 1바이트, 한글은 2바이트로 변환한다.
	 		- UTF-8은 알파벳은 1바이트, 한글은 3바이트로 변환한다.
	 		- 잘못된 문자셋을 매개값으로 줄 경우 'java.io.UnsupportedEncodingException'예외가 발생하므로
	 		  예외처리가 필요하다.
	 		- 시스템의 기본 문자셋으로 인코딩된 바이트 배열의 경우 String(byte[] bytes)로 디코딩한다.
	 		- 이외의 문자셋으로 인코딩된 바이트 배열의 경우 String(byte[] bytes, String charsetName)로
	 		  디코딩해야 한다.
	 		참고) stringClass.GetBytesExample.java
	 		
	 	4) indexOf()
	 		- indexOf() 메소드는 매개값으로 주어진 문자열이 시작되는 인덱스를 리턴한다.
	 		- 주어진 문자열이 포함되어있지 않으면 -1을 리턴한다.
	 		----------------------------------------------------------
	 			String subject = "자바 프로그래밍";
	 			int index = subject.indexOf("프로그래밍");		// index = 3
	 		----------------------------------------------------------
	 		- indexOf() 메소드는 if문의 조건식에서 특정 문자열이 포함되어 있는지 여부에 따라 실행 코드를
	 		  달리할 때 자주 사용된다. -1값을 리턴하면 특정 문자열이 포함되어 있지 않다는 뜻이다.
	 		----------------------------------------------------------
	 			if(문자열.indexOf("찾는문자열") != -1) {
	 				// 포함되어있는 경우
	 			} else {
	 				// 포함되어 있지 않은 경우
	 			}
	 		----------------------------------------------------------
	 		참고) stringClass.IndexOfExample.java
	 		
	 	5) length()
	 		- length() 메소드는 문자열의 길이(문자의 수)를 리턴한다.
	 		----------------------------------------------------------
	 			String subject = "자바 프로그래밍";
	 			int length = subject.length();		// length = 8
	 		----------------------------------------------------------
	 		참고) stringClass.LengthExample.java
	 		
	 	6) replace()
	 		- replace() 메소드는 첫번째 매개값인 문자열을 찾아 두 번째 매개값인 문자열로 대치한
	 		  새로운 문자열을 생성하고 리턴한다.
	 		----------------------------------------------------------
	 			String oldStr = "자바 프로그래밍";
	 			String newStr = oldStr.replace("자바", "JAVA");
	 		----------------------------------------------------------
	 		- String 객체의 문자열은 변경이 불가한 특성을 갖기 때문에 replace() 메소드가 리턴하는 문자열은
	 		  원래 문자열의 수정본이 아니라 완전히 새로운 문자열이다.
	 		  (newStr 변수는 새로 생성된 "JAVA 프로그래밍" 문자열을 참조한다.)
	 		참고) stringClass.RepalceExample.java
	 		
	 	7) substring()
	 		- substring() 메소드는 주어진 인덱스에서 문자열을 추출한다.
	 		- substring(int beginIndex, int endIndex)는 주어진 시작과 끝 인덱스 사이의 문자열을 추출한다.
	 		  (endIndex에 해당하는 문자열은 추출하지 않는다)
	 		- substring(int beginIndex)는 주어진 인덱스부터 끝까지 문자열을 추출한다.
	 		----------------------------------------------------------
	 			String ssn = "123456-456789";
	 			String firstNum = ssn.substring(0, 6);		// firstNum = 123456
	 			String secondNum = ssn.substring(7);		// secondNum = 456789
	 		----------------------------------------------------------
	 		참고) stringClass.SubstringExample.java
	 			
	 	8) toLowerCase(), toUpperCase()
	 		- toLowerCase() 메소드는 문자열을 모두 소문자로 바꾼 새로운 문자열을 생성한 후 리턴한다.
	 		- toUpperCase() 메소드는 문자열을 모두 대문자로 바꾼 새로운 문자열을 생성한 후 리턴한다.
	 		----------------------------------------------------------
	 			String original = "Java Programming";
	 			String lowerCase = original.toLowerCase();	// lowerCase = java programming
	 			String upperCase = original.toUpperCase();	// upperCase = JAVA PROGRAMMING	
	 		----------------------------------------------------------
	 		- lowerCase 변수는 새로 생성된 "java programming" 문자열을 참조하고
	 		  upperCase 변수는 새로 생성된 "JAVA PROGRAMMING" 문자열을 참조한다.
	 		  원래 "Java Programming" 문자열이 변경된 것은 아니다.
	 		- toLowerCase()와 toUpperCase() 메소드는 영어로 된 두 문자열을 대소문자와 관계없이 비교할 때
	 		  주로 이용한다.
	 		- 두 문자열이 대소문자가 다를 경우 equals() 메소드를 사용하려면 사전에 toLowerCase()와
	 		  toUpperCase()로 대소문자를 맞추어야 하지만, equalsIgnoreCase()메소드를 사용하면 이 작업이
	 		  생략된다.
	 		참고) stringCalss.ToLowerUpperCaseExample.java
	 		
	 	9) trim()
	 		- trim() 메소드는 문자열의 앞뒤 공백을 제거한 새로운 문자열을 생성하고 리턴한다.
	 		- trim() 메소드는 앞뒤의 공백만 제거할 뿐 중간의 공백은 제거하지 않는다.
	 		  또한, 원래 문자열의 공백이 제거되는 것은 아니다.
	 		----------------------------------------------------------
	 			String oldstr = "  자바 프로그래밍  ";
	 			String newstr = oldStr.trim();		// 새로 생성된 "자바 프로그래밍" 문자열을 참조한다.
	 		----------------------------------------------------------
	 		참고) stringClass.TrimExample.java
	 		
	 	10) valueOf()
	 		- valueOf() 메소드는 기본 타입의 값을 문자열로 반환하는 기능을 가지고 있다.
	 		- String 클래스에는 매개 변수의 타입별로 valueOf() 메소드가 오버로딩되어있다.
	 		----------------------------------------------------------
	 			static String valueOf(boolean b)
	 			static String valueOf(char c)
	 			static String valueOf(int i)
	 			static String valueOf(long l)
	 			static String valueOf(double d)
	 			static String valueOf(float f)
			----------------------------------------------------------
			참고) stringClass.ValueOfExample.java
			
			
	11.8 StringTokenizer Class
		- 문자열이 특정 구분자(delimiter)로 연결되어 있을 경우, 구분자를 기준으로 부분 문자열을 분리하기 위해서는
		  String의 split() 메소드를 이용하거나, java.util 패키지의 StringTokenizer 클래스를 이용할 수 있다.
		- split()은 정규 표현식으로 구분하고, StringTokenizer는 문자로 구분한다는 차이점이 있다.
	
	11.8.1 split()
		- String 클래스의 split() 메소드는 정규 표현식을 구분자로해서 문자열을 분리한 후, 배열에 저장하고 리턴한다.
			ex) String[] result = "문자열".split("정규표현식");
		참고) stringClass.SplitExample.java
		
	11.8.2 StringTokenizer Class
		- 문자열이 한 종류의 구분자로 연결되어 있을 경우, StringTokenizer 클래스를 사용하면
		  손쉽게 문자열(토큰:token)을 분리해 낼 수 있다.
		- StringTokenizer 객체를 생성할 대 첫 번째 매개값으로 전체 문자열을 주고,
		  두 번째 매개값으로 구분자를 주면 된다.
			ex) StringTokenizer st = new StringTokenizer("문자열", "구분자");
		- 만약 구분자를 생략하면 공백(space)이 기분 구분자가 된다. 	 		
		----------------------------------------------------------
			String text = "짱구/팽수/마징가";
			StringTokenizer st = new StringTokenizer(text, "/");
		----------------------------------------------------------
		- StringTokenizer 객체가 생성되면 메소드들을 이용해서 전체 토큰수, 남아 있는 토큰 여부를 확인한 다음
		  토큰을 읽으면 된다.
		----------------------------------------------------------
			리턴값		메소드				설명
			int			countTokens()		꺼내지 않고 남아있는 토큰의 수
			boolean		hasMoreTokens()		남아 있는 토큰이 있는지 여부
			String 		nextToken()			토큰을 하나씩 꺼내옴
		----------------------------------------------------------
		- nextToken() 메소드로 토큰을 하나 꺼내오면 StringTokenizer 객체에는 해당 토큰이 없어진다.
		- StringTokenizer 객체에서 더이상 가져올 토큰이 없다면 nextToken()메소드는
		  'java.util.NoSuchElementException' 예외를 발생시킨다.
		- nextToken() 메소드를 사용하기 전에 hasMoreTokens() 메소드로 꺼내올 토큰이 있는지 조사한 후
		  nextToken() 메소드를 호출하는 것이 좋은 코딩 방법이다.
		참고) stringTokenizerClass.Example.java
		
		
	11.9 StringBuffer, StringBuilder Class
		- 문자열을 저장하는 String는 내부의 문자열을 수정할 수 없다.
		  ( 예를 들어 String의 replace() 메소드는 내부의 문자를 대치하는 것이 아니라,
		  대치된 새로운 문자열을 리턴한다. String 객체를 + 연산할 경우에도 마찬가지이다. )
		- 문자열을 결합하는 + 연산자를 많이 사용하면 할수록 그만큼 String 객체의 수가 늘어나기 때문에,
		  프로그램 성능을 느리게 하는 요인이 된다.
		- 문자열을 변경하는 작업이 많을 경우에는 String 클래스를 사용하는 것 보다는 java.lang 패키지의
		  StringBuffer 또는 StringBuilder 클래스를 사용하는 것이 좋다.
		- 이 두 클래스는 내부 버퍼(buffer : 데이터를 임시로 저장하는 메모리)에 문자열을 저장해두고,
		  그 안에서 추가, 수정, 삭제 작업을 할 수 있도록 설계되어 있다.
		  ( String 처럼 새로운 객체를 만들지 않고도 문자열을 조작할 수 있는 것이다. )
		- StringBuffer는 멀티 스레드 환경에서 사용할 수 있도록 동기화가 적용되어 있어 안전하다.
		- StringBuilder는 단일 스레드 환경에섬나 사용하도록 설계되어 있다.
		  ( 두 클래스의 사용 방법은 동일하다. )
		- 기본 생성자인 StringBuilder()는 16개의 문자들을 저장할 수 있는 초기 버퍼를 만들고,
		  StringBuilder(int capacity) 생성자는 capacity로 주어진 개수만큼 문자를 저장할 수 있는
		  초기 버퍼를 만든다.
		- StringBuilder는 버퍼가 부족할 경우 자동으로 버퍼 크기를 늘리기 때문에 초기 버퍼의 크기는 중요하지 않다.
		- StringBuilder(String str) 생성자는 str로 주어진 매개값을 버퍼의 초기값으로 저장한다.
		----------------------------------------------------------
			StringBuilder sb = new StringBuilder();
			StringBuilder sb = new StringBuilder(16);
			StringBuilder sb = new StringBuilder("Java");
		----------------------------------------------------------
		- StringBuilder 객체가 생성되었다면 버퍼 내에서 문자 추가, 삽입, 삭제 등의 작업을 할 수 있다.
		----------------------------------------------------------
			메소드										설명
			append(...)									문자열 끝에 주어진 매개값을 추가한다.
			insert(int offset, ...)  					문자열 중간에 주어진 매개값을 추가한다.
			delete(int start, int end)					문자열의 일부분을 삭제한다.
			deletecharAt(int index)						문자열에서 주어진 index의 문자를 삭제한다.
			replace(int strat, int end, String str)		문자열의 일부분을 다른 문자열로 대치한다.
			reverse()									문자열의 순서를 뒤바꾼다.
			setCharAt(int index, char ch)				문자열에서 주어진 index의 문자를 다른 문자로 대치한다.
		----------------------------------------------------------
		- append() 와 insert() 메소드는 매개 변수가 다양한 타입으로 오버로딩되어 있기 때문에
		  대부분의 값을 문자로 추가 도는 삽입할 수 있다.( API 도큐먼트 참고 )
		참고) stringBuilder.Example.java
		
	
	11.10 Regular Expression and Pattern Class
		- 문자열이 정해져 있는 형식(정규 표현식 : Regular Expression)으로 구성되어 있는지
		  검증해야 하는 경우가 있다.
		- 이메일, 전화번호를 사용자가 제대로 입력했는지 검증해야 할 때 정규 표현식과 비교한다.
		
	11.10.1 정규 표현식 작성 방법
		- 정규 표현식을 작성하는 방법은 API 도큐먼트에서 java.util.regex.Pattern 클래스를 찾아
		  Summary of regular-expression constructs를 참조하면 된다.
		- 간단히 말해서 정규 표현식은 문자 또는 숫자 기호와 반복 기호가 결합된 문자열이다.
		----------------------------------------------------------
			기호		설명
			[]		한 개의 문자		[abc]		a, b, c 중 하나의 문자
									[^abc]		a, b, c 이외의 하나의 문자
									[a-zA-z]	a~z, A~Z 중 하나의 문자
			\d		한 개의 숫자, [0-9]와 동일
			\s		공백
			\w		한 개의 알파벳 또는 한 개의 숫자, [a-zA-Z_0-9]와 동일
			?		없음 또는 한 개
			*		없음 또는 한 개 이상
			+		한 개 이상
			{n}		정확히 n개
			{n,}	최소한 n개
			{n, m}	n개에서부터 m개까지
			()		그룹핑
		----------------------------------------------------------
		- (02|010)-\d{3,4}-\d{4} 는 전화번호를 위한 정규 표현식이다.
			(02|010) : 02 또는 010
			- 		 : - 포함
			\d{3,4}  : 3자리 또는 4자리 숫자
			-		 : - 포함
			\d{4}	 : 4자리 숫자
		- \w+@\w+\.\w+(\.\w+)?
			\w+		 : 한 개 이상의 알파벳 또는 숫자
			@		 : @
			\w+		 : 한 개 이상의 알파벳 또는 숫자
			\.		 : .
			\w+		 : 한 개 이상의 알파벳 또는 숫자
			(\.\w+)? : \.\w+이 없거나 한 번 더 올 수 있음
		----------------------------------------------------------
		- \. 은 문자로서의 (.)을 의미하고 . 은 모든 문자 중에서 한 개의 문자를 똣한다.
		
	11.10.2 Pattern Class
		- 문자열을 정규 표현식으로 검증하는 기능은 java.util.regex.Pattern 클래스의
		  정적 메소드인 matches() 메소드가 제공한다.    
			ex) boolean result = Pattern.matches("정규식", "검증할 문자열);
		참고) regularExpressionAndPatternClass.Example.java
	
	
	11.11 Array Class
		- Array 클래스는 배열 조작 기능을 가지고 있다.
		- 배열 조작이란 배열의 복사, 항목 정렬, 항목 검색과 같은 기능을 말한다.
		- Array 클래스의 모든 메소드는 정적(static)이므로 Arrays 클래스로 바로 사용이 가능하다.
		----------------------------------------------------------
			리턴 타입		메소드 이름						설명
			int			binarySearch(배열, 찾는 값)		전체 배열 항목에서 찾는 값이 있는 인덱스 리턴
			타겟 배열		copyOf(원본배열, 복사할 길이)		원본 배열의 0번 인텍스에서 복사할 길이 만큼
														복사한 배열 리턴, 복사할 길이는 원존 배열의 길이보다
														커도 되며, 타겟 배열의 길이가 된다.
			타겟 배열		copyOfRanger(원본배열,			원본 배열의 시작인덱스에서 끝 인덱스까지 복사한
						시작인덱스, 끝 인덱스)				배열 리턴
			boolean		deepEquals(배열, 배열)			두 배열의 깊은 비교(중첩 배열의 항목까지 비교)
			boolean		equals(배열, 배열)				두 배열의 얕은 비교(중첩 배열의 항목은 비교하지 않음)
			void		fill(배열, 값)					전체 배열 항목에 동일한 값을 저장
			void		fill(배열, 시작인덱스, 끝인덱스, 값)	시작 인덱스부터 끝 인덱스 까지의 항목에만 동일한 값을 저장
			void		sort(배열)						배열의 전체 항목을 오름차순으로 정렬
			String		toString(배열)					"[값1, 값2, ... ]"와 같은 문자열을 리턴한다.
		----------------------------------------------------------
		
		11.11.1 copyOf(), copyOfRange()
			- 배열 복사를 위해 사용하는 메소드이다.
			- copyOf() 메소드는 원본 배열의 0번 인덱스에서 복사할 길이 만큼 복사한 타겟 배열을 리턴한다.
			  복사할 길이는 원본 배열의 길이보다 커도 되며, 타겟 배열의 길이가 된다.
			----------------------------------------------------------
				char[] arr1 = {'J', 'A', 'V', 'A'};
				char[] arr2 = Arrays.copyOf(arr1, arr1.length);
			----------------------------------------------------------
			- copyOfRange(원본배열, 시작인덱스, 끝인덱스)는 원본 배열의 시작 인덱스에서 끝 인덱스까지
			  복사한 배열을 리턴한다. 시작 인덱스는 포합되지만, 끝 인덱스는 포함되지 않는다.
			----------------------------------------------------------
				char[] arr1 = {'J', 'A', 'V', 'A'};
				char[] arr2 = Arrays,copyOfTange(arr1, 1, 3);
			----------------------------------------------------------
			- 단순히 배열을 복사할 목적이라면 Arrays 클래스를 사용하지 않고 System.arraycopy() 메소드를
			  이용할 수 있다.
				ex) System.arraycopy(원본배열, 원본시작인덱스, 타겟배열, 타겟시작인덱스, 복사개수)
			- 원본시작인덱스는 원본 배열에서 복사할 항목의 시작위치이다.
			- 타겟시작인덱스는 타겟 배열에서의 복사 시작 위치를 말한다.
			참고) arrayClass.ArrayCopyExample.java
			
	11.11.2 equals(), deepEquals() - array
		- Arrays의 equals()와 deepEquals()는 배열 항목을 비교한다. 
		- equals()는 1차 항목의 값만 비교하고, deepEquals()는 1차 항목이 서로 다를 배열을 참조할 경우
		  중첩된 배열의 항목까지 비교한다.
		참고) arrayClass.EqualsExample.java	
		
	11.11.3 sort()
		- 기본 타입 또는 String  배열은 Arrays.sort() 메소드의 매개값으로 지정해주면 자동으로 오름차순 정렬이 된다.
		- 사용자 정의 클래스 타입을 경우에는 클래스가 Comparable 인터페이스를 구현하고 있어야 정렬이 된다.
		참고) arrayClass.SortMember.java
			 arrayClass.SortExample.java
			 
	11.11.4 binarySearch()
		- 배열 항목에서 특정 값이 위치한 인덱스를 얻는 것을 배열 검색이라고 한다.
		- 배열 항목을 검색하려면 먼저 Arrays.sort() 메소드로 항목들을 오름차순으로 정렬한 후,
		  Arrays.binarySearch() 메소드로 항목을 찾아야 한다.
		참고) arrayClass.SearchExample.java  
		
		
	11.12 Wrapper Class
		- 자바는 기본 타입(byte, char, short, int, long, float, double, boolean)의 값을 갖는 객체를
		  생성할 수 있다. 이런 객체를 포장(Wrapper) 객체라고 한다. 기본 타입의 값을 내부에 두고 포장하는 객체이다.
		- 포장하고 있는 기본 타입 값은 외부에서 변경할 수 없다.
		- 내부의 값을 변경하고 싶다면 새로운 포장 객체를 만들어야 한다.
		- Wrapper Class는 java.lang 패키지에 포함되어있으며, char 타입과 int 타입이 각각
		  Character와 Integer 클래스로 대응된다. 또한, 각 기본 타입의 첫 문자를 대문자로 바꾼 이름을 가지고 있다.
		----------------------------------------------------------
			기본 타입				포장 클래스
			byte				Byte
			char				Charater
			short				Short
			int					Integer
			long				Long
			float				Float
			double				Double
			boolean				Boolean
		----------------------------------------------------------
		
	11.12.1 Boxing and Unboxing
		* 박싱 : 기본 타입의 값을 포장 객체로 만드는 과정
		* 언박싱 : 포장 객체에서 기본 타입의 값을 얻어내는 과정
		----------------------------------------------------------
			기본 타입의 값을 줄 경우						문자열을 줄 경우
			Byte obj = new Byte(10);				Byte obj = new Byte("10");
			Character obj = new Character("가");  	없음
			Short obj = new Short(100);				Short obj = new Short("100");
			Integer obj = new Integer(1000);		Integer obj = new Integer("1000");
			Long obj = new Long(10000);				Long obj = new Long("10000");
			Float obj = new Float(2.5F);			Float obj = new Float("2.5F");
			Double obj = new Double(3.5);			Double obj = new Double("3.5);
			Boolean obj = new Boolean(true);		Boolean obj = new Boolean("true");
		----------------------------------------------------------
		- 생성자를 이용하지 않아도 각 포장 클래스마다 가지고 있는 정적 valueOf() 메소드를 사용할 수도 있다.
		----------------------------------------------------------
			Integer obj = Integer.valueOf(1000);
			Integer obj = Integer.valueOf("1000");
		----------------------------------------------------------
		- 기본 타입의 값을 얻어내기 위해서는 "기본타입명+Value()" 메소드를 호출한다.
		----------------------------------------------------------
			기본타입의 값을 이용
			byte num = obj.byteValue();
			char ch = obj.charValue();
			short num = obj.shortValue();
			int num = obj.intValue();
			long num = obj.longValue();
			float num = obj.floatValue();
			double num = obj.doubleValue();
			boolean bool = obj.booleanValue();
		----------------------------------------------------------
		참고) wrapperClass.BoxingUnboxingExample.java
		
	11.12.2 auto boxing and auto unboxing
		- 기본 타입 값을 직접 박싱, 언박싱하지 않아도 자동적으로 박싱과 언박싱이 일어나는 경우가 있다.
		- 자동 박싱은 포장 클래스 타입에 기본값이 대입될 경우에 발생한다.
			ex) Integer obj = 100;		// 자동 박싱
		- 자동 언박싱은 기본 타입에 포장 객체가 대입될 경우에 발생한다.
		----------------------------------------------------------
			Integer obj = new Integer(200);
			int value1 = obj;			// 자동 언박싱
			int value2 = obj + 100;		// 자동 언박싱
		----------------------------------------------------------
		- 컬렉션 객체에 int 값을 저장하면 자동 박싱이 일어나 Integer 객체가 저장된다.
		----------------------------------------------------------
			List<Integer> list = new ArrayList<Integer>();
			list.add(200);		// 자동 언박싱
		----------------------------------------------------------
		- 자동 박싱과 언박싱은 자바 5부터 추가된 기능이다.
		- 자동 박싱과 언박싱은 코들르 간결하게 만들어주는 역할을 한다.
		참고) wrapperClass.AutoBoxingUnboxingExample.java
		
	11.12.3 문자열을 기본 타입 값으로 변환
		- 포장 클래스의 주요 용도는 가본 타입의 값을 박싱해서 포장 객체로 만드는 것이지만,
		  문자열을 기본 타입 값으로 변환할 때에도 많이 사용된다.
		- 대부분의 포장 클래스에는 "parse + 기본타입" 명으로 되어있는 정적(static) 메소드가 있다.
		  이 메소드는 문자열을 매개값으로 받아 기본 타입 값으로 변환한다.
		----------------------------------------------------------
			기본 타입의 값을 이용
			byte	num	= Byte.parseByte("10");
			short	num = Short.parseShort("100");
			int		num = Integer.parseInt("1000");
			long	num = Long.parseLong("10000");
			float	num = Float.parseFloat("2.5F");
			double	num = Double.parseDouble("3.5");
			boolean bool = Boolean.psrseBoolean("true");
		----------------------------------------------------------
		참고) wrapperClass.StringToPrimitiveValueExample.java
		
	11.12.4 to compare wrapping value
		- 포장 객체는 내부의 값을 비교하기위해 ==와 !=연산자를 사용할 수 없다.
		- ==와 !=연산자는 내부의 값을 비교하는 것이 아니라 포장 객체의 참조를 비교하기 때문이다.
		----------------------------------------------------------
			Integer obj1 = 300;
			Integer obj2 = 300;
			System.out.println(obj1 == obj2);	// false
		----------------------------------------------------------
		- 내부의 값만 비교하려면 언박싱한 값을 얻어 비교해야 한다.
		- 박싱된 값이 boolean 타입의 true, false / char 타입의 \u0000 ~ \u007f /
		  byte, short, int 타입의 -128 ~ 127 의 값이라면 ==와 !=연산자로 내부의 값을 바고 비교할 수 있다.
		  그 이외의 경우에는 ==와 !=연산자로 비교할 수 없다.
		- 포장 객체에 정확히 어떤 값이 저장될지 모르는 상황이라면 ==와 !=연산자는 사용하지 않는 것이 좋다.
		- 직접 내부 값을 언박싱해서 비교하거나, equals() 메소드로 내부 값을 비교하는 것이 좋다.
		  ( Wrapper 클래스의 equals() 메소드는 내부의 값을 비교하도록 오버라이딩 되어있다. )
		참고) wrapperClass.ValueCompareExample.java
		
	
	11.13 Math, Random Class
	11.13.1 Math Class
		- java.lang.Math 클래스는 수학 계산에 사용할 수 있는 메소드를 제공하고 있다.
		- Math 클래스가 제공하는 메소드는 모두 정적(static)이므로 Math 클래스로 바로 사용이 가능하다.
		----------------------------------------------------------
			메소드					 		설명			예제코드								리턴값
			int abs(int a)					절대값		int v1 = Math.abs(-5);				v1 = 5
			double abs(double a) 						double v2 = Math.abs(-3.14);		v2 = 3.14
			double ceil(double a)			올림값		double v3 = Math.ceil(5.3);			v3 = 6.0
														double v4 = Math.ceil(-5.3);		v4 = -6.0
			double floor(double a)			버림값		double v5 = Math.floor(5.3);		v5 = 5.0
														double v6 = Math.floor(-5.3);		v6 = -6.0
			int max(int a, int b)			최대값		int v7 = Math.max(5, 9);			v7 = 9
			double max(double a, double b)				double v8 = Math.max(5.3, 2.5);		v8 = 5.3
			int min(int a, int b)			최소값		int v9 = Math.min(5, 9);			v9 = 5
			double min(double a, double b)				double v10 = Math.min(5.3, 2.5);	v10 = 2.5
			double random()					랜덤값		double v11 = Math.random();			0.0 <= v11 < 1.0
			double rint(double a)			가까운 정수의	double v12 = Math.rint(5.3);		v12 = 5.0
											실수값		double v13 = Math.rint(5.7);		v13 = 6.0
			long round(double a)			반올림값		long v14 = Math.round(5.3);			v14 = 5
														long v15 = Math.round(5.7);			v15 = 6
		----------------------------------------------------------
		참고) mathRamdomClass.MathExample.java	
		
		- 0.0과 1.0 사이의 범위에 속하는 하나의 double 타입의 값을 리턴한다. 
		  0.0은 범위에 포함되고 1.0은 포함되지 않는다.
		- Math.random()을 활용해서 x ~ y 까지의 정수 난수를 얻는 방법
			(1) y - x = z, 각 변에 z를 곱하면 0.0 * z <= Math.random() * z < 1.0 * z
				-> 0.0 <= Math.random() * z < z.0 에 해당하는 하나의 double 타입의 값을 얻을 수 있다.
			(2) 각 변을 int 타입으로 강제타입 변환하면 (int)(0.0 * z) <= (int)(Math.random() * z )< (int)(1.0 * z)
				-> 0 <= (int)(Math.random() * z) < z 에 해당하는 하나의 int 타입의 값을 얻을 수 있다.
			(3) 각 변에 x를 더하면 (int)(0.0 * z) + x <= (int)(Math.random() * z) + x < (int)(1.0 * z) + x
				-> x <= (int)(Math.random() * z) + x <= y 에 해당하는 하나의 정수를 얻게 된다.
			(4) x ~ y 사이의 정수 난수를 얻는 연산식
				int num = (int)(Math.random() * z) + x;
			
			주사위 번호 뽑기 예제 ) int num = (int)(Math.random() * 6) + 1;
			로또 번호 뽑기 예제 ) int num = (int)(Math.random() * 45) + 1;
		참고) mathRandomClass.MathRandomExample.java
		
	11.13.2 Random Class
		- java.util.Random 클래스는 난수를 얻어내기 위해 다양한 메소드를 제공한다.
		- Math.random() 메소드는 0.0에서 1 사이의 double 난수를 얻는 데만 사용한다면,
		  Random 클래스는 boolean, int, long, float, double 난수를 얻을 수 있다.
		- Random 클래스는 종자값(seed)을 설정할 수 있다.
		- 종자값은 난수를 만드는 알고리즘에 사용되는 값으로 종자값이 같으면 같은 난수를 얻는다.
		----------------------------------------------------------
			생성자				설명
			Random()			호출 시마다 다른 종자값(현재시간 이용)이 자동 실행된다.
			Random(long seed)	매개값으로 주어진 종자값이 설정된다
		----------------------------------------------------------
		- Random 클래스가 제공하는 메소드
		----------------------------------------------------------
			리턴값		메소드(매개 변수)	설명
			boolean		nextBoolean()	boolean 타입의 난수를 리턴한다.
			double		nextDouble()	double 타입의 난수를 리턴(0.0 <= ~ < 1.0)
			int			nextInt()		int 타입의 난수를 리턴(-2^31 <= ~ < 2^31 - 1);
			int			nextInt(int n)	int 타입의 난수를 리턴(0 <= ~ < n)
		----------------------------------------------------------
		참고) mathRandomClass.RandomExample.java
		
	
	11.14 Date, Calendar Class
		- 자바는 시스템의 날짜 및 시각을 읽을 수 있도록 Date와 Calendar 클래스를 제공하고 있다.
		  이 두 클래스는 모두 java.util 패키지에 포함되어있다.
	
	11.14.1 Date Class
		- Date는 날짜를 표현하는 클래스이다. 객체 간에 날짜 정보를 주고 받을 때 주로 사용된다.
		- 여러 개의 생성자가 선언되어 있지만 대부분 Deprecated(비권장)되어 현재는 Date() 생성자만 주로 사용한다.
		- Date() 생성자는 컴퓨터의 현재 날짜를 읽어 Date 객체로 만든다.
			ex) Date now = new Date();
		- toString() 메소드를 사용하면 현재 날짜를 문자열로 얻을 수 있다. 이는 영문으로 된 날짜를 리턴하는데
		  만약 특정 문자열 포맷으로 얻고 싶다면 java.text.SimpleDateFormat 클래스를 이용하면 된다.
		참고) dateCalendarClass.DateExample.java
		
	11.14.2 Calendar Class
		- Calendar 클래스는 달력을 표현한 클래스이다.
		- 추상(abstract) 클래스 이므로 new 연산자를 사용해서 인스턴스를 생성할 수 없다.
		- 날짜와 시간을 계산하는 방법이 지역과 문화, 나라에 따라 다르기 때문이다.
		- 날짜와 시간을 계산한는데 꼭 필요한 메소드들만 선언되어 있고, 특정한 역법을 따르는 계산 로직은 하위 클래스에서
		  구현하도록 되어있다.
		- 특별한 역법을 사용하는 경우가 아니라면 직접 하위 클래스를 만들 필요는 없고 Calendar 클래스의
		  정적 메소드인 getInstance() 메소드를 이용하면 현재 운영체제에 설정되어 잇는 시간대를 기준으로한
		  Calendar 하위 객체를 얻을 수 있다.
			ex) Calendar now = Calendar.getInstance();
		- Calendar 객체를 얻었다면 get() 메소드를 이용해서 날짜와 시간에 대한 정보를 읽을 수 있다.
		----------------------------------------------------------
			int year = now.get(Calendar.YEAR);			// 년도를 리턴
			int month = now.get(Calendar.MONTH) + 1;	// 월을 리턴
			int day = now.get(Calendar.DAY_OF_MONTH);	// 일을 리턴
			int week = now.get(Calendar.DAY_OF_WEEK);	// 요일을 리턴
			int amPm = now.get(Calendar.AM_PM);			// 오전/오후를 리턴
			int hour = now.get(Calendar.HOUR);			// 시를 리턴
			int minute = now.get(Calendar.MINUTE);		// 분을 리턴
			int second	= now.get(Calendar.SECOND);		// 초를 리턴
		----------------------------------------------------------
		- get() 메소드를 호출할 때 사용한 매개값은 모두 Calendar 클래스에 선언되어 있는 상수들이다.
		참고) dateCalendarClass.CalendarExample.java
		
		- Calendar 클래스의 오버로딩된 다른 getInstance() 메소드를 이용하면 간단하게 다른 시간대의 Calendar를 얻을 수 있다.
		- 알고 싶은 시간대의 java.util.TimeZone 객체를 얻어 Calendar.getInstance() 메소드의 매개값으로 넘겨주면 된다.
			ex) TimeZone timeZone = TimeZone.getTimeZont("Ameriac/Los_Angeles");
				Calendar now = Claendar.getInstance( timeZone );
		- Timezone.getTimeZone() 메소드의 매개값은 Timezone 클래스의 정적 메소드인 getAvailableIDs()를 호출하여 얻은
		  시간대 문자열 중 하나를 사용하면 된다. getAvailableIDs() 메소드의 리턴 타입은 String 배열이다.
		참고) dateCalendarClass.PrintTimeZoneID.java
		
		
	11.15 Format Class
		- 데이터를 가공하여 원하는 문자열을 출력하기 위해서 자바는 형식 클래스를 제공한다.
		- 형식 클래스는 java.text 패키지에 포함되어 있으며, 숫자 형식을 위해 DecimalFormat,
		  날짜 형식을 위해 SimpleDateFormat, 매개 변수화된 문자열 헝식을 위해 MessageFormat등을 제공한다.
	
	11.15.1 DecimalFormat
		- DecimalFormat은 숫자 데이터를 원하는 형식으로 표현하기 위해서 패턴을 사용한다.
		----------------------------------------------------------
			기호		의미							패턴 예				1234567.89->변환 결과
			0		10진수(빈자리는 0으로 채움)		0					1234568
												0.0					1234567.9
												0000000000.00000	0001234567.89000
			#		10진수(빈자리는 채우지 않음)		#					1234568
												#.#					1234567.9
												########.#####		1234567.89
			.		소수점						#.0					1234567.9
			-		음수 기호						+#.0				+1234567.9
												-#.0				-1234567.9
			,		단위 구분						#.###.0				1,234,567.9
			E		지수 문자						0.0E0				1.2E6
			;		양수와 음수의 패턴을 모두			+#,###;-#,###		+1,234,568(양수일 때)
					기술할 경우, 패턴 구분자								-1,234,568(음수일 때)
			%		100을 곱한 후에 %문자 붙임		#.#%				123456789%
			\u00A4	통화 기호						\u00A4 #,###		$ 1,234,568
		----------------------------------------------------------
		- 적용할 패턴을 선택했다면 DecimalFormat 생성자 매개값으로 지정해서 객체를 생성하면 된다.
		- format() 메소드를 호출해서 패턴이 적용된 문자열을 얻으면 된다.
			ex) DecimalFormat df = new DeciamlFormat("#,###.0");
				String result = df.format(1234567.89);
		참고) formatClass.DecimalFormatExample.java
		
	11.15.2 SimpleDateFormat
		- Date 클래스의 toString() 메소드는 영문으로된 날짜를 리턴하는데 만약 특정 문자열 포맷으로 얻고 싶다면
		  java.text.SimpleDateFormat 클래스를 이용하면 된다.
		- SimpleDateFormat 클래스는 날짜를 원하는 형식으로 표현하기 위해 패턴을 사용한다.
		----------------------------------------------------------
			패턴 문자		의미						패턴문자		의미
			y			년						H			시(0 ~ 23)
			M			월						h			시(1 ~ 12)
			d			일						K			시(0 ~ 11)
			D			월 구분이 없는 일(1 ~ 365)	k			시(1 ~ 24)
			E			요일						m			분
			a			오전/오후					s			초
			w			년의 몇 번째 주			S			밀리세컨드(1/1000초)
			W			월의 몇 번재 주
		----------------------------------------------------------
		- 패턴에는 자릿수에 맞게 기호를 반복해서 작성할 수 있다.
			ex) yyyy = 년도를 4자리로 표시
				MM = 달을 2자리로 표시
				dd = 일을 2자리로 표시
		- 적용할 패턴을 작성했다면 이 패턴을 SimpleDateFormat의 생성자 매개값으로 지정해서 객체를 생성하면 된다.
		  그리고나서 format() 메소드를 호출해서 패턴이 적용된 문자열을 얻으면 된다.
			ex) SimpleDateFormat sdf = new SimpleDateFormat("yyyy년 MM월 dd일");
				String strDate = sdf.format(new Date());
		참고) formatClass.SimpleDateFormatExample.java
		
	11.15.3 MessageFormat
		- MessageFormat 클래스를 사용하면 문자열에 데이터가 들어갈 자리를 표시해두고, 프로그램이 실행하면서
		  동적으로 데이터를 삽입해 문자열을 완성시킬 수 있다.
			ex) String message = "회원 ID : {0} \n회원 이름 : {1} \n회원 전화 : {2}";
				String result = MessageFormat.format(message, id, name, tel);
		- format() 메소드는 완성된 문자열을 리턴한다. 첫 번째 매개값은 변수화된 문자열을 지정하고,
		  두 번째 이후의 매개값은 인덱스 순서에 맞게 값을 나열하면 된다. 배열을 대입할 수 도 있다.
			ex) String text = "회원 ID : {0} \n회원 이름 : {1} \n회원 전화 : {2}";
				Object[] arguments = { id, name, tel };
				String result = MessageFormat.format(text, arguments);
		참고) formatClass.MessageFormatExample.java
		
	
	11.16 java.time package
		- 자바 7 이전 까지는 Date와 Calendar 클래스를 이용해서 날짜와 시간 정보를 얻을수 있었다.
		- 자바 8 이후 Date 클래스의 대부분의 메소드는 Deprecated되면서 Date의 용도는 단순히 특정 시점의
		  날짜 정보를 저장하는 역할만 한다.
		- Calendar 클래슨느 날짜와 시간 정보를 얻기에는 충분하지만, 날짜와 시간을 조작하거나 비교하는 기능이
		  불충분 하다.
		- java.time 패키지와 하위 패키지로 날짜와 시간을 나타내는 여러가지 API를 지원한다.
		----------------------------------------------------------
			패키지				설명
			java.time			날짜와 시간을 나타내는 핵심 API인 LocalDate, LocalTime, LocalDateTime,
								ZonedDateTime을 포함하고 있다. 이 클래스들을 ISO-8601에 정의된 달력 시스템에
								기초한다.
			java.time.chrono	ISO-8601에 정의된 달력 시스템 이외에 다른 달력 시스템이 필요할 때
								사용할 수 있는 API들이 포함되어 있다.
			java.time.formet	날짜와 시간을 파싱하고 포맷팅 하는 API들이 포함되어있다.
			java.time.temporal	날짜와 시간을 연산하기 위한 보조 API들이 포함되어 있다.
			java.time.zone		타임존을 지원하는 API들이 포함되어있다.
		----------------------------------------------------------
		
	11.16.1 날짜와 시간 객체 생성
		- java.time 패키지의 5개 클래스
		----------------------------------------------------------
			클래스명			설명
			LocalDate		로컬 날짜 클래스
			LocalTime		로컬 시간 클래스
			LocalDateTime	로컬 날짜 및 시간 클래스(LocalDate + LocalTime)
			ZonedDateTime	특정 타입존(TimeZone)의 날짜와 시간 클래스
			Instant			특정 시점의 Time-Stamp 클래스
		----------------------------------------------------------
		
		1) LocalDate
			- LocalDate는 로컬 날짜 클래스로 날짜 정보만을 저장할 수 있다.
			- now()는 컴퓨터의 현재 날짜 정보를 저장한 LocalDate 객체를 리턴한다.
			- of()는 매개값으로 주어진 날짜 정보를 저장한 LocalDate객체를 리턴한다.
				ex) LocalDate currDate = LocalDate.now();
					LocalDate targetDate = LocalDate.of(int year, int month, int dayOfMonth);
		
		2) LocalTime
			- LocalTime은 로컬 시간 클래스로 시간 정보만을 저장할 수 있다.
			- now()는 컴퓨터의 현재 시간 정보를 저장한 LocalTime 객체를 리턴한다.
			- of()는 매개값으로 주어진 시간 정보를 저장한 LocalTime 객체를 리턴한다.
				ex) LocalTime currTime = LocalTime.now();
					LocalTime targetTime = LocalTime.of(int hour, int minute, int second,
					int nanoOfSecond);
			
		3) LocalDateTime
			- LocalDateTime은 LocalDate와 LocalTime을 결합한 클래스라고 볼 수 있다.
			- 날짜와 시간 정보를 모두 저장할 수 있다.
			- now()는 컴퓨터의 현재 날짜와 시간 정보를 저장한 LocalDateTime객체를 리턴한다.
			- of()는 매개값으로 주어진 날자와 시간 정보를 저장한 LocalDateTime객체를 리턴한다.
				ex) LocalDateTime currDateTime = LocalDateTime.now();
					LocalDateTime targetTime = LocalDateTime.of(int year, int month, int dayOfMonth,
					int hour, int minute, int second, int nanofSecond);
		
		4) ZonedDateTime
			- ZonedDateTime은 ISO-8601 달력 시스템에서 정의하고 있는 타임존의 날자와 시간을 저장하는 클래스이다.
			- 저장 형태는 2014-04-21T07:50:23.017+09:00[Asia/Seoul]과 같이 맨 뒤에 타임존에 대한 정보
			  (+-존오프셋[존아이디])가 추가적으로 붙는다.
			- ZoneOffset은 협정세계시(UTC : Universal Time Coordinated)와 차이나는 시간(시차)을 말한다.
			- now() 메소드에 ZoneId를 매개값으로 주고 얻을 수 있다.
			- ZoneId는 of() 메소드로 얻을수 있다. of()의 매개값은 java.util.TimeZone의
			  getAvailableIDs() 메소드가 리턴하는 유효한 값 중 하나이다.
			  	ex) ZonedDateTime utcDatetime = ZonedDateTime.now(ZoneId.of("UTC"));
			  		ZonedDateTime londonDateTime = ZondeDateTime.now(ZoneId.of("Europe/London"
			  		ZonedDateTime seoulDateTime = ZonedDateTime.now(Zoneid.of("Asia/Seoul"));
			  		
		5) Instant
			- Instant 클래스는 특정 시점의 타임스탬프로 사용된다.
			- 주로 특정한 두 시점 간의 사간적 우선순위를 다진 때 사용한다.
			- 협정세계시(UTC)를 기준으로 한다.
				ex)	Instant instant1 = Instant.now();
					Instant instant2 = Instant.now();
					if(instant1.isBefore(instant2)) {
						System.out.println("instant1이 빠릅니다.");
					} else if(instant1.isAfter(instant2)) {
					    System.out.println("instant1이 늦습니다.");
					} else {
						System.out.println("동일한 시간입니다.");
					}
					System.out.println("차이(nanos) : " + instant1.until(instant2, chronoUnit.NANOS));
			참고) javaTimePackage.DateTimeCreateExample.java
			
	11.16.2 get information of date and time
		- LocalDate와 LocalTime은 프로그램에서 날짜와 시간 정보를 이용할 수 있도록 메소드를 제공하고 있다.
		----------------------------------------------------------
			클래스		리턴 타입		메소드(매개 변수)		설명
			LocalDate	int			getYear()			년
						Month		getMonth()			Month 열거값
						int			getMonthValue()		월
						int			getDayOfYear()		일년의 몇 번째 일
						int			getDayOfMonth()		월의 몇 번째 일
						DayOfWeek	getDayOfWeek()		요일
						boolean		isLeapYear()		윤년 여부
			LocalTime	int			getHour()			시간
						int			getMinute()			분
						int			getSecond()			초
						int			getNano()			나노초 리턴
		----------------------------------------------------------
		- LocalDateTime과 ZonedDateTime은 날짜와 시간 정보 모두를 갖고 있기 때문에 위의 메소드
		  대부분을 가지고 있다. 단, isLeapYear()는 LocalDate에만 있기 때문에 toLocalDate() 메소드로 
		  LocalDate로 변환한 후에 사용할 수 있다.
		- ZonedDateTime은 시간존에 대한 정보를 제공하는 메소드들을 추가적으로 가지고 있다.
		----------------------------------------------------------
			클래스			리턴타입		메소드(매개 변수)	설명
			ZonedDateTime	ZoneId		getzone()		존아이디를 리턴(예 : Asia/Seoul)
							ZoneOffset	getOffset()		존오프셋(시차)을 리턴
		----------------------------------------------------------
		참고) javaTimePackage.DateTimeInfoExample.java
		
	11.16.3 operation of date and time
		- 날짜와 시간 클래스들은 날짜와 시간을 조작하는 메소드와 상대 날짜를 리턴하는 메소드들을 가지고있다.
		
		1) minus and plus
			----------------------------------------------------------
				클래스			리턴타입			메소드(매개변수)		설명
				LocalDate		LocalDate		minusYears(long)	년 빼기
				LocalDateTime	LocalDateTime	minusMonth(long)	달 빼기
				ZonedDateTime	ZonedDateTime	minusWeeks(long)	일 빼기
												plusYears(long)		년 더하기
												plusMonths(long)	달 더하기			
												plusWeeks(long)		주 더하기
												plusDays(long)		일 더하기
				LocalTime		LocalTime		minusHours(long)	시간 빼기
				LocalDateTime	LocalDateTime	minusMinutes(long)	분 빼기
				ZonedDateTime	ZonedDateTime	minusSeconds(long)	초 빼기
												minusNanos(long)	나노초 빼기
												plusHours(long)		시간 더하기
												plusMinutes(long)	분 더하기
												plusSeconds(long)	초 더하기
												plusNanos(long)		나노초 더하기
			----------------------------------------------------------
			- 각 메소드들은 수정된 LocalDate, LocalTime, LocalDateTime, ZonedDateTime을 리턴하기 때문에
			  도트(.)연산자로 연결해서 순차적으로 호출할 수 있다.
			참고) javaTimePackage.DateTimeOperationExample.java
		
		2) change
			----------------------------------------------------------
				클래스			리턴 타입			메소드(매개 변수)					설명	
				LocalDate		LocalDate		withYear(int)					년 변경
				LocalDateTime	LocalDateTime	withMonth(int)					월 변경
				ZonedDateTime	ZonedDateTime	withDayOfMonth(int)				월의 일 변경
												withDayOfYear(int)				년의 일 변경
												with(TemporalAdjuster adjuster)	상대 변경
				LocalTime		LocalTime		withHour(int)					시간 변경
				LocalDateTime	LocalDateTime	withMinute(int)					분 변경
				ZonedDateTime	ZonedDateTime	withSecond(int)					초 변경
												whitNano(int)					나노초 변경
			----------------------------------------------------------
			- with() 메소드는 현재 날짜를 기준으로 해의 첫 번째 일 또는 마지막 일, 달의 첫번째 일 또는 마지막 일,
			  달의 첫번째 요일, 지난 요일 및 돌아오는 요일 등 상대적인 날짜를 리턴한다.
			----------------------------------------------------------
				리턴 타입				메소드(매개 변수)						설명
				TemporalAdjuster 	firstDayOfYear()					이번 해의 첫 번째 일
									lastDayOfYear()						이번 해의 마지막 일
									firstDayOfNestYear()				다음 해의 첫 번째 일
									firstDayOfMonth()					이번 달의 첫 번째 일
									lastDayOfMonth()					이번 달의 마지막 일
									firstDayOfNextMonth()				다음 달의 첫 번째 일
									firstInMonth(DayOfWeek dayOfWeek)	이번 달의 첫 번째 요일
									lastInMonth(DayOfWeek dayOfWeek)	이번 달의 마지막 요일
									next(DayOfWeek dayOfWeek)			돌아오는 요일
									nextOrSame(DayOfWeek dayOfWeek)		돌아오는 요일(오늘 포함)
									previous(DayOfWeek dayOfWeek)		지난 요일
									previousOrSame(DayOfWeek dayOfWeek)	지난 요일(오늘 포함)
			----------------------------------------------------------
			참고) javaTimePackage.DateTimeChangeExample.java
			
	11.16.4 to compare date and time
		----------------------------------------------------------
			클래스				리턴 타입		메소드(매개 변수)							설명
			LocalDate			boolean		isAfter(ChronoLocalDate other)			이후 날짜인지 비교
			LocalDateTime					isBefore(ChronoLocalDate other)			이전 날짜인지 비교
											isEqual(ChronoLocalDate other)			동일 날짜인지 비교
			LocalTime			boolean		isAfter(LocalTime other)				이후 시잔인지 비교
											isBefore(LocalTime other)				이전 시간인지 비교
			LocalDate			Period		util(ChronoLocalDate endDateExclusive)	날짜 차이
			LocalDate			long		util(									시간 차이
			LocalTime						 	Temporal endExclusive,
			LocalDateTime						TemporalUnit unit
											)
			Period				Period		between(								날짜 차이
												LocalDate startDateInclusive,
												LocalDate endDateExclusive
											)
			Duration			Duration	between(								시간 차이
												Temporal startInclusive,
												Temporal endExclusive
											)
			ChronoUnit.YEARS	long		between(								전체 년 차이
			ChronoUnit.MONTHS					Temporal temporal1Inclusive,		전체 달 차이
			ChronoUnit.WEEKS					Temporal temporal2Exclusive			전체 주 차이
			ChronoUnit.DAYS					)										전체 일 차이
			ChronoUnit.HOURS														전체 시간 차이
			ChronoUnit.SECONDS														전체 초 차이
			ChronoUnit.MILLIS														전체 밀리초 차이
			ChronoUnit.NANOS														전체 나노초 차이
		----------------------------------------------------------
		- Period와 Duration은 날짜와 시간의 양을 나타내는 클래스들이다.
		- Period는 년, 달, 일의 양을 나타내는 클래스이다.
		- Duration은 시, 분, 초, 나노초의 양을 나타내는 클래스이다.
		- D-day나 D-time을 구할 대 사용될 수 있다.
		----------------------------------------------------------
			클래스		리턴타입	메소드(매개 변수)	설명
			Period		int		getYears()		년의 차이
						int		getMonth()		달의 차이
						int		getDays()		일의 차이
			Duration	int		getSeconds()	초의 차이
						int		getNano()		나노초의 차이
		----------------------------------------------------------
		- between() 메소드는 Period와 Duration 클래스, ChronoUnit 열거 타입에도 있다.
		- Period와 Duration의 between()은 년, 달, 일, 초의 단순 차이를 리턴한다.
		- ChronoUnit 열거 타입의 between()은 전체 시간을 기준으로 차이를 리턴한다.
		참고) javaTimePackage.DateTimeCompareExample.java
		
	11.16.5 parsing and formatting
		- 날짜와 시간 클래스는 문자열을 파싱(parsing)해서 날짜와 시간을 생성하는 메소드와
		  이와 반대로 날짜와 시간을 포맷팅(Formmattion)된 문자열로 변환하는 메소드를 제공하고 있다.
		
		1) Parsing Method
		----------------------------------------------------------
			클래스			리턴 타입			메소드
			LocalDate		LocalDate		parse(CharSequence)
			LocalTime		LocalTime		parse(CharSequence, DateTimeFormatter)
			LocalDateTime	LocalDateTime
			ZonedDateTime	ZondeDateTime
		----------------------------------------------------------
		- LocalDate의 parse(CharSequence) 메소드는 기본적으로 ISO_LOCAL_DATE 포맷터를 사용해서
		  문자열을 파싱한다. ISO_LOCAL_DATE는 DateTimeFormatter의 상수로 정의되어있는데,
		  "2024-05-04" 형식의 포맷터이다.
			ex) LocalDate localDate = LocalDate.parse("2024-05-21");
		- 만약 다른 포맷터를 이용해서 문자열을 파싱하고 싶다면 parse(CharSequence, DateTimeFormatter)메소드를
		  이용할 수 있다.
		- DateTimeFormatter는 ofPattern() 메소드로 정의할 수 있다.
			ex) DateTimeFormatter formatter = DateTimeFofPattern("yyyy.MM.dd");
				LocalDate localDate = LocalDate.parse("2024.05.21", formatter);
		- ofPattern() 메소드의 매개값으로 사용되는 패턴 기호에 대한 설명은 API 도큐먼트의
		  java.time.format.DateTimeFormatter 클래스 설명 부분에서 참조할 수 있다.
		----------------------------------------------------------
			상수						설명								예
			BASIC_ISO_DATE 			Basic ISO date					"20111203"
			ISO_LOCAL_DATE			ISO Local Date					"2011-12-03"
			ISO_OFFSET_DATE			ISO Date with offset			"2011-12-03+01:00"
			ISO_DATE				ISO Date with or without offset	"2011-12-03+01:00"; "2011-12-03"
			ISO_LOCAL_TIME			Time without offset				"10:15:30"
			ISO_OFFSET_TIME			Time with offset				"10:15:30+01:00"
			ISO_TIME				Time with or without offset		"10:15:30+01:00"; "10:15:30"
			ISO_LOCAL_DATE_TIME		ISO Local Date and Time			"2011-12-03T10:15:30"
			ISO_OFFSET_DATE_TIME	Date Time with Offset			"2011-12-03T10:15:30+01:00"
			ISO_ZONED_DATE_TIME		Zoned Date Time					"2011-12-03T10:15:30+01:00
																	 [Europe/Paris]"
			ISO_DATE_TIME			Date and time with ZoneId		"2011-12-03T10:15:30+01:00
																	 [Europe/Paris]"
			ISO_ORDINAL_DATE		Year and day of year			"2012-337"
			ISO_WEEK_DATE			Year and Week					"2012-W48-6"
			ISO_INSTANT				Date and Time of an Instant		"2011-12-03T10:15:30Z"
			RFC_1123_DATE_TIME		RFC 1123 / RFC 822				"Tue, 3 Jun 2008 11:05:30 GMT"
		----------------------------------------------------------
		참고) javaTimePackage.DateTimeParsingExample.java
		
		2) Formatting Method
		----------------------------------------------------------
			클래스			리턴타입			메소드(매개 변수)
			LocalDate		String			format(DateTimeFormatter formatter)
			LocalTime
			LocalDateTime
			ZonedDateTime
		----------------------------------------------------------
		- format()의 매개값은 DateTimeFormatter인데 해당 형식대로 문자열을 리턴한다.
			ex) LocalDateTime now = LoclaDateTime.now();
				DateTimeFormatter dateTimeFormatter =
					DateTimeFormatter.ofPattern("yyyy년 M월 d일 a h시 m분");
				String nowString = now.format(dateTimeFormatter);
		참고) javaTimePackage.DateTimeFormatExample.java