	chapter003 operator
	
	-- Table of contents --
		3.1 연산자와 연산식
		3.2 연산의 방향과 우선순위
		3.3 단항 연산자
		3.4	이항 연산자
		3.5	삼항	연산자
	-----------------------
	
	3.1 연산자와 연산식
		* 연산(operations) : 프로그램에서 데이터를 처리하여 결과를 산출하는 것
		* 연산자(operator) : 연산에 사용되는 표시나 기호이다. 단항, 이항, 삼항 연산자로 구분한다.
		* 피연산자(operand) : 연산되는 데이터
		* 연산식(expression)
			: 연산자와 피연산자를 이용하여 연산의 과정을 기술한 것이다.
			: 반드시 하나의 값을 산출한다.
			: 다른 연산자의 피연산자 위치에도 쓸 수 있다.
		----------------------------------------------------------
		연산자 종류	연산자			피연산자 수	산출값		기능 설명
		산술			+, -, *, /, %	이항			숫자			사칙연산 및 나머지 계산
		부호			+, -			단항			숫자			음수와 양수의 부호
		문자열		+				이항			문자열		두 문자열을 연결
		대입			=, +=, -=, *=,	이항			다양			우변의 값을 좌변의 변수에 대입
					/=, %=, &=, ^=,
					|=, <<=, >>=,
					>>>=			
		증감			++, --			단항			숫자			1만큼 증가/감소
		비교			==, !=, >, <,	이항			boolean		값의 비교
					>=, <=,
					instance of
		논리			!, &, |, &&, ||	단항/이항		boolean		논리적 NOT, AND, OR 연산
		조건			(조건식) ? A : B	삼항			다양			조건식에 따라 A 또는 B중 하나를 선택
		비트			~, &, |, ^		단항/이항		숫자/boolean	비트	NOT, AND, OR, XOR 연산
		쉬프트		>>, <<, >>>		이항			숫자			비트를 좌측/우측으로 밀어서 이동
		----------------------------------------------------------
	
	3.2 연산의 방향과 우선순위
		- 프로그램에서는 연산자의 연산 방향과 연산자 간의 우선순위가 정해져 있다.
		- 우선순위가 같은 연산자의 경우 대부분 왼쪽에서부터 오른쪽으로 연산을 시작한다.
		- 단항연산자(++, --, ~, !), 부호연산자(+, -), 대입연산자(=, +=, -=, ...)는 오른쪽에서 왼쪽으로 연산한다.
		----------------------------------------------------------
		연산자									연산 방향				우선순위
		증감(++, --), 부호(+, -), 비트(~), 논리(!)	<---------			1
		산술(*, /, %)							--------->			2
		산술(+, -)								--------->			3
		쉬프트(<<, >>, >>>)						--------->			4
		비교(<, >, <=, >=, instance of)			--------->			5
		비교(==, !=)								--------->			6
		논리(&)									--------->			7
		논리(^)									--------->			8
		논리(|)									--------->			9
		논리(&&)									--------->			10	
		논리(||)									--------->			11
		조건(? :)								--------->			12
		대입(=, +=, -=, *=, /=, %=, &=, ^=, |=,	<---------			13
			<<=, >>=, >>>=
		----------------------------------------------------------	
		(1) 단항, 이항(대입연산자 제외), 삼항, 대입(이항) 연산자 순으로 우선순위를 가진다.
		(2) 산술, 쉬프트, 비교, 논리, (조건), 대입 연산자 순으로 우선순위를 가진다.
		(3) 단항과 대입 연산자를 제외한 모든 연산의 방향은 왼쪽에서 오른쪽이다.
		(4) 복잡한 연산식에는 괄호()를 사용해서 우선순위를 정해준다.
	
	3.3 단항연산자
		- 피연산자가 하나뿐인 연산자, 부호(+, -), 증감(++, --), 비트 반전(~), 논리 부정(!)
	
	3.3.1 부호 연산자(+, -)
		- 양수 밒 음수를 표시하는 +, -
		- boolean 타입과 char 타입을 제외한 나머지 기본 타입에 사용할 수 있다.
		----------------------------------------------------------
		연산식				설명
		+		피연산자		피연산자의 부호 유지
		- 		피연산자		피연산자의 부호 변경
		----------------------------------------------------------
		- 정수 및 실수 리터럴 앞에 붙여 양수 및 음수를 표현한다.
		----------------------------------------------------------
		int i1 = +100;
		int i2 = -100;
		double d1 = +3.14;
		double d2 = -10.5;
		----------------------------------------------------------
		- 정수 및 실수 타입 변수 앞에 붙일 수 있다. 변수 값의 부호를 유지하거나 바꾸기 위해 사용된다.
		----------------------------------------------------------
		int x = -100;
		int result1 = +x;	// -100
		int result2 = -x;	// 100
		----------------------------------------------------------
		- 부호 연산자의 산출 타입은 int 타입이 된다. ex) short 타입 값을 부호 연산하면 int 타입 값으로 바뀐다.
		----------------------------------------------------------
		short s = 100;
		short result = -s;	// compile error 발생
		
		short s = 100;
		int result = -s;	// ok!
		----------------------------------------------------------
	
	3.3.2 증감연산자(++, --)
		- 변수의 값을 1 증가(++)시키거나 1 감소(--)시키는 연산자를 말한다.
		- boolean 타입을 제외한 모든 기본 타입의 피연산자에 사용할 수 있다.
		----------------------------------------------------------
		연산식					설명
		++		피연산자			다른 연산을 수행하기 전에 피연산자의 값을 1 증가시킴
		--		피연산자			다른 연산을 수행하기 전에 피연산자의 값을 1 감소시킴
		피연산자	++				다른 연산을 수행한 후에 피연산자의 값을 1 증가시킴
		피연산자	--				다른 연산을 수행한 후에 피연산자의 값을 1 감소시킴
		----------------------------------------------------------
		----------------------------------------------------------
		int x = 1;
		int y = 1;
		int result1 = ++x + 10;		// 12
		int result2 = y++ + 10;		// 11
		----------------------------------------------------------
		- ++i와 i = i + 1은 실제로 컴파일하면 동일한 바이트 코드가 생성된다.(어떤것이 연산속도가 빠르다고 볼 수 없다.)
		----------------------------------------------------------
		소스코드		int i = 0;			int i = 0;
					++i;				i = i + 1;
		바이트코드		iconst_0			iconst_0
					istore_1[i]			istore_1[i]
					iinc 1 1 [i]		iinc 1 1 [i]
		---------------------------------------------------------
		
	3.3.3 논리 부정 연산자(!)
		- true를 false로	false를 true로 변경하기 때문에 boolean 타입에만 사용할 수 있다.
		----------------------------------------------------------
		연산식				설명
		!		피연산자		피연산자가 true이면 false 값을 산출, false이면 true 값을 산출한다
		----------------------------------------------------------
		- 조건문과 제어문에서 사용되어 조건식의 값을 부정하도록 해서 실행 흐름을 제어할 때 주로 사용된다.
		- 또한 두 가지 상태(true/false)를 번갈아가면 변경하는 토글(toggle) 기능을 구현할 때도 주로 사용한다.
		
	3.3.4 비트 반전 연산자(~)
		- 정수 타입 (byte, short, int, long)의 피연산자에만 사용
		- 피연산자를 2진수로 표현했을 때 비트값인 0을 1로, 1은 0으로 반전한다.(최상위 비트 포함)
		- 부호가 반대인 새로운 값이 산출된다.
		----------------------------------------------------------
		연산식						설명
		~	10(00 ... 0 1010)		산출결과 : -11(11 ... 1 0101)
		----------------------------------------------------------
		- 연산 후 int 타입으로 산출된다. (피연산자는 연산을 수행하기 전에 int 타입으로 변환되고, 비트반전이 일어난다.)
		----------------------------------------------------------
		byte v1 = 10;
		byte v2 = ~v1;	// 컴파일 에러
		
		byte v1 = 10;
		int v2 = ~v1;	// ok!
		----------------------------------------------------------
		- 비트 반전 연산자의 산출값에 1을 더하기하면 부호가 반대인 정수를 얻을 수 있다. ex) ~10 -> -11 -> -11 + 1 -> -10
		----------------------------------------------------------
		byte v1 = 10;
		int v2 = ~v1 + 1;	// -10
		----------------------------------------------------------
		- Integer.toVinaryString(정수값) : 정수값을 총 32비트의 이진 문자열로 리턴하는 메소드
		  (앞의 비트가 모두 0이면 0을 생략되고 나무지 문자열만 리턴한다)
		----------------------------------------------------------
		String v1BinaryString = Integer.toVinaryString(10);
		
		/**
			32개의 문자열을 모두 얻기위한 메소드.
			리턴하는 str의 문자 수를 조사해서 32보다 작으면 앞에 0을 붙이도록 한다.
		*/
		public static String toBinaryString(int value){
			String str = Integer.toBinaryString(value);
			while(str.length() < 32){
				str = "0" + str;
			}
			retrun str;
		}
		----------------------------------------------------------
		
		
	3.4 이항 연산자
		- 피연산자가 두 개인 연산자
		
	3.4.1 산술연산자(+, -, *, /, %)
		- boolean 타입을 제외한 모든 기본타입에 사용할 수 있다.
		----------------------------------------------------------
		연산식						설명
		피연산자	+	피연산자			덧셈 연산
		피연산자	- 	피연산자			뺄셈 연산
		피연산자	*	피연산자			곱셈 연산
		피연산자	/	피연산자			좌측 피연산자를 우측 피연산자로 나눗셈 연산
		피연산자	%	피연산자			좌측 피연산자를 우측 피연산자로 나눈 나머지를 구하는 연산
		----------------------------------------------------------
		- 피연산자들의 타입이 동일하지 않을 경우 다음의 규칙을 사용해서 타입을 일치시킨 후 연산을 수행한다.
			(1) 피연산자들이 모두 정수 타입이고, int 타입(4byte)보다 크기가 작은 타입일 경우
				모두 int 타입으로 변환 후, 연산을 수행한다. 따라서 연산의 산출 타입은 int이다.
				ex) byte + byte -> int + int = int
			(2) 피연산들이 모두 정수 타입이고, long 타입이 있을 경우 모두 long 타입으로 변환 후 연산을 수행한다.
				따라서 연산의 산출 타입은 long이다.
				ex) int + long -> long + long = long
			(3) 피연산자 중 실수 타입이 있을 경우, 크기가 큰 실수 타입으로 변환 후, 연산을 수행한다.
				따라서 연산의 산출 타입은 실수 타입이다.
				ex) int + double -> double + double = double
		----------------------------------------------------------
		byte byte1 = 1;
		byte byte2 = 1;
		byte byte3 = byte1 + byte2;		// compile error
		int result1 = byte1 + byte2;	// ok!
		
		int int1 = 10;
		int int2 = 4;
		int result2 = int1 / int2;		// 2.5(x)	2(o)
		double result3 = int1 / int2;	// 2.5(x)	2.0(o)
		
		double result3 = (int1*1.0) / int2;		// 2.5
		double result3 = (double) int1 / int2;	// 2.5
		double result3 = int1 / (double) int2;	// 2.5
		----------------------------------------------------------
		- char 타입도 산술 연산이 가능하다.(int 타입으로 산출된다)
		----------------------------------------------------------
		cahr c1 = 'A' + 1;
		char c2 = 'A';
		char c3 = c2 + 1	// compile error
		char c3 = (char)(c2 + 1);	// ok!
		----------------------------------------------------------
		
		1) 오버플로우 탐지
			- 산출 타입으로 표현할 수 없는 값이 산출되었을 경우, 오버플로우가 발생하고 쓰레기값을 얻을 수 있다.
			----------------------------------------------------------
			int x = 1000000;
			int y = 1000000;
			int z = x * y;		// -727379968 ( int에 저장될 수 있는 값의 범위를 초과하게 된 경우)
			
			long x = 1000000;
			long y = 1000000;
			long z = x * y;		// 1000000000000
			----------------------------------------------------------
			- 피연산자의 값을 사용자로부터 입력받거나 프로그램 실행 도중에 생성되는 경우 메소드를 이용한다.
			- 메소드를 이용하면 산술 연산 전 피연산자들의 값을 조사해서 오버플로우를 탐지할 수 있다.
			----------------------------------------------------------
			public static int safeAdd(int left, int right) {
				if(right > 0) {
					if(left > (Integer.MAX_VALUE - right)) {
						throw new ArithmeticException("오버플로우 발생");	// 예외 발생 코드
					}
				} else {	// right <= 0 일 경우
					if(left < (Integer.MIN_VALUE - right)) {
						throw new ArithmeticException("오버플로우 발생");	// 예외 발생 코드
					}
				}
				return left + right;
			}
			----------------------------------------------------------
		
		2) 정확한 계산은 정수 사용
			- 정확하게 계산해야 할 때는 부동소수점(실수) 타입을 사용하지 않는 것이 좋다.
			----------------------------------------------------------
			int apple = 1;
			double pieceUnit = 0.1;
			int number = 7;
			
			double result = apple - number * pieceUnit; // 0.3 (x)	0.29999999999999993(o)
			----------------------------------------------------------
			- 이진 포맷의 가수를 사용하는 부동소수점 타입은 0.1을 정확히 표현할 수 없어 근사치로 처리한다.
			- 정확한 계산이 필요하다면 정수 연산으로 변경해야한다.
			----------------------------------------------------------
			int apple = 1;
			
			int totalPieces = apple * 10;
			int number = 7;
			int temp = totalPiece - number;
			
			double result = temp / 10.0;	// 0.3
			----------------------------------------------------------
			
		3) NaN과 Infinity 연산
			- '/'와 '%' 연산자를 사용할 때 좌측 피연산자가 정수 타입인 경우 나누는 수인 우측 피연산자는 0을 사용할 수 없다.
			  (컴파일은 정상적으로 되지만, 실행시 ArithmeticException(예외)이 발생한다.)
			- 예외 발생으로 인한 프로그램 종료를 피하고 프로그램이 종료되지 않도록 하려면 예외처리를 해야한다.
			----------------------------------------------------------
			5 / 0 -> ArtihmeticException 예외 발생
			5 % 0 -> ArtihmeticException 예외 발생
			
			try {
				int z = x / y;(y가 0일 경우 ArtimeticException 발생)
				int z = x % y;(y가 0일 경우 ArtimeticException 발생)
				System.out.println("z : " + z);
			} catch {
				System.out.println("0으로 나누면 안됨");
			}
			----------------------------------------------------------
			- 실수 타입인 0.0 또는 0.0f로 나누면 ArithmeticException이 발생하지 않고,
			  '/'연산의 결과는 Infinity(무한대) 값을 가지며, % 연산의 결과는 NaN(Not a Number)을 가진다.
			- Infinity 또는 NaN과 산술 연한을 하면 어떤 수와 연산하더라도 Infinity와 NaN이 산출되에 데이터가 엉망이 될 수 있다.
			----------------------------------------------------------
			5 / 0.0 -> Infinity
			5 % 0.0 -> NaN
			
			Infinity + 2 -> Infinity
			NaN + 2 -> NaN
			----------------------------------------------------------
			- Double.isInfinite(double 타입의 값) : 매개값이 Infinity라면 true를 리턴하고 아니면 false를 리턴한다.
			- Double.isNaN(double 타입의 값) : 매개값이 NaN이라면 true를 리턴하고 아니면 false를 리턴한다.
			- 연산의 결과가 Infinity 또는 NaN이면 절대로 다음 연산을 수행하지 못하도록 if문을 사용해서 실행 흐름을 변경해야 한다.
			----------------------------------------------------------
			if(Double.isInfinite(z) || Double.isNaN(z)) {
				System.out.println("값 산출 불가");
			} else {
				System.out.println(z + 2);
			}
			----------------------------------------------------------
		
		4) 입력값의 NaN 검사
			- 부동소수점(실수)을 입력받을 때는 반드시 NaN 검사를 해야한다.
			----------------------------------------------------------
			String userInput = "NaN";	// 사용자로부터 입력받은 값
			double val = Double.valueOf(userInput);		// 입력값을 double 타입으로 변환
			
			double currentBalance = 10000.0;
			
			currentBalance += val;	// currentBalance에 NaN이 저장됨
			----------------------------------------------------------
			- NaN은 산술 연산이 가능하다.
			- NaN과 어떠한 수가 연산되면 결과는 NaN이 산출되어 데이터가 엉망이 된다.
			- 사용자로부터 문자열을 입력받을 때에는 반드시 "NaN"인지를 조사하고 만약 "NaN"이라면 NaN과 산술 연산을 수행해서는 안된다.
			----------------------------------------------------------
			String userInput = "NaN";
			double val = Double.valueIf(userInput);
			
			double currentBalance = 10000.0;
			
			if(Double.isNaN(val)) {		// NaN을 검사함
				System.out.println("NaN이 입력되어 처리할 수 없음");
				val = 0.0;
			}
			
			currentBalance += val;	// currentBalance의 원래 값이 유지
			----------------------------------------------------------
			- NaN인지 조사할 때 '==' 연산자를 사용할 수 없다.
			- NaN은 '!=' 연산자를 제외한 모든 비교 연산자를 사용할 경우 false 갓을 리턴한다. 반드시 Double.isNaN()을 사용해야 한다.	
	
	3.4.2 문자열 연결 연산자(+)
		- 문자열 연결 연산자인 +는 문자열을 서로 결합하는 연산자이다.
		- 피연산자 중 한쪽이 문자열이면 + 연산자는 문자열 연결 연산자로 사용되어 다른 피연산자를 문자열로 변환하고 서로 결합한다.
		----------------------------------------------------------
		String str1 = "JDK" + 6.0;	// "JDK6.0"
		String str2 = str1 + " 특징;	// "JDK6.0 특징"
		----------------------------------------------------------
		- 문자열과 숫자가 혼합된 + 연산식은 왼쪽에서부터 오른쪽으로 연산이 진행된다.
		----------------------------------------------------------
		"JDK" + 3 + 3.0;	-> "JDK3" + 3.0 -> "JDK33.0"
		3 + 3.0 + "JDK"		-> 6.0 + "JDK"	-> "6.0JDK"
		----------------------------------------------------------
				
	3.4.3 비교 연산자(<, <=, >, >=, ==, !=)
		- 비교 연산자는 대소 (<, <=, >, >=) 또는 동등(==, !=)을 비교해서 boolean 타입인 true/false를 산출한다.
		- 대소 연산자는 boolean 타입을 제외한 기본 타입에 사용할 수 있다.
		- 동등 연산자는 모든 타입에 사용될 수 있다.
		- 흐름 제어문인 조건문(if), 반복문(for, while)에서 주로 이용되어 실행 흐름을 제어할 때 사용된다.
		----------------------------------------------------------
		구분			연산식								설명
		동등비교		피연산자1		==		피연산자2			두 피연산자의 값이 같은지를 검사한다.
					피연산자1		!=		피연산자2			두 피연산자의 값이 다른지를 검사한다.
		크기비교		피연산자1		>		피연산자2			피연산자 1이 큰지를 검사한다.
					피연산자1		>=		피연산자2			피연산자 1이 크거나 같은지를 검사한다.
					피연산자1		<		피연산자2			피연산자 1이 작은지를 검사
					피연산자1		<=		피연산자2			피연산자1이 작거나 같은지를 검사함다.
		----------------------------------------------------------
		- 만약 피연산자가 char 타입이면 유니코드 값으로 비교 연산을 수행한다.
		----------------------------------------------------------
		('A' < 'B')	->	(65 < 66)
		----------------------------------------------------------
		- 비교 연산자에서도 연산을 수행하기 전에 타입 변환을 통해 피연산자의 타입을 일치시킨다.
		----------------------------------------------------------
		'A' == 65 -> 65(int) == 65 -> true
		3 == 3.0 -> 3.0(double) == 3.0 -> true
		----------------------------------------------------------
		- 0.1 == 0.1f의 경우 false값을 가지게 된다.
		  이유는 이진 포맷의 가수를 사용하는 모든 부동소수점 타입이 0.1정확히 표현할 수 없기 때문이다.
		  0.1f 가 0.1의 근사값으로 표현되어 0.10000000149011612와 같은 값이 되고 이는 0.1보다 큰 값이기 때문에 좌항과 우항이 동일하지 않다.
		- 피연산자를 모두 float 타입을 강제 타입 변환한 후에 비교연산을 하거나, 
		  정수로 변환해서 비교해야 한다.
		----------------------------------------------------------
		double v1 = 0.1;
		float v2 = 0.1f;
		System.out.println(v1 == v2);	// false
		System.out.println((float)v1 == v2);	// true
		System.out.println((int)(v1 * 10) == (int)(v5 * 10));	// true
		----------------------------------------------------------
		- String 타입의 문자열을 비교할 때엔느 대소 연산자를 사용할 수 없고, 동등 비교 연산자는 사용할 수 있으나
		  문자열이 같은지, 다른지를 비교한느 용도로는 사용되지 않는다.
		----------------------------------------------------------
		String strVar1 = "짱구";
		String strVar2 = "짱구";
		String strVar3 = new String("짱구");
		----------------------------------------------------------
		- 자바는 문자열 리터럴이 동일하다면 동일한 String 객체를 참조하도록 되어있다.
		- strVar1과 strVar2는 동일한 String 객체의 번지값을 가지고 있지만
		  strVar3은 객체 생성 연산자인 new로 생성한 새로운 String 객체의 번지값을 가지고 있다.
		- 이 경우 변수 strVar1과 strVar2의 == 연산은 true를 산출하고
		  strVar2와 strVar3dml == 연산은 false를 산출한다.
		- == 연산자는 변수에 저장된 값(객체의 번지값)만 비교하기 때문에 이러한 결과가 나온다.
		----------------------------------------------------------
		strVar1 == strVar2	-> true
		strVar2 == strVar3	-> false
		----------------------------------------------------------
		- equals() : String 객체의 문자열만을 비교하는 메소드
		----------------------------------------------------------
		boolean result = 원본문자열.equals(비교문자열);
		
		strVar1.equals(strVar2);	// true
		strVar2.equals(strVar3);	// true
		----------------------------------------------------------
		
		3.4.4 논리 연산자(&&, ||, &, |, ^, !)
			- 논리 연산자의 피연산자는 boolean타입만 사용할 수 있다.
		----------------------------------------------------------
		구분				연산식						결과			설명
		AND(논리곱)		true	&& or &		true	true		피연산자 모두가 true일 경우에만 연산결과는 true
						true				false	false
						false				true	false
						false				false	false
		OR(논리합)		true	|| or |		true	true		피연산자 중 하나만 true이면 연산결과는 true
						true				false	true	
						false				true	true	
						false				false	false
		XOR(배타적논리합)	true		^		true	false		피연산자가 하나는 true이고 다른 하나가 false일 경우에만
						true				false	true		연산결과는 true
						false				true	true
						false				false	false
		NOT(논리부정)					!		true	false		피연산자의 논리값을 바꿈
											false	true
		----------------------------------------------------------
		- && and & : 산출결과는 같지만 연산과정이 조금 다르다.
					&&는 앞의 피연산자가 false라면 뒤의 피연산자를 평가하지 않고 바로 false라는 산출 결과를 낸다.
					하나라도 false라면 전체 연산식은 false이기 때문이다.
					&는 두 피연산자를 모두 평가해서 산출 결과를 낸다.
					& 보다는 &&가 효율적으로 동작한다.
		- || and | : || 앞의 피연산자가 true라면 뒤의 피연산자를 평가하지 않고 바로 true라는 산출결과를 낸다.
					 |는 두 피연산자 모두를 평가해서 산출결과를 낸다.
					 ||가 더 효율적으로 동작한다.
	
	3.4.5 비트 연산자(&, |, ^, ~, <<, >>, >>>)
		- 데이터를 비트(bit)단위로 연산한다. 즉, 0과 1이 피연산자가 된다.
		- 0과 1로 표현이 가능한 정수 타입만 비트 연산을 할 수 있다. 
		1) 비트 논리 연산자(&, |, ^, ~)
			- 피연산자가 boolean 타입일 경우에는 일반 논리 연산자이고, 피연산자가 정수 타입일 경우에는 비트 논리 연산자로 사용된다.
			----------------------------------------------------------
			구분				연산식					결과			설명
			AND(논리곱)		1		&		1		1			두 비트 모두 1일 경우에만 연산 결과가 1
							1				0		0		
							0				1		0
							0				0		0
			OR(논리합)		1		|		1		1			두 비트 중 하나만 1이면 연산결과는 1
							1				0		1			
							0				1		1
							0				0		0
			XOR(배타적논리합)	1		^		1		0			두 비트 중 하나는 1이고 다른 하나가 0일 경우 연산 결과는 1
							1				0		1
							0				1		1
							0				0		0
			NOT(논리 부정)			~		1		0			보수
											0		1	
			----------------------------------------------------------
			ex) 45와 25의 비트 논리 연산
				45 -> 00101101			25 -> 00011001
				(1) 45 & 25	-> 00101101 & 00011001 -> 00001001 -> 9
				(2) 45 | 25	-> 00101101 | 00011001 -> 00111101 -> 61
				(3) 45 ^ 25 -> 00101101 ^ 00011001 -> 00110100 -> 52
				(4)    ~ 45 ->           ~ 00101101 -> 11010010
				    -> -(~11010010) -> - (00101101) -> - (00101101 + 0000 0001)
				    -> -(00101110) -> - 46
			----------------------------------------------------------
			- 비트 연산자는 피 연산자를 int 타입으로 자동 타입 변환한 후 연산을 수행한다.
		2) 비트 이동 연산자
			- 정수 데이터의 비트를 좌측 또는 우측으로 밀어서 이동시키는 연산을 수행한다.
			----------------------------------------------------------
			구분			연산식			설명
			이동(쉬프트)	a	<<	 b		정수 a의 각 비트를 b만큼 왼쪽으로 이동(빈자리는 0으로 채워진다.)	
						a	>>	 b		정수 a의 각 비트를 b만큼 오른쪽으로 이동
										(빈자리는 정수 a의 최상위 부호 비트(MSB)와 같은 값으로 채워진다.)
						a	>>>	 b		정수 a의 각 비트를 b만큼 오른쪽으로 이동(빈자리는 0으로 채워진다.)
			 ----------------------------------------------------------
			 ex) 1 << 3
			 00000000 00000000 00000000 00000001 << 3
			 ->	(000 버림)00000000 00000000 00000000 00001000 -> Math.pow(2, 3) -> 8
			 ----------------------------------------------------------
			 - 32비트 전체를 왼쪽으로 3비트 이동할 때 맨 왼쪽 3비트는 밀려서 버려진다.
			 - 오른쪽에 새로 생기는 3비트는 0으로 채운다
			 ----------------------------------------------------------
			 ex) -8 >> 3
			 11111111 11111111 11111111 11111000 >> 3
			 -> (111 채움) 11111111 11111111 11111111 11111111(000 버림)
			 -> -(~11111111 11111111 11111111 11111111 + 1)
			 -> -(00000000 00000000 00000000 00000001) -> -1
			 ----------------------------------------------------------
			 - 32비트 전체를 오른쪽으로 3비트 이동할 때 맨 오른쪽 3비트는 밀려서 버려진다.
			 - 맨 왼쪽에 새로 생기는 3비트는 최상위 부호 비트(MSB)와 동일한 값으로 채워진다.
			 ----------------------------------------------------------
			 ex) -8 >>> 3
			 11111111 11111111 11111111 11111000 >>> 3
			 -> (000 채움)00011111 11111111 11111111 11111111(000 버림)
			 -> 536870991
			 ----------------------------------------------------------
			 - 32비트 전체를 오른쪽으로 3비트 이동할 때 맨 오른쪽 3비트는 밀려서 버려진다.
			 - 맨 왼쪽에 새로 생기는 3비트는 무조건 0으로 채워진다.
	
	3.4.6 대입 연산자
		- 오른쪽 피연산자의 값을 좌측 피연산자인 변수에 저장한다.
		- 오른쪽 피연산자는 리터럴 및 변수, 그리고 다른 연산식이 올 수 있다.
		- 단순 대입 연산자 : 단순히 오른쪽 피연산자의 값을 변수에 저장한다.
		- 복합 대입 연산자 : 정해진 연산을 수행한 후 결과를 변수에 저장한다.
		----------------------------------------------------------
		구분					연산식			설명
		단순 대입 연산자		변수	= 피연산자	우측의 피연산자의 값을 변수에 저장
		복합	대입 연산자		변수	+= 피연산자	우측의 비연산자의 값을 변수의 값과 더한 후에 다시 변수에 저장
											(변수 = 변수 + 피연산자와 동일)
							변수 -= 피연산자	우측의 피연산자의 값을 변수의 값에서 뺀 후에 다시 변수에 저장
											(변수 = 변수 - 피연산자와 동일)
							변수 *= 피연산자	우측의 피연산자의 값을 변수의 값과 곱한 후에 다시 변수에 저장
											(변수 = 변수 * 피연산자와 동일)
							변수 /= 피연산자	우측의 피연산자의 값으로 변수의 값을 나눈 후에 다시 변수에 저장
											(변수 = 변수 / 피연산자와 동일)
							변수 %= 피연산자	우측의 피연산자의 값으로 변수의 값을 나눈 후에 나머지를 변수에 저장
											(변수 = 변수 % 피연산자와 동일)
							변수 &= 피연산자	우측의 피연산자의 값과 변수의 값을 & 연산 후 결과를 변수에 저장
											(변수 = 변수 & 피연산자와 동일)
							변수 |= 피연산자	우측의 피연산자의 값과 변수의 값을 | 연산 후 결과를 변수에 저장
											(변수 = 변수 | 피연산자와 동일)
							변수 ^= 피연산자	우측의 피연산자의 값과 변수의 값을 ^ 연산 후 결과를 변수에 저장
											(변수 = 변수 ^ 피연산자와 동일)
							변수 <<= 피연산자	우측의 피연산자의 값과 변수의 값을 << 연산 후 결과를 변수에 저장
											(변수 = 변수 << 피연산자와 동일)
							변수 >>= 피연산자	우측의 피연산자의 값과 변수의 값을 >> 연산 후 결과를 변수에 저장
											(변수 = 변수 >> 피연산자와 동일)
							변수 >>>= 피연산자	우측의 피연산자의 값과 변수의 값을 >>> 연산 후 결과를 변수에 저장
											(변수 = 변수 >>> 피연산자와 동일)
		----------------------------------------------------------
		- 대입 연산자는 모든 연산자들 중에서 가장 낮은 연산 순위를 가지고 있기 때문에 제일 마지막에 수행된다.
		- 연산의 진행방향은 오른쪽에서 왼쪽이다.
		
		
	3.5 삼항 연산자(? :)
		- 세 개의 피필요로 하는 연산자를 말한다.
		- ? 앞의 조건식에 따라 콜론(:) 앞뒤의 피연산자가 선택된다고 해서 조건 연신식이라고 부르기도 한다.
		----------------------------------------------------------
		조건식 ?	값 또는 연산식 : 값 또는 연산식
			  (조건식이 true) : (조건식이 false)		
		----------------------------------------------------------
		- 조건식을 연산하여 true가 나오면 결과는 앞의 피연산자가 된다.
		- 조건식을 연산하여 false가 나오면 결과는 뒤의 피연산자가 된다.
		----------------------------------------------------------
		int score = 95;							=		int score = 95;
		char grade = (score > 90) ? A : B;				char grade;
														if(score > 90) {
															grade = 'A';
														} else {
															grade = 'B';
														}
		----------------------------------------------------------					 
			 