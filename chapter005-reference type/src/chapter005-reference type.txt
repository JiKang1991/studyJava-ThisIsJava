	chapter005 reference type
	
	-- Table of contents --
		5.1 데이터 타입 분류
		5.2 메모리 사용 영역
		5.3 참조 변수의 ==, != 연산
		5.4 null과 NullPointerException
		5.5 String 타입
		5.6 배열 타입
		5.7 열거 타입
	-----------------------
	5.1 데이터 타입 분류
		* 참조 타입 : 객체의 번지를 참조하는 타입
			(1) 배열
			(2) 열거
			(3) 클래스
			(4) 인터페이스
		- 참조 타입을 이용해서 선언된 변수는 메모리의 번지를 값으로 갖는다.
		  기본 타입을 이용해서 선언된 변수는 실제 값(리터럴)을 변수 안에 저장한다.
		----------------------------------------------------------
			기본타입변수				참조변수
			  실제값					100번지 ----------> 100번지(객체)
		----------------------------------------------------------
		- 스택 영역 : 변수가 생성되는 메모리 영역(기본변수, 참조변수)
		- 힙 영역 : 객체가 생성되는 메모리 영역
		
	
	5.2 메모리 사용 영역
		- java.exe로 JVM이 시작되면 JVM은 운영체제에서 할당받은 메모리영역(Runtime Data Area)를
		  (1) 메소드 영역(클래스(런타임 상수풀, 필드/메소드 데이터, 메소드 코드, 생성자 코드),
		  (2) 힙 영역(객체, 배열),
		  (3) 스레드(JVM 스택(프레임(변수)))
		  로 구분해서 사용한다.
		  
	5.2.1 메소드 영역
		- 코드에서 사용되는 클래스(~.class)들을 클래스 로더로 읽어 클래스 별로
		  (1) 런타임 상수풀
		  (2) 필드 데이터
		  (3) 메소드 데이터
		  (4) 메소드 코드
		  (5) 생성자(constructor) 코드
		- JVM이 시작할 때 생성되고 모든 스레드가 공유하는 영역이다.
		
	5.2.2 힙 영역
		- 객체와 배열이 생성되는 영역
		- 힙 영역에 생성된 객체와 배열은 JVM 스택 영역의 변수나 다른 객체의 필드에서 참조한다.
		- 참조하는 변수나 필드가 없다면 의미없는 객체로 쓰레기로 취급하고
		  JVM은 Garbage Collector를 실행시켜 스레기 객체를 힙 영역에서 자동으로 제거한다
		- 객체를 제거하기위해 별도의 코드를 작성할 필요가 없고
		  자바는 코드로 객체를 직접 제거시키는 방법을 제공하지 않는다.
	
	5.2.3 스레드(JVM 스택(Stack) 영역)
		- 각 스레드마다 하나의 JVM 스택 영역이 존재한다.
		- 추가적으로 스레드를 생성하지 않았다면 main 스레드만 존재하며 JVM 스택도 하나이다.
		- JVM 스택은 메소드를 호출할 때 마다 프레임(Frame)을 추가(push)하고 메소드가 종료되면
		  해당 프레임을 제거(pop)하는 동작을 수행한다.
		- 예외 발생시 printStackTrace() 메소드로 보여주는 Stack Trace의 각 라인은 하나의 프레임을 표현한다.
		- 프레임 내부에는 로컬 변수 스택이 있다. 기본 타입 변수와 참조 타입 변수가 추가(push)되거나 제거(pop)된다.
		- 변수가 이 영역에 생성되는 시점은 초기화가 될 때, 즉 최초로 변수에 값이 저장될 때이다.
		- 변수는 선언된 블록 안에서만 스택에 존재하고 블록을 벗어나면 스택에서 제거된다.
		- 선언된 변수는 실행 순서에 따라서 스택에 생성되고 소멸된다.
		----------------------------------------------------------
		(1) char v1 = 'A';
		(2) if (v1 == 'A') {
				int v2 = 100;
				double v3 = 3.14;
			}
		(3) boolean v4 = true;
		(4) int[] scores = {10, 20, 30}
		
		  '(1)' 실행  ->   '(2)'실행    ->  '(3)' 실행	  ->    '(4)' 실행
		| stack 영역 |  | stack 영역  |	| stack 영역  |	|    stack 영역   |
		| (v1, 'A') |  | (v3, 3.14) |	| (v4, true) |	| (scores, 5번지)-|->|
		-------------  | (v2, 100 )	|	| (v1, 'A' ) |	| (  v4  , true) |	|
					   | (v1, 'A' ) |   --------------	| (  v1  ,  'A') |	|
					   --------------					------------------	|
																			|
																			|
													| 	   힙 영역 	    |	V
													| 5번지(10, 20, 30)<-|----
													---------------------
													
		----------------------------------------------------------
		
	
	5.3 참조 변수의 ==, != 연산
		- 참조 타입 변수들 간의 ==, != 연산은 동일한 객체를 참조하는지, 다를 객체를 참조하는지 알아볼 때 사용된다.
		  ( 기본 타입 변수의 ==, != 연산은 변수의 값이 같은지, 아닌지를 조사한다)
		- 참조 타입 변수의 값은 힙 영역의 객체 주소이므로 결국 주소값을 비교하는 것이 된다.
		- 동일한 주소 값을 갖고 있다는 것은 동일한 객체를 참조한다는 의미이다.
		- ==와 != 연산자로 객체를 비교하는 코드는 일반적으로 if문에서 많이 사용된다.
		 ex) if(refVar2 == refVar3){...}
		 
	
	5.4 null과 NullPointerException
		* null : 참조 타입 변수가 힙 영역의 객체를 참조하지 않는다는 뜻으로 가지는 값이다.
			   : 초기값으로 사용될 수 있다.
			   : null로 초기화된 참조 변수는 스택영영에 생성된다.
		- 참조 타입 변수가 null 값을 가지는지 확인하려면 ==, != 연산을 이용하면 된다.
		- 객체를 참조하는 변수의 경우 '변수 == null'의 연산값이 false를 도출하고 '변수 != null'의 연산값이 true를 도출한다.
		- 객체를 참조하지 않는 변수의 경우 '변수 == null'의 연산값이 true를 도출하고 '변수 != null'의 연산 값이 false를 도출한다.
		* exception(예외) : 프로그램 실행 도중에 발생하는 오류이다.
		* NullPointerException : 참조 타입 변수를 잘못 사용하는 경우 발생한다.(참조타입의 변수가 null값을 가지고 있는 경우)
		----------------------------------------------------------
		int[] intArray = null;	// 배열 타입 변수이므로 참조 타입 변수이며 null로 초기화가 가능하다.
		intArray[0] = 10;	// NullPointerException, intArray 변수가 참조하는 배열 객체가 없다.
		
		String str = null;	// 클래스 타입이므로 참조 타입이다. null로 초기화가 가능하다.
		System.out.println("총 문자수 : " + str.length());	// NullPointerException, str객체가 참조하는 String 객체가 없다.
		----------------------------------------------------------
		
		
	5.5 String 타입
		- 문자열 객체를 생성는데에는 문자열 리터럴로 생성하는 방법과 new 연산자를 사용하는 방법이 있다.
		- 문자열 리터럴로 객체를 생성하는 방법은 큰 따옴표로 감싼 문자열을 String 변수에 대입하는 방법이다.
		----------------------------------------------------------
			String str1 = "java";
			
			or
			
			String str2;
			str2 = "java";
		----------------------------------------------------------
		- 위의 경우 "java"라는 문자열 리터럴을 가진 String 객체는 heap영역에 생성되고 str1, str2 변수는 해당 객체의 주소값을 가지고 있다.
		- 자바는 위의 경우와 같이 문자열 리터럴이 동일하다면 String 객체를 공유하도록 되어있다.
		  즉, str1 과 str2 변수는 같은 객체의 주소값을 가지고있다. 
		
		- new 연산자를 사용해서 'String str3 = new String("java");'의 방식으로 객체를 생성하는 것도 가능하다.
		- new 연산자를 사용해서 객체를 만들 경우 heap영역에 "java"라는 문자열 리터럴을 가진 새로운 객체가 생성된다. 
		- str3 변수는 str1, str2와 다른 주소값을 가지게 되며 str1,2와 비교연산을 할 경우 == 연산은 false가 도출된다.
		- 객체의 주소는 다르지만 각 변수가 참조하는 객체가 가진 문자열 리터럴이 동일하기 때문에 .equals() 메소드를 사용하여
		  각 변수를 비교할 경우 true값을 리턴한다.
		
		- String 변수는 참조 타입이므로 초기값으로 null을 대입할 수 있다.(null은 변수가 참조하는 객체가 없다는 뜻이다)
		- 'str1 = "eclipse";'와 같이 객체를 참조하고 있는 변수에 'str1 = null;'와 같이 null값을 대입함으로써
		  더 이상 객체를 참조하지 않도록 할 수 있다.
		  (참조를 잃은 객체는 JVM이 실행시킨 Gabage Collector에 의해 메모리에서 제거된다)
		  
		  
	5.6 배열 타입
	5.6.1 배열이란?
		* 배열 : 같은 타입의 데이터를 연속된 공간에 나열시키고, 각 데이터에 인덱스(index)를 부여해 놓은 자료구조이다.
		* 인덱스 : 각 항목의 데이터를 읽거나, 저장하는데 사용한다. 배열 이름 옆 대괄호[]에 기입한다. ex) 배열이름[1]
		- 배열을 사용하면 같은 타입의 많은 양의 데이터를 효율적으로 가공할 수 있다. 
		- 배열은 선언과 동시에 저장할 수 있는 데이터 타입이 결정된다.
		* 타입 불일치(Type mismatch) 컴파일 오류 : 배열 선언시 결정한 데이터 타입과 배열에 저장하려는 데이터 타입이 다를 경우 발생한다.
		- 한번 생성된 배열은 길이를 늘리거나 줄일 수 없다.
	
	5.6.2 배열 선언
		- 배열 변수 선언은 '타입[] 변수;', '타입 변수[];'의 두가지 형태로 작성할 수 있다.
		- 대괄호[]는 배열 변수를 선언하는 기호로 사용한다. 타입 뒤에 붙거나 변수 뒤에 붙는다.
		- 타입은 배열에 저장될 데이터의 타입을 말한다.
		----------------------------------------------------------
		int[] intArray;				int intArray[];
		double[] doubleArray; 		double doubleArray[];
		String[] strArray;			String strArray[];
		----------------------------------------------------------
		- 배열 변수는 참조변수에 속한다. 배열도 객체이므로 힙 영역에 생성되고 배열 변수는 힙 영역의 배열 객체를 참조하게 된다.
		- 참조할 배열 객체가 없다면 배열 변수는 null 값으로 초기화 될 수 있다.	ex) 타입[] 변수 = null;
		- 만약 배열 변수가 null 값을 가진 상태에서 변수[인덱스]로 값을 읽거나 저장하게 되면 NullPointerException이 발생한다.
		- 배열 변수는 배열을 생성하고 참조하는 상태에서 값을 저장하거나 읽어야 한다.
		
	5.6.3 값 목록으로 배열 생성
		- 배열 항목에 저장될 값의 목록이 있다면 '데이터타입[] 변수 = {값0, 값1, 값2, 값3, ...};'의 형식으로 배열 객체를 만들 수 있다.
		- 중괄호{}는 주어진 값들을 항목으로 가지는 배열 객체를 힙에 생성하고 배열 객체의 번지를 리턴한다.
		- 배열 변수는 리턴된 번지를 저장함으로써 참조가 이루어진다.
		- "값0"은 변수[0], "값1"은 변수[1], "값2"는 변수[2]로 읽을 수 있다.
		- 변수[0]의 "값0"을 "값00"으로 바꾸고 싶다면 '변수[0] = "값00"'의 형식으로 대입 연산자를 사용하면 된다.
		- '타입[] 변수;', '변수 = {값0, 값1, 값2, ...}'와 같이 배열 변수를 이미 선언한 후에
		  다른 실행문에서 중괄호를 사용한 배열 생성은 허용되지 않는다. (컴파일 에러 발생)
		- 배열 변수를 미리 선언한 후, 값 목록들이 나중에 결정되는 상황이라면 '변수 = new 타입[] {값0, 값1, 값2, ...};'과 같이
		  new 연산자를 사용해서 값 목록을 지정해주면 된다.
		- 값 목록으로 배열을 생성함과 동시에 메소드의 매개값으로 사용하고자 할 때에도 '리턴타입 메소드이름(배열타입[] 배열이름){...}',
		  '변수타입 변수이름 = 메소드이름(new 배열타입[] {값0, 값1, 값2, ...};와 같이 new연산자를 사용해야 한다.
		  
	5.6.4 new 연산자로 배열 생성
		- 값의 목록을 가지고 있지 않지만, 향후 값들을 저장할 배열을 미리 만들고 싶다면 new 연산자로 다음과 같이 배열 객체를 생성할 수 있다.
		----------------------------------------------------------
			타입[] 변수 = new 타입[길이];
		---------------------------------------------------------- 
		- 길이는 배열이 저장할 수 있는 값의 수를 말한다.
		- new 연산자로 배열을 생성할 경우에는 이미 배열변수가 선언된 후에도 가능하다.
		- new 연산자로 배열을 처음 생성할 경우, 배열은 자동적으로 기본값으로 초기화된다. (int -> 0, String -> null)
		----------------------------------------------------------
			타입[] 변수 = null;
			변수 = new 타입[길이];
			
			// 자바는 intArray[0] ~ intArray[4]까지 저장할 수 있는 공간을 확보하고, 배열의 생성 번지를 리턴한다.
			// 리턴된 번지는 intArray 변수에 저장된다.
			int[] intArray = new int[5];	
			
			| stack Area |				| 								heap Area	   						 |
			|  intArray -|--------------|-> intArray[0](4byte), intArray[1](4byte), ... , intArray[4](4byte) |
			
			intArray[n] : 00000000(1byte) 00000000 00000000 00000000 
		----------------------------------------------------------
		- 다음은 타입 별로 배열의 초기값을 보여준다
		----------------------------------------------------------
			분류				데이터 타입					초기값
			기본타입(정수)		byte[]						0
							char[]						'\u0000'
							short[]						0
							int[]						0
							long[]						0L
			기본타입(실수)		float[]						0.0F
							double[]					0.0
			기본타입(논리)		boolean[]					false
			참조타입			클래스[]						null
							인터페이스[]					null
		----------------------------------------------------------
		- 배열이 생성되고 나서 새로운 값을 저장하려면 대입 연산자를 사용하면 된다.
		----------------------------------------------------------
			변수[인덱스] = 값;
			
			int[] scores = new int[3];
			scores[0] = 83;
			scores[1] = 90;
			scores[2] = 75;
		----------------------------------------------------------
		
	5.6.5 배열 길이
		- 배열에 저장할 수 있는 전체 항목 수
		* 배열변수.length : 배열 객체의 length 필드를 읽는 메서드
		* 필드 : 객체 내부의 데이터
		- 배열의 length필드는 for문을 사용해서 배열 전체를 루핑할 때 유용하다.
		- 배열의 마지막 인덱스는 배열 길이보다 1이 적으므로 for문의 조건식에서 < 연산자를 사용한다.
		* ArrayIndexOutOfBoundsException : 인덱스를 초과해서 배열을 사용할 경수 발생하는 에러
		----------------------------------------------------------
			int[] intArray = { 10, 20, 30 };
			int num = intArray.length;	// num에는 3이 저장된다.
			
			int[] scores = { 83, 90, 87 };
			int sum  = 0;
			for(int i = 0; i < scores.length; i++) {
				sum += scores[i];
			}
			System.out.println("총합 : " + sum);		// sum에는 260이 저장되어있다.
			
			double avg = (double) sum / scores.length;	// 260을 3으로 나눈다
			System.out.println("평균 : " + avg);	 // avg는 86.66...
		----------------------------------------------------------
	
	5.6.6 커맨드 라인 입력
		* String[] args : main() 메소드의 매개값
		- 명령 프롬프트에서 "java 클래스"로 프로그램을 실행하면 JVM은 길이가 0인 String 배열을 먼저 생성하고
		  main() 메소드를 호출할 때 매개값으로 전달한다.
		- "java 클래스 문자열0 문자열1 문자열2 ... 문자열n-1" 과 같이
		  "java 클래스" 뒤에 공백으로 구분된 문자열 목록을 주고 실행하면,
		  문자열 목록으로 구성된 String[] 배열이 생성되고 main() 메소드를 호출할 때 
		  매개값으로 전달된다.
		- main() 메소드는 String[] args 매개변수를 통해서 커맨드 라인에서 입력된 데이터의 수(배열의 길이)와
		  입력된 데이터(배열의 항목 값)을 알 수 있게 된다.
		----------------------------------------------------------
			String[] args = {문자열0, 문자열1, 문자열2, ... 문자열n-1};  
					  | 	
		  			  V	
		 			  ------------------------>|	
						main() 메소드 호출시 전달  |
											   V
			public static void main(String[] args){
				...
			}
		----------------------------------------------------------
		* 이클립스에서 프로그램을 실행할 때 매개값을 주고 실행하는 방법
			[Menu -> Run -> Run Configurations -> Main -> Project -> Main Class
			-> Arguments -> Program arguments] '문자열0 문자열1 ... 문자열n-1'을 입력하고 [Apply -> Run]을 클릭한다.
			이는 명령 프롬프트에서 'java 클래스명 문자열0 문자열1 ... 문자열n-1'로 실행하는 것과 동일하다.
			이렇게 실행하면 args는 { 문자열0, 문자열1, ... , 문자열n-1 } 배열을 참조하게 되고
			args[0]은 문자열0, args[1]은 문자열1, args[n-1]은 문자열n-1을 얻을 수 있다.
		
		* Integer.parseInt() : 매개 변수에 정수로 변환 가능한 문자열이 저장되어있을 경우 매개변수를 정수로 변환한 후 저장한다.
		* NumberFornetException 실행 예외 : Integer.parseInt() 메소드의 매개변수에 정수로 변환 할 수 없는 데이터가 저장되어 있을 경우
	
	5.6.7 다차원 배열
		* 2차원 배열 : 행과 열로서 구성된 배열
				   : 가로 인덱스와 세로 인덱스를 사용한다
				   : 중첩 배열 방식으로 구현한다
				   ----------------------------------------------------------
						int[][] scores = new int[2][3];
						 
						위의 코드는 메모리에 세 개의 배열 객체를 생성한다(int[] A, int[] B, int[] C)
						배열 변수인 scores 는 길이가 2인 배열 A객체를 참조한다.
						배열 A객체의 0번 인덱스 즉, scores[0]은 배열 B객체를 참조한다.
						배열 A객체의 1번 인덱스 즉, scores[1]은 배열 C객체를 참조한다.
						 
						각 배열의 길이는 다음과 같이 얻을 수 있다.
						scores.length		// 2(배열 A의 길이)
						scores[0].length	// 3(배열 B의 길이)
						scores[1].length	// 3(배열 C의 길이)
						 
						scores[0][1] = 배열 B의 인덱스 1 값
						scores[1][0] = 배열 C의 인덱스 0 값
				   ----------------------------------------------------------
				   : 자바 배열은 계단식 구조를 가질 수 있다.
				   ----------------------------------------------------------
				   		int[][] scores = new int[2][];
				   		scores[0] = new int[2];		// 0  1
				   		scores[1] = new int[3];		// 0  1  2
				   		
				   		위의 코드는
				   		길이 2의 int 타입 배열A, 길이 2의 int 타입 배열B, 길이 3의 int타입 배열C를 생성한다.
				   		배열 A의 인덱스 0은 배열B를 참조하고 인덱스 1은 배열C를 참조한다.
				   	----------------------------------------------------------	
				   	* ArrayIndexOutOfBoundsException : 배열 길이를 초과하여 사용할 경우 발생
				    - 그룹화된 값 목록을 가지고 있다면 중괄호 안에 다시 중괄호를 사용해서 값 목록을 나열할 수 있다.
				    ----------------------------------------------------------
				    	타입[][] 변수 = { { 값1, 값2, ... }, { 값3, 값4, ... } };
				    	
				    	타입 변수명 = 배열변수명[0][0];		// 값1
				    	타입 변수명 = 배열변수명[1][1];		// 값4 	 
				    ----------------------------------------------------------
	
	5.6.8 객체를 참조하는 배열
		- 참조 타입 배열은 각 항목에 문자열이 아니라 참조 타입 객체의 주소를 가지고 있다. 즉, 객체를 참조하게 된다.
		----------------------------------------------------------
			String[] strArray = new String[3];
			strArray[0] = "Java";
			strArray[1] = "C++";
			strArray[2] = "C#";
			
			위의 코드는 String 배열 객체 하나와 String 객체 3개를 생성한다.
			String 배열의 각 인덱스는 String 객체의 주소값을 참조한다.
		----------------------------------------------------------	
		- String 배열의 각 항목 값을 비교할 때는 == 연산자 대신 .equal() 메소드를 사용해야 한다.
		
	
	