	chapter005 reference type
	
	-- Table of contents --
		5.1 데이터 타입 분류
		5.2 메모리 사용 영역
		5.3 참조 변수의 ==, != 연산
		5.4 null과 NullPointerException
		5.5 String 타입
		5.6 배열 타입
		5.7 열거 타입
	-----------------------
	5.1 데이터 타입 분류
		* 참조 타입 : 객체의 번지를 참조하는 타입
			(1) 배열
			(2) 열거
			(3) 클래스
			(4) 인터페이스
		- 참조 타입을 이용해서 선언된 변수는 메모리의 번지를 값으로 갖는다.
		  기본 타입을 이용해서 선언된 변수는 실제 값(리터럴)을 변수 안에 저장한다.
		----------------------------------------------------------
			기본타입변수				참조변수
			  실제값					100번지 ----------> 100번지(객체)
		----------------------------------------------------------
		- 스택 영역 : 변수가 생성되는 메모리 영역(기본변수, 참조변수)
		- 힙 영역 : 객체가 생성되는 메모리 영역
		
	
	5.2 메모리 사용 영역
		- java.exe로 JVM이 시작되면 JVM은 운영체제에서 할당받은 메모리영역(Runtime Data Area)를
		  (1) 메소드 영역(클래스(런타임 상수풀, 필드/메소드 데이터, 메소드 코드, 생성자 코드),
		  (2) 힙 영역(객체, 배열),
		  (3) 스레드(JVM 스택(프레임(변수)))
		  로 구분해서 사용한다.
		  
	5.2.1 메소드 영역
		- 코드에서 사용되는 클래스(~.class)들을 클래스 로더로 읽어 클래스 별로
		  (1) 런타임 상수풀
		  (2) 필드 데이터
		  (3) 메소드 데이터
		  (4) 메소드 코드
		  (5) 생성자(constructor) 코드
		- JVM이 시작할 때 생성되고 모든 스레드가 공유하는 영역이다.
		
	5.2.2 힙 영역
		- 객체와 배열이 생성되는 영역
		- 힙 영역에 생성된 객체와 배열은 JVM 스택 영역의 변수나 다른 객체의 필드에서 참조한다.
		- 참조하는 변수나 필드가 없다면 의미없는 객체로 쓰레기로 취급하고
		  JVM은 Garbage Collector를 실행시켜 스레기 객체를 힙 영역에서 자동으로 제거한다
		- 객체를 제거하기위해 별도의 코드를 작성할 필요가 없고
		  자바는 코드로 객체를 직접 제거시키는 방법을 제공하지 않는다.
	
	5.2.3 스레드(JVM 스택(Stack) 영역)
		- 각 스레드마다 하나의 JVM 스택 영역이 존재한다.
		- 추가적으로 스레드를 생성하지 않았다면 main 스레드만 존재하며 JVM 스택도 하나이다.
		- JVM 스택은 메소드를 호출할 때 마다 프레임(Frame)을 추가(push)하고 메소드가 종료되면
		  해당 프레임을 제거(pop)하는 동작을 수행한다.
		- 예외 발생시 printStackTrace() 메소드로 보여주는 Stack Trace의 각 라인은 하나의 프레임을 표현한다.
		- 프레임 내부에는 로컬 변수 스택이 있다. 기본 타입 변수와 참조 타입 변수가 추가(push)되거나 제거(pop)된다.
		- 변수가 이 영역에 생성되는 시점은 초기화가 될 때, 즉 최초로 변수에 값이 저장될 때이다.
		- 변수는 선언된 블록 안에서만 스택에 존재하고 블록을 벗어나면 스택에서 제거된다.
		- 선언된 변수는 실행 순서에 따라서 스택에 생성되고 소멸된다.
		----------------------------------------------------------
		(1) char v1 = 'A';
		(2) if (v1 == 'A') {
				int v2 = 100;
				double v3 = 3.14;
			}
		(3) boolean v4 = true;
		(4) int[] scores = {10, 20, 30}
		
		  '(1)' 실행  ->   '(2)'실행    ->  '(3)' 실행	  ->    '(4)' 실행
		| stack 영역 |  | stack 영역  |	| stack 영역  |	|    stack 영역   |
		| (v1, 'A') |  | (v3, 3.14) |	| (v4, true) |	| (scores, 5번지)-|->|
		-------------  | (v2, 100 )	|	| (v1, 'A' ) |	| (  v4  , true) |	|
					   | (v1, 'A' ) |   --------------	| (  v1  ,  'A') |	|
					   --------------					------------------	|
																			|
																			|
													| 	   힙 영역 	    |	V
													| 5번지(10, 20, 30)<-|----
													---------------------
													
		----------------------------------------------------------
		
	
	5.3 참조 변수의 ==, != 연산
		- 참조 타입 변수들 간의 ==, != 연산은 동일한 객체를 참조하는지, 다를 객체를 참조하는지 알아볼 때 사용된다.
		  ( 기본 타입 변수의 ==, != 연산은 변수의 값이 같은지, 아닌지를 조사한다)
		- 참조 타입 변수의 값은 힙 영역의 객체 주소이므로 결국 주소값을 비교하는 것이 된다.
		- 동일한 주소 값을 갖고 있다는 것은 동일한 객체를 참조한다는 의미이다.
		- ==와 != 연산자로 객체를 비교하는 코드는 일반적으로 if문에서 많이 사용된다.
		 ex) if(refVar2 == refVar3){...}
		 
	
	5.4 null과 NullPointerException
		* null : 참조 타입 변수가 힙 영역의 객체를 참조하지 않는다는 뜻으로 가지는 값이다.
			   : 초기값으로 사용될 수 있다.
			   : null로 초기화된 참조 변수는 스택영영에 생성된다.
		- 참조 타입 변수가 null 값을 가지는지 확인하려면 ==, != 연산을 이용하면 된다.
		- 객체를 참조하는 변수의 경우 '변수 == null'의 연산값이 false를 도출하고 '변수 != null'의 연산값이 true를 도출한다.
		- 객체를 참조하지 않는 변수의 경우 '변수 == null'의 연산값이 true를 도출하고 '변수 != null'의 연산 값이 false를 도출한다.
		* exception(예외) : 프로그램 실행 도중에 발생하는 오류이다.
		* NullPointerException : 참조 타입 변수를 잘못 사용하는 경우 발생한다.(참조타입의 변수가 null값을 가지고 있는 경우)
		----------------------------------------------------------
		int[] intArray = null;	// 배열 타입 변수이므로 참조 타입 변수이며 null로 초기화가 가능하다.
		intArray[0] = 10;	// NullPointerException, intArray 변수가 참조하는 배열 객체가 없다.
		
		String str = null;	// 클래스 타입이므로 참조 타입이다. null로 초기화가 가능하다.
		System.out.println("총 문자수 : " + str.length());	// NullPointerException, str객체가 참조하는 String 객체가 없다.
		----------------------------------------------------------
		
		
	5.5 String 타입
		- 문자열 객체를 생성는데에는 문자열 리터럴로 생성하는 방법과 new 연산자를 사용하는 방법이 있다.
		- 문자열 리터럴로 객체를 생성하는 방법은 큰 따옴표로 감싼 문자열을 String 변수에 대입하는 방법이다.
		----------------------------------------------------------
			String str1 = "java";
			
			or
			
			String str2;
			str2 = "java";
		----------------------------------------------------------
		- 위의 경우 "java"라는 문자열 리터럴을 가진 String 객체는 heap영역에 생성되고 str1, str2 변수는 해당 객체의 주소값을 가지고 있다.
		- 자바는 위의 경우와 같이 문자열 리터럴이 동일하다면 String 객체를 공유하도록 되어있다.
		  즉, str1 과 str2 변수는 같은 객체의 주소값을 가지고있다. 
		
		- new 연산자를 사용해서 'String str3 = new String("java");'의 방식으로 객체를 생성하는 것도 가능하다.
		- new 연산자를 사용해서 객체를 만들 경우 heap영역에 "java"라는 문자열 리터럴을 가진 새로운 객체가 생성된다. 
		- str3 변수는 str1, str2와 다른 주소값을 가지게 되며 str1,2와 비교연산을 할 경우 == 연산은 false가 도출된다.
		- 객체의 주소는 다르지만 각 변수가 참조하는 객체가 가진 문자열 리터럴이 동일하기 때문에 .equals() 메소드를 사용하여
		  각 변수를 비교할 경우 true값을 리턴한다.
		
		- String 변수는 참조 타입이므로 초기값으로 null을 대입할 수 있다.(null은 변수가 참조하는 객체가 없다는 뜻이다)
		- 'str1 = "eclipse";'와 같이 객체를 참조하고 있는 변수에 'str1 = null;'와 같이 null값을 대입함으로써
		  더 이상 객체를 참조하지 않도록 할 수 있다.
		  (참조를 잃은 객체는 JVM이 실행시킨 Gabage Collector에 의해 메모리에서 제거된다)
		  
		  
	5.6 배열 타입
	5.6.1 배열이란?
		* 배열 : 같은 타입의 데이터를 연속된 공간에 나열시키고, 각 데이터에 인덱스(index)를 부여해 놓은 자료구조이다.
		* 인덱스 : 각 항목의 데이터를 읽거나, 저장하는데 사용한다. 배열 이름 옆 대괄호[]에 기입한다. ex) 배열이름[1]
		- 배열을 사용하면 같은 타입의 많은 양의 데이터를 효율적으로 가공할 수 있다. 
		- 배열은 선언과 동시에 저장할 수 있는 데이터 타입이 결정된다.
		* 타입 불일치(Type mismatch) 컴파일 오류 : 배열 선언시 결정한 데이터 타입과 배열에 저장하려는 데이터 타입이 다를 경우 발생한다.
		- 한번 생성된 배열은 길이를 늘리거나 줄일 수 없다.
	
	5.6.2 배열 선언
		- 배열 변수 선언은 '타입[] 변수;', '타입 변수[];'의 두가지 형태로 작성할 수 있다.
		- 대괄호[]는 배열 변수를 선언하는 기호로 사용한다. 타입 뒤에 붙거나 변수 뒤에 붙는다.
		- 타입은 배열에 저장될 데이터의 타입을 말한다.
		----------------------------------------------------------
		int[] intArray;				int intArray[];
		double[] doubleArray; 		double doubleArray[];
		String[] strArray;			String strArray[];
		----------------------------------------------------------
		- 배열 변수는 참조변수에 속한다. 배열도 객체이므로 힙 영역에 생성되고 배열 변수는 힙 영역의 배열 객체를 참조하게 된다.
		- 참조할 배열 객체가 없다면 배열 변수는 null 값으로 초기화 될 수 있다.	ex) 타입[] 변수 = null;
		- 만약 배열 변수가 null 값을 가진 상태에서 변수[인덱스]로 값을 읽거나 저장하게 되면 NullPointerException이 발생한다.
		- 배열 변수는 배열을 생성하고 참조하는 상태에서 값을 저장하거나 읽어야 한다.
		
	5.6.3 값 목록으로 배열 생성
		- 배열 항목에 저장될 값의 목록이 있다면 '데이터타입[] 변수 = {값0, 값1, 값2, 값3, ...};'의 형식으로 배열 객체를 만들 수 있다.
		- 중괄호{}는 주어진 값들을 항목으로 가지는 배열 객체를 힙에 생성하고 배열 객체의 번지를 리턴한다.
		- 배열 변수는 리턴된 번지를 저장함으로써 참조가 이루어진다.
		- "값0"은 변수[0], "값1"은 변수[1], "값2"는 변수[2]로 읽을 수 있다.
		- 변수[0]의 "값0"을 "값00"으로 바꾸고 싶다면 '변수[0] = "값00"'의 형식으로 대입 연산자를 사용하면 된다.
		- '타입[] 변수;', '변수 = {값0, 값1, 값2, ...}'와 같이 배열 변수를 이미 선언한 후에
		  다른 실행문에서 중괄호를 사용한 배열 생성은 허용되지 않는다. (컴파일 에러 발생)
		- 배열 변수를 미리 선언한 후, 값 목록들이 나중에 결정되는 상황이라면 '변수 = new 타입[] {값0, 값1, 값2, ...};'과 같이
		  new 연산자를 사용해서 값 목록을 지정해주면 된다.
		- 값 목록으로 배열을 생성함과 동시에 메소드의 매개값으로 사용하고자 할 때에도 '리턴타입 메소드이름(배열타입[] 배열이름){...}',
		  '변수타입 변수이름 = 메소드이름(new 배열타입[] {값0, 값1, 값2, ...};와 같이 new연산자를 사용해야 한다.
		  
	5.6.4 new 연산자로 배열 생성
		- 값의 목록을 가지고 있지 않지만, 향후 값들을 저장할 배열을 미리 만들고 싶다면 new 연산자로 다음과 같이 배열 객체를 생성할 수 있다.
		----------------------------------------------------------
			타입[] 변수 = new 타입[길이];
		---------------------------------------------------------- 
		- 길이는 배열이 저장할 수 있는 값의 수를 말한다.
		- new 연산자로 배열을 생성할 경우에는 이미 배열변수가 선언된 후에도 가능하다.
		- new 연산자로 배열을 처음 생성할 경우, 배열은 자동적으로 기본값으로 초기화된다. (int -> 0, String -> null)
		----------------------------------------------------------
			타입[] 변수 = null;
			변수 = new 타입[길이];
			
			// 자바는 intArray[0] ~ intArray[4]까지 저장할 수 있는 공간을 확보하고, 배열의 생성 번지를 리턴한다.
			// 리턴된 번지는 intArray 변수에 저장된다.
			int[] intArray = new int[5];	
			
			| stack Area |				| 								heap Area	   						 |
			|  intArray -|--------------|-> intArray[0](4byte), intArray[1](4byte), ... , intArray[4](4byte) |
			
			intArray[n] : 00000000(1byte) 00000000 00000000 00000000 
		----------------------------------------------------------
		- 다음은 타입 별로 배열의 초기값을 보여준다
		----------------------------------------------------------
			분류				데이터 타입					초기값
			기본타입(정수)		byte[]						0
							char[]						'\u0000'
							short[]						0
							int[]						0
							long[]						0L
			기본타입(실수)		float[]						0.0F
							double[]					0.0
			기본타입(논리)		boolean[]					false
			참조타입			클래스[]						null
							인터페이스[]					null
		----------------------------------------------------------
		- 배열이 생성되고 나서 새로운 값을 저장하려면 대입 연산자를 사용하면 된다.
		----------------------------------------------------------
			변수[인덱스] = 값;
			
			int[] scores = new int[3];
			scores[0] = 83;
			scores[1] = 90;
			scores[2] = 75;
		----------------------------------------------------------
		
		  
		 
		
		