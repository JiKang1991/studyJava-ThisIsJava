	chapter005 reference type
	
	-- Table of contents --
		5.1 데이터 타입 분류
		5.2 메모리 사용 영역
		5.3 참조 변수의 ==, != 연산
		5.4 null과 NullPointerException
		5.5 String 타입
		5.6 배열 타입
		5.7 열거 타입
	-----------------------
	5.1 데이터 타입 분류
		* 참조 타입 : 객체의 번지를 참조하는 타입
			(1) 배열
			(2) 열거
			(3) 클래스
			(4) 인터페이스
		- 참조 타입을 이용해서 선언된 변수는 메모리의 번지를 값으로 갖는다.
		  기본 타입을 이용해서 선언된 변수는 실제 값(리터럴)을 변수 안에 저장한다.
		----------------------------------------------------------
			기본타입변수				참조변수
			  실제값					100번지 ----------> 100번지(객체)
		----------------------------------------------------------
		- 스택 영역 : 변수가 생성되는 메모리 영역(기본변수, 참조변수)
		- 힙 영역 : 객체가 생성되는 메모리 영역
		
	
	5.2 메모리 사용 영역
		- java.exe로 JVM이 시작되면 JVM은 운영체제에서 할당받은 메모리영역(Runtime Data Area)를
		  (1) 메소드 영역(클래스(런타임 상수풀, 필드/메소드 데이터, 메소드 코드, 생성자 코드),
		  (2) 힙 영역(객체, 배열),
		  (3) 스레드(JVM 스택(프레임(변수)))
		  로 구분해서 사용한다.
		  
	5.2.1 메소드 영역
		- 코드에서 사용되는 클래스(~.class)들을 클래스 로더로 읽어 클래스 별로
		  (1) 런타임 상수풀
		  (2) 필드 데이터
		  (3) 메소드 데이터
		  (4) 메소드 코드
		  (5) 생성자(constructor) 코드
		- JVM이 시작할 때 생성되고 모든 스레드가 공유하는 영역이다.
		
	5.2.2 힙 영역
		- 객체와 배열이 생성되는 영역
		- 힙 영역에 생성된 객체와 배열은 JVM 스택 영역의 변수나 다른 객체의 필드에서 참조한다.
		- 참조하는 변수나 필드가 없다면 의미없는 객체로 쓰레기로 취급하고
		  JVM은 Garbage Collector를 실행시켜 스레기 객체를 힙 영역에서 자동으로 제거한다
		- 객체를 제거하기위해 별도의 코드를 작성할 필요가 없고
		  자바는 코드로 객체를 직접 제거시키는 방법을 제공하지 않는다.
	
	5.2.3 스레드(JVM 스택(Stack) 영역)
		- 각 스레드마다 하나의 JVM 스택 영역이 존재한다.
		- 추가적으로 스레드를 생성하지 않았다면 main 스레드만 존재하며 JVM 스택도 하나이다.
		- JVM 스택은 메소드를 호출할 때 마다 프레임(Frame)을 추가(push)하고 메소드가 종료되면
		  해당 프레임을 제거(pop)하는 동작을 수행한다.
		- 예외 발생시 printStackTrace() 메소드로 보여주는 Stack Trace의 각 라인은 하나의 프레임을 표현한다.
		- 프레임 내부에는 로컬 변수 스택이 있다. 기본 타입 변수와 참조 타입 변수가 추가(push)되거나 제거(pop)된다.
		- 변수가 이 영역에 생성되는 시점은 초기화가 될 때, 즉 최초로 변수에 값이 저장될 때이다.
		- 변수는 선언된 블록 안에서만 스택에 존재하고 블록을 벗어나면 스택에서 제거된다.
		- 선언된 변수는 실행 순서에 따라서 스택에 생성되고 소멸된다.
		----------------------------------------------------------
		(1) char v1 = 'A';
		(2) if (v1 == 'A') {
				int v2 = 100;
				double v3 = 3.14;
			}
		(3) boolean v4 = true;
		(4) int[] scores = {10, 20, 30}
		
		  '(1)' 실행  ->   '(2)'실행    ->  '(3)' 실행	  ->    '(4)' 실행
		| stack 영역 |  | stack 영역  |	| stack 영역  |	|    stack 영역   |
		| (v1, 'A') |  | (v3, 3.14) |	| (v4, true) |	| (scores, 5번지)-|->|
		-------------  | (v2, 100 )	|	| (v1, 'A' ) |	| (  v4  , true) |	|
					   | (v1, 'A' ) |   --------------	| (  v1  ,  'A') |	|
					   --------------					------------------	|
																			|
																			|
													| 	   힙 영역 	    |	V
													| 5번지(10, 20, 30)<-|----
													---------------------
													
		----------------------------------------------------------
		
	
	5.3 참조 변수의 ==, != 연산
		- 참조 타입 변수들 간의 ==, != 연산은 동일한 객체를 참조하는지, 다를 객체를 참조하는지 알아볼 때 사용된다.
		  ( 기본 타입 변수의 ==, != 연산은 변수의 값이 같은지, 아닌지를 조사한다)
		- 참조 타입 변수의 값은 힙 영역의 객체 주소이므로 결국 주소값을 비교하는 것이 된다.
		- 동일한 주소 값을 갖고 있다는 것은 동일한 객체를 참조한다는 의미이다.
		- ==와 != 연산자로 객체를 비교하는 코드는 일반적으로 if문에서 많이 사용된다.
		 ex) if(refVar2 == refVar3){...}
		 
	
	5.4 null과 NullPointerException
		* null : 참조 타입 변수가 힙 영역의 객체를 참조하지 않는다는 뜻으로 가지는 값이다.
			   : 초기값으로 사용될 수 있다.
			   : null로 초기화된 참조 변수는 스택영영에 생성된다.
		- 참조 타입 변수가 null 값을 가지는지 확인하려면 ==, != 연산을 이용하면 된다.
		- 객체를 참조하는 변수의 경우 '변수 == null'의 연산값이 false를 도출하고 '변수 != null'의 연산값이 true를 도출한다.
		- 객체를 참조하지 않는 변수의 경우 '변수 == null'의 연산값이 true를 도출하고 '변수 != null'의 연산 값이 false를 도출한다.
		* exception(예외) : 프로그램 실행 도중에 발생하는 오류이다.
		* NullPointerException : 참조 타입 변수를 잘못 사용하는 경우 발생한다.(참조타입의 변수가 null값을 가지고 있는 경우)
		----------------------------------------------------------
		int[] intArray = null;	// 배열 타입 변수이므로 참조 타입 변수이며 null로 초기화가 가능하다.
		intArray[0] = 10;	// NullPointerException, intArray 변수가 참조하는 배열 객체가 없다.
		
		String str = null;	// 클래스 타입이므로 참조 타입이다. null로 초기화가 가능하다.
		System.out.println("총 문자수 : " + str.length());	// NullPointerException, str객체가 참조하는 String 객체가 없다.
		----------------------------------------------------------
		
		
	5.5 String 타입
		- 문자열 객체를 생성는데에는 문자열 리터럴로 생성하는 방법과 new 연산자를 사용하는 방법이 있다.
		- 문자열 리터럴로 객체를 생성하는 방법은 큰 따옴표로 감싼 문자열을 String 변수에 대입하는 방법이다.
		----------------------------------------------------------
			String str1 = "java";
			
			or
			
			String str2;
			str2 = "java";
		----------------------------------------------------------
		- 위의 경우 "java"라는 문자열 리터럴을 가진 String 객체는 heap영역에 생성되고 str1, str2 변수는 해당 객체의 주소값을 가지고 있다.
		- 자바는 위의 경우와 같이 문자열 리터럴이 동일하다면 String 객체를 공유하도록 되어있다.
		  즉, str1 과 str2 변수는 같은 객체의 주소값을 가지고있다. 
		
		- new 연산자를 사용해서 'String str3 = new String("java");'의 방식으로 객체를 생성하는 것도 가능하다.
		- new 연산자를 사용해서 객체를 만들 경우 heap영역에 "java"라는 문자열 리터럴을 가진 새로운 객체가 생성된다. 
		- str3 변수는 str1, str2와 다른 주소값을 가지게 되며 str1,2와 비교연산을 할 경우 == 연산은 false가 도출된다.
		- 객체의 주소는 다르지만 각 변수가 참조하는 객체가 가진 문자열 리터럴이 동일하기 때문에 .equals() 메소드를 사용하여
		  각 변수를 비교할 경우 true값을 리턴한다.
		
		- String 변수는 참조 타입이므로 초기값으로 null을 대입할 수 있다.(null은 변수가 참조하는 객체가 없다는 뜻이다)
		- 'str1 = "eclipse";'와 같이 객체를 참조하고 있는 변수에 'str1 = null;'와 같이 null값을 대입함으로써
		  더 이상 객체를 참조하지 않도록 할 수 있다.
		  (참조를 잃은 객체는 JVM이 실행시킨 Gabage Collector에 의해 메모리에서 제거된다)
		  
		 
		
		