	chapter005 reference type
	
	-- Table of contents --
		5.1 데이터 타입 분류
		5.2 메모리 사용 영역
		5.3 참조 변수의 ==, != 연산
		5.4 null과 NullPointerException
		5.5 String 타입
		5.6 배열 타입
		5.7 열거 타입
	-----------------------
	5.1 데이터 타입 분류
		* 참조 타입 : 객체의 번지를 참조하는 타입
			(1) 배열
			(2) 열거
			(3) 클래스
			(4) 인터페이스
		- 참조 타입을 이용해서 선언된 변수는 메모리의 번지를 값으로 갖는다.
		  기본 타입을 이용해서 선언된 변수는 실제 값(리터럴)을 변수 안에 저장한다.
		----------------------------------------------------------
			기본타입변수				참조변수
			  실제값					100번지 ----------> 100번지(객체)
		----------------------------------------------------------
		- 스택 영역 : 변수가 생성되는 메모리 영역(기본변수, 참조변수)
		- 힙 영역 : 객체가 생성되는 메모리 영역
		
	
	5.2 메모리 사용 영역
		- java.exe로 JVM이 시작되면 JVM은 운영체제에서 할당받은 메모리영역(Runtime Data Area)를
		  (1) 메소드 영역(클래스(런타임 상수풀, 필드/메소드 데이터, 메소드 코드, 생성자 코드),
		  (2) 힙 영역(객체, 배열),
		  (3) 스레드(JVM 스택(프레임(변수)))
		  로 구분해서 사용한다.
		  
	5.2.1 메소드 영역
		- 코드에서 사용되는 클래스(~.class)들을 클래스 로더로 읽어 클래스 별로
		  (1) 런타임 상수풀
		  (2) 필드 데이터
		  (3) 메소드 데이터
		  (4) 메소드 코드
		  (5) 생성자(constructor) 코드
		- JVM이 시작할 때 생성되고 모든 스레드가 공유하는 영역이다.
		
	5.2.2 힙 영역
		- 객체와 배열이 생성되는 영역
		- 힙 영역에 생성된 객체와 배열은 JVM 스택 영역의 변수나 다른 객체의 필드에서 참조한다.
		- 참조하는 변수나 필드가 없다면 의미없는 객체로 쓰레기로 취급하고
		  JVM은 Garbage Collector를 실행시켜 스레기 객체를 힙 영역에서 자동으로 제거한다
		- 객체를 제거하기위해 별도의 코드를 작성할 필요가 없고
		  자바는 코드로 객체를 직접 제거시키는 방법을 제공하지 않는다.
	
	5.2.3 스레드(JVM 스택(Stack) 영역)
		- 각 스레드마다 하나의 JVM 스택 영역이 존재한다.
		- 추가적으로 스레드를 생성하지 않았다면 main 스레드만 존재하며 JVM 스택도 하나이다.
		- JVM 스택은 메소드를 호출할 때 마다 프레임(Frame)을 추가(push)하고 메소드가 종료되면
		  해당 프레임을 제거(pop)하는 동작을 수행한다.
		- 예외 발생시 printStackTrace() 메소드로 보여주는 Stack Trace의 각 라인은 하나의 프레임을 표현한다.
		- 프레임 내부에는 로컬 변수 스택이 있다. 기본 타입 변수와 참조 타입 변수가 추가(push)되거나 제거(pop)된다.
		- 변수가 이 영역에 생성되는 시점은 초기화가 될 때, 즉 최초로 변수에 값이 저장될 때이다.
		- 변수는 선언된 블록 안에서만 스택에 존재하고 블록을 벗어나면 스택에서 제거된다.
		- 선언된 변수는 실행 순서에 따라서 스택에 생성되고 소멸된다.
		----------------------------------------------------------
		(1) char v1 = 'A';
		(2) if (v1 == 'A') {
				int v2 = 100;
				double v3 = 3.14;
			}
		(3) boolean v4 = true;
		(4) int[] scores = {10, 20, 30}
		
		  '(1)' 실행  ->   '(2)'실행    ->  '(3)' 실행	  ->    '(4)' 실행
		| stack 영역 |  | stack 영역  |	| stack 영역  |	|    stack 영역   |
		| (v1, 'A') |  | (v3, 3.14) |	| (v4, true) |	| (scores, 5번지)-|->|
		-------------  | (v2, 100 )	|	| (v1, 'A' ) |	| (  v4  , true) |	|
					   | (v1, 'A' ) |   --------------	| (  v1  ,  'A') |	|
					   --------------					------------------	|
																			|
																			|
													| 	   힙 영역 	    |	V
													| 5번지(10, 20, 30)<-|----
													---------------------
													
		----------------------------------------------------------
		
	
	5.3 참조 변수의 ==, != 연산
		- 참조 타입 변수들 간의 ==, != 연산은 동일한 객체를 참조하는지, 다를 객체를 참조하는지 알아볼 때 사용된다.
		  ( 기본 타입 변수의 ==, != 연산은 변수의 값이 같은지, 아닌지를 조사한다)
		- 참조 타입 변수의 값은 힙 영역의 객체 주소이므로 결국 주소값을 비교하는 것이 된다.
		- 동일한 주소 값을 갖고 있다는 것은 동일한 객체를 참조한다는 의미이다.
		- ==와 != 연산자로 객체를 비교하는 코드는 일반적으로 if문에서 많이 사용된다.
		 ex) if(refVar2 == refVar3){...}
		 
	
	5.4 null과 NullPointerException
		* null : 참조 타입 변수가 힙 영역의 객체를 참조하지 않는다는 뜻으로 가지는 값이다.
			   : 초기값으로 사용될 수 있다.
			   : null로 초기화된 참조 변수는 스택영영에 생성된다.
		- 참조 타입 변수가 null 값을 가지는지 확인하려면 ==, != 연산을 이용하면 된다.
		- 객체를 참조하는 변수의 경우 '변수 == null'의 연산값이 false를 도출하고 '변수 != null'의 연산값이 true를 도출한다.
		- 객체를 참조하지 않는 변수의 경우 '변수 == null'의 연산값이 true를 도출하고 '변수 != null'의 연산 값이 false를 도출한다.
		* exception(예외) : 프로그램 실행 도중에 발생하는 오류이다.
		* NullPointerException : 참조 타입 변수를 잘못 사용하는 경우 발생한다.(참조타입의 변수가 null값을 가지고 있는 경우)
		----------------------------------------------------------
		int[] intArray = null;	// 배열 타입 변수이므로 참조 타입 변수이며 null로 초기화가 가능하다.
		intArray[0] = 10;	// NullPointerException, intArray 변수가 참조하는 배열 객체가 없다.
		
		String str = null;	// 클래스 타입이므로 참조 타입이다. null로 초기화가 가능하다.
		System.out.println("총 문자수 : " + str.length());	// NullPointerException, str객체가 참조하는 String 객체가 없다.
		----------------------------------------------------------
		
		
	5.5 String 타입
		- 문자열 객체를 생성는데에는 문자열 리터럴로 생성하는 방법과 new 연산자를 사용하는 방법이 있다.
		- 문자열 리터럴로 객체를 생성하는 방법은 큰 따옴표로 감싼 문자열을 String 변수에 대입하는 방법이다.
		----------------------------------------------------------
			String str1 = "java";
			
			or
			
			String str2;
			str2 = "java";
		----------------------------------------------------------
		- 위의 경우 "java"라는 문자열 리터럴을 가진 String 객체는 heap영역에 생성되고 str1, str2 변수는 해당 객체의 주소값을 가지고 있다.
		- 자바는 위의 경우와 같이 문자열 리터럴이 동일하다면 String 객체를 공유하도록 되어있다.
		  즉, str1 과 str2 변수는 같은 객체의 주소값을 가지고있다. 
		
		- new 연산자를 사용해서 'String str3 = new String("java");'의 방식으로 객체를 생성하는 것도 가능하다.
		- new 연산자를 사용해서 객체를 만들 경우 heap영역에 "java"라는 문자열 리터럴을 가진 새로운 객체가 생성된다. 
		- str3 변수는 str1, str2와 다른 주소값을 가지게 되며 str1,2와 비교연산을 할 경우 == 연산은 false가 도출된다.
		- 객체의 주소는 다르지만 각 변수가 참조하는 객체가 가진 문자열 리터럴이 동일하기 때문에 .equals() 메소드를 사용하여
		  각 변수를 비교할 경우 true값을 리턴한다.
		
		- String 변수는 참조 타입이므로 초기값으로 null을 대입할 수 있다.(null은 변수가 참조하는 객체가 없다는 뜻이다)
		- 'str1 = "eclipse";'와 같이 객체를 참조하고 있는 변수에 'str1 = null;'와 같이 null값을 대입함으로써
		  더 이상 객체를 참조하지 않도록 할 수 있다.
		  (참조를 잃은 객체는 JVM이 실행시킨 Gabage Collector에 의해 메모리에서 제거된다)
		  
		  
	5.6 배열 타입
	5.6.1 배열이란?
		* 배열 : 같은 타입의 데이터를 연속된 공간에 나열시키고, 각 데이터에 인덱스(index)를 부여해 놓은 자료구조이다.
		* 인덱스 : 각 항목의 데이터를 읽거나, 저장하는데 사용한다. 배열 이름 옆 대괄호[]에 기입한다. ex) 배열이름[1]
		- 배열을 사용하면 같은 타입의 많은 양의 데이터를 효율적으로 가공할 수 있다. 
		- 배열은 선언과 동시에 저장할 수 있는 데이터 타입이 결정된다.
		* 타입 불일치(Type mismatch) 컴파일 오류 : 배열 선언시 결정한 데이터 타입과 배열에 저장하려는 데이터 타입이 다를 경우 발생한다.
		- 한번 생성된 배열은 길이를 늘리거나 줄일 수 없다.
	
	5.6.2 배열 선언
		- 배열 변수 선언은 '타입[] 변수;', '타입 변수[];'의 두가지 형태로 작성할 수 있다.
		- 대괄호[]는 배열 변수를 선언하는 기호로 사용한다. 타입 뒤에 붙거나 변수 뒤에 붙는다.
		- 타입은 배열에 저장될 데이터의 타입을 말한다.
		----------------------------------------------------------
		int[] intArray;				int intArray[];
		double[] doubleArray; 		double doubleArray[];
		String[] strArray;			String strArray[];
		----------------------------------------------------------
		- 배열 변수는 참조변수에 속한다. 배열도 객체이므로 힙 영역에 생성되고 배열 변수는 힙 영역의 배열 객체를 참조하게 된다.
		- 참조할 배열 객체가 없다면 배열 변수는 null 값으로 초기화 될 수 있다.	ex) 타입[] 변수 = null;
		- 만약 배열 변수가 null 값을 가진 상태에서 변수[인덱스]로 값을 읽거나 저장하게 되면 NullPointerException이 발생한다.
		- 배열 변수는 배열을 생성하고 참조하는 상태에서 값을 저장하거나 읽어야 한다.
		
	5.6.3 값 목록으로 배열 생성
		- 배열 항목에 저장될 값의 목록이 있다면 '데이터타입[] 변수 = {값0, 값1, 값2, 값3, ...};'의 형식으로 배열 객체를 만들 수 있다.
		- 중괄호{}는 주어진 값들을 항목으로 가지는 배열 객체를 힙에 생성하고 배열 객체의 번지를 리턴한다.
		- 배열 변수는 리턴된 번지를 저장함으로써 참조가 이루어진다.
		- "값0"은 변수[0], "값1"은 변수[1], "값2"는 변수[2]로 읽을 수 있다.
		- 변수[0]의 "값0"을 "값00"으로 바꾸고 싶다면 '변수[0] = "값00"'의 형식으로 대입 연산자를 사용하면 된다.
		- '타입[] 변수;', '변수 = {값0, 값1, 값2, ...}'와 같이 배열 변수를 이미 선언한 후에
		  다른 실행문에서 중괄호를 사용한 배열 생성은 허용되지 않는다. (컴파일 에러 발생)
		- 배열 변수를 미리 선언한 후, 값 목록들이 나중에 결정되는 상황이라면 '변수 = new 타입[] {값0, 값1, 값2, ...};'과 같이
		  new 연산자를 사용해서 값 목록을 지정해주면 된다.
		- 값 목록으로 배열을 생성함과 동시에 메소드의 매개값으로 사용하고자 할 때에도 '리턴타입 메소드이름(배열타입[] 배열이름){...}',
		  '변수타입 변수이름 = 메소드이름(new 배열타입[] {값0, 값1, 값2, ...};와 같이 new연산자를 사용해야 한다.
		  
	5.6.4 new 연산자로 배열 생성
		- 값의 목록을 가지고 있지 않지만, 향후 값들을 저장할 배열을 미리 만들고 싶다면 new 연산자로 다음과 같이 배열 객체를 생성할 수 있다.
		----------------------------------------------------------
			타입[] 변수 = new 타입[길이];
		---------------------------------------------------------- 
		- 길이는 배열이 저장할 수 있는 값의 수를 말한다.
		- new 연산자로 배열을 생성할 경우에는 이미 배열변수가 선언된 후에도 가능하다.
		- new 연산자로 배열을 처음 생성할 경우, 배열은 자동적으로 기본값으로 초기화된다. (int -> 0, String -> null)
		----------------------------------------------------------
			타입[] 변수 = null;
			변수 = new 타입[길이];
			
			// 자바는 intArray[0] ~ intArray[4]까지 저장할 수 있는 공간을 확보하고, 배열의 생성 번지를 리턴한다.
			// 리턴된 번지는 intArray 변수에 저장된다.
			int[] intArray = new int[5];	
			
			| stack Area |				| 								heap Area	   						 |
			|  intArray -|--------------|-> intArray[0](4byte), intArray[1](4byte), ... , intArray[4](4byte) |
			
			intArray[n] : 00000000(1byte) 00000000 00000000 00000000 
		----------------------------------------------------------
		- 다음은 타입 별로 배열의 초기값을 보여준다
		----------------------------------------------------------
			분류				데이터 타입					초기값
			기본타입(정수)		byte[]						0
							char[]						'\u0000'
							short[]						0
							int[]						0
							long[]						0L
			기본타입(실수)		float[]						0.0F
							double[]					0.0
			기본타입(논리)		boolean[]					false
			참조타입			클래스[]						null
							인터페이스[]					null
		----------------------------------------------------------
		- 배열이 생성되고 나서 새로운 값을 저장하려면 대입 연산자를 사용하면 된다.
		----------------------------------------------------------
			변수[인덱스] = 값;
			
			int[] scores = new int[3];
			scores[0] = 83;
			scores[1] = 90;
			scores[2] = 75;
		----------------------------------------------------------
		
	5.6.5 배열 길이
		- 배열에 저장할 수 있는 전체 항목 수
		* 배열변수.length : 배열 객체의 length 필드를 읽는 메서드
		* 필드 : 객체 내부의 데이터
		- 배열의 length필드는 for문을 사용해서 배열 전체를 루핑할 때 유용하다.
		- 배열의 마지막 인덱스는 배열 길이보다 1이 적으므로 for문의 조건식에서 < 연산자를 사용한다.
		* ArrayIndexOutOfBoundsException : 인덱스를 초과해서 배열을 사용할 경수 발생하는 에러
		----------------------------------------------------------
			int[] intArray = { 10, 20, 30 };
			int num = intArray.length;	// num에는 3이 저장된다.
			
			int[] scores = { 83, 90, 87 };
			int sum  = 0;
			for(int i = 0; i < scores.length; i++) {
				sum += scores[i];
			}
			System.out.println("총합 : " + sum);		// sum에는 260이 저장되어있다.
			
			double avg = (double) sum / scores.length;	// 260을 3으로 나눈다
			System.out.println("평균 : " + avg);	 // avg는 86.66...
		----------------------------------------------------------
	
	5.6.6 커맨드 라인 입력
		* String[] args : main() 메소드의 매개값
		- 명령 프롬프트에서 "java 클래스"로 프로그램을 실행하면 JVM은 길이가 0인 String 배열을 먼저 생성하고
		  main() 메소드를 호출할 때 매개값으로 전달한다.
		- "java 클래스 문자열0 문자열1 문자열2 ... 문자열n-1" 과 같이
		  "java 클래스" 뒤에 공백으로 구분된 문자열 목록을 주고 실행하면,
		  문자열 목록으로 구성된 String[] 배열이 생성되고 main() 메소드를 호출할 때 
		  매개값으로 전달된다.
		- main() 메소드는 String[] args 매개변수를 통해서 커맨드 라인에서 입력된 데이터의 수(배열의 길이)와
		  입력된 데이터(배열의 항목 값)을 알 수 있게 된다.
		----------------------------------------------------------
			String[] args = {문자열0, 문자열1, 문자열2, ... 문자열n-1};  
					  | 	
		  			  V	
		 			  ------------------------>|	
						main() 메소드 호출시 전달  |
											   V
			public static void main(String[] args){
				...
			}
		----------------------------------------------------------
		* 이클립스에서 프로그램을 실행할 때 매개값을 주고 실행하는 방법
			[Menu -> Run -> Run Configurations -> Main -> Project -> Main Class
			-> Arguments -> Program arguments] '문자열0 문자열1 ... 문자열n-1'을 입력하고 [Apply -> Run]을 클릭한다.
			이는 명령 프롬프트에서 'java 클래스명 문자열0 문자열1 ... 문자열n-1'로 실행하는 것과 동일하다.
			이렇게 실행하면 args는 { 문자열0, 문자열1, ... , 문자열n-1 } 배열을 참조하게 되고
			args[0]은 문자열0, args[1]은 문자열1, args[n-1]은 문자열n-1을 얻을 수 있다.
		
		* Integer.parseInt() : 매개 변수에 정수로 변환 가능한 문자열이 저장되어있을 경우 매개변수를 정수로 변환한 후 저장한다.
		* NumberFornetException 실행 예외 : Integer.parseInt() 메소드의 매개변수에 정수로 변환 할 수 없는 데이터가 저장되어 있을 경우
	
	5.6.7 다차원 배열
		* 2차원 배열 : 행과 열로서 구성된 배열
				   : 가로 인덱스와 세로 인덱스를 사용한다
				   : 중첩 배열 방식으로 구현한다
				   ----------------------------------------------------------
						int[][] scores = new int[2][3];
						 
						위의 코드는 메모리에 세 개의 배열 객체를 생성한다(int[] A, int[] B, int[] C)
						배열 변수인 scores 는 길이가 2인 배열 A객체를 참조한다.
						배열 A객체의 0번 인덱스 즉, scores[0]은 배열 B객체를 참조한다.
						배열 A객체의 1번 인덱스 즉, scores[1]은 배열 C객체를 참조한다.
						 
						각 배열의 길이는 다음과 같이 얻을 수 있다.
						scores.length		// 2(배열 A의 길이)
						scores[0].length	// 3(배열 B의 길이)
						scores[1].length	// 3(배열 C의 길이)
						 
						scores[0][1] = 배열 B의 인덱스 1 값
						scores[1][0] = 배열 C의 인덱스 0 값
				   ----------------------------------------------------------
				   : 자바 배열은 계단식 구조를 가질 수 있다.
				   ----------------------------------------------------------
				   		int[][] scores = new int[2][];
				   		scores[0] = new int[2];		// 0  1
				   		scores[1] = new int[3];		// 0  1  2
				   		
				   		위의 코드는
				   		길이 2의 int 타입 배열A, 길이 2의 int 타입 배열B, 길이 3의 int타입 배열C를 생성한다.
				   		배열 A의 인덱스 0은 배열B를 참조하고 인덱스 1은 배열C를 참조한다.
				   	----------------------------------------------------------	
				   	* ArrayIndexOutOfBoundsException : 배열 길이를 초과하여 사용할 경우 발생
				    - 그룹화된 값 목록을 가지고 있다면 중괄호 안에 다시 중괄호를 사용해서 값 목록을 나열할 수 있다.
				    ----------------------------------------------------------
				    	타입[][] 변수 = { { 값1, 값2, ... }, { 값3, 값4, ... } };
				    	
				    	타입 변수명 = 배열변수명[0][0];		// 값1
				    	타입 변수명 = 배열변수명[1][1];		// 값4 	 
				    ----------------------------------------------------------
	
	5.6.8 객체를 참조하는 배열
		- 참조 타입 배열은 각 항목에 문자열이 아니라 참조 타입 객체의 주소를 가지고 있다. 즉, 객체를 참조하게 된다.
		----------------------------------------------------------
			String[] strArray = new String[3];
			strArray[0] = "Java";
			strArray[1] = "C++";
			strArray[2] = "C#";
			
			위의 코드는 String 배열 객체 하나와 String 객체 3개를 생성한다.
			String 배열의 각 인덱스는 String 객체의 주소값을 참조한다.
		----------------------------------------------------------	
		- String 배열의 각 항목 값을 비교할 때는 == 연산자 대신 .equal() 메소드를 사용해야 한다.
		
	5.6.9 배열 복사
		- 배열은 한 번 생성하면 크기를 변경할 수 없기 때문에 더 많은 저장 공간이 필요하다면 보다 큰 배열을 새로 만들고
		  이전 배열로부터 항목 값들을 복사해야 한다.
		- 배열 간의 항목 값들을 복사하려면 for문을 사용하거나 System.arraycopy() 메소드를 사용하면 된다.
		  참고) ArrayCopyByForExample.java
		- System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length);
			: src = 원본 배열
			: srcPos = 원본 배열에서 복사할 항목의 시작 인덱스
			: dest = 새 배열
			: destPos = 새 배열에서 붙여넣을 시작 인덱스
			: length = 복사할 개수
		  참고) ArraycopyExample.java 
		- 큰 배열에 작을 배열을 복사하면 복사되지 않은 인덱스의 저장공간에는 초기값이 유지된다.
		  ex) int[] -> 0, String[] -> null
		* 얕은 복사(shallow copy) : 참조 타입 배열을 복사할 경우 객체의 번지를 복사하여
								  새 배열의 항목은 이전 배열의 항목이 참조하는 객체와 동일한 것
		* 깊은 복사(deep copy) : 새 배열이 참조한는 객체를 별도로 생성한다.
	
	5.6.10 향상된 for문
		- 배열 및 컬렉션 객체를 좀 더 쉽게 처리할 목적으로 제공하는 for문(java 5부터)
		- 반복 실행을 위해 카운터 변수와 증감식을 사용하지 않는다.
		- 배열 및 컬렉션 항목의 개수만큼 반복하고 자동적으로 for문을 빠져나간다.
		- for문의 반복 횟수는 배열의 항목 수 가 된다.
		참고) AdvancedForexample.java
		----------------------------------------------------------
			for( 타입 변수 : 배열 ) {
				실행문;
			}
			
			타입 변수 = 배열에서 꺼낸 항목을 저장할 변수
			배열 = 가져올 데이터를 가지고 있는 배열
			
			for -> 배열에서 가져올 첫번째 값이 존재하는지 평가 -> 값이 존재할 경우 해당 값을 변수에 저장
			-> 실행문 실행 -> 루프롤 돌아 배열에서 가져올 다음 값이 존재하는지 평가 -> 존재할 경우 루프를 반복
			
			for -> 배열에서 가져올 다음 값(or 첫번째 값)이 없으면 for문 종료
		----------------------------------------------------------	
			 
	
	5.7 열거 타입(enumeration type)
		- 한정된 값만을 갖는 데이터 타입
		- 몇 개의 열거 상수(enumeration constant) 중에서 하나의 상수를 저장하는 데이터 타입이다.
	 
	5.7.1 열거 타입 선언
		* 열거 타입(.java) : 열거 객체를 만드는 틀, 열거 상수 수 만큼의 열거 객체를 생성한다.
			ex) Week.java(열거 타입, 7개의 열거 상수를 가진다) -> 7개의 객체를 생성한다.
		- 열거 타입의 이름을 정하고 열거 타입 이름으로 소스 파일(.java)을 생성한다.
		- 열거 타입 이름은 관례적으로 첫 문자를 대문자로 하고 나머지는 소문자로 구성한다.
		- 여러 단어로 구성된 이름이라면 단어 첫 문자는 대문자로 하는 것이 관례이다.
			ex) Week.java, Membergrade.java, ProductKind.java
		- 소스 파일의 내용에 열거 타입 선언
			'public enum' : 열거 타입을 선언하기 위한 키워드, 소문자로 작성해야 한다.
		- 소스 파일의 내용에 선언한 열거 타입 이름은 파일명과 대소문자가 일치해야 한다.
		* 열거 상수 : 열거 타입의 값, 관례적으로 모두 대문자로 작성한다.
				  : 열거 상수가 여러 단어로 구성될 경우 단어 사이를 밑줄(_)로 연결하는 것이 관례이다.
		- 열거 타입 생성 순서
			[Package Explorer View - project - 메뉴 - File - New - Enum]
			-> [New Enum Type - Package(패키지명 입력) - Name(열거 타입 이름 입력) - Finish]
			-> 열거 상수 작성
		참고) Week.java
		
	5.7.2 열거 타입 변수
		* 열거 타입 변수 : stack영역에 생성, '열거타입.열거상수'로부터 열거 객체의 주소값을 받아 저장한다.
		* 열거타입.열거상수 : method영역에 생성, 열거 객체의 주소값을 저장한다.
		- 열거 타입도 하나의 데이터 타입이므로 변수를 선언하고 사용해야 한다.
			ex) 열거타입 변수;, Week today;, Week reservationDay;
		- 열거 타입 변수에 열거 상수를 저장할 수 있다.
		- 열거 상수 단독으로 사용할 수 없고 반드시 '열거타입.열거상수;'로 사용한다.
			ex) Week today = Week.SUNDAY;
		- 열거 타입 변수에는 null값을 저장할 수 있다.(열거 타입도 참조 타입 이므로)
		- 열거 상수는 열거 객체로 생성된다.(열거 상수는 열거 객체를 참조한다.)
		- 메소드 영역에 생성된 열거 상수가 해당 열거 객체를 각각 참조하게 된다.
		- '타입 변수 = 열거타입.열거상수;' : 변수는 스택영역에 생성된다 해당 변수에는 메소드영역에 있는 열거상수의 참조값
									   즉, 열거 객체의 주소값을 저장한다.
		ex) 'today == Week.SUNDAY;'의 연산 결과는 true가 된다.
		----------------------------------------------------------
			Week week1 = Week.SATURDAY;
			Week week2 = Week.SATURDAY;	
			System.out.println( week1 == week2 );	// true
		----------------------------------------------------------
		
		- 자바는 컴퓨터의 날짜 및 요일, 시간을 프로그램에서 사용할 수 있도록 하기 위해 Date, Calendar, LocalDateTime 등의
		  클래스를 제공한다.(LocalDateTime은 자바8부터 지원하는 API이다)
		- Calendar를 이용해 날짜와 시간 얻기
		----------------------------------------------------------
			// Calendar 변수를 선언하고 calendar.getInstance() 메소드가 리턴하는 Calendar객체를 얻는다.
			Calender now = Calendar.getinstance();
			
			// get() 메소드를 이용해 년, 월, 일, 요일, 시간, 분, 초를 얻는다.
			int year = now.get(Calendar.YEAR);			// 년
			int month = now.get(Calendar.MONTH);		// 월(1~12)
			int day = now.get(Calendar.DAY_OF_MONTH);	// 일
			int week = now.get(Calendar.DAY_OF_WEEK);	// 요일
			int hour = now.get(Calendar.HOUR);			// 시간
			int minute = now.get(Calendar.MINUTE);		// 분
			int secount = now.get(Calendar.SECOUND);	// 초
		----------------------------------------------------------
		- 오늘의 요일을 얻고 나서 열거 타입 변수 today에 해당 열거 상수를 대입하는 예제
			참고) EnumWeekExample.java
			
	5.7.3 열거 객체의 메소드
		- 열거 객체는 열거 상수의 문자열을 내부 데이터로 가지고 있다.
		- 열거 객체의 메소드는 java.lang.Enum 클래스에 선언되어있다.
		- 모든 열거 타입은 컴파일 시에 Enum 클래스를 상속하므로 메소드를 사용할 수 있다.
		----------------------------------------------------------
			리턴타입		메소드(매개 변수)			설명
			String		name()					열거 객체의 문자열을 리턴한다.
			int			ordinal()				열거 객체의 순번(0부터 시작)을 리턴한다.
			int			compareTo()				열거 객체를 비교해서 순번 차이를 리턴한다.
			열거 타입		valueOf(String name)	주어진 문자열의 열거 객체를 리턴한다.
			열거 배열		values()				모든 열거 객체들을 배열로 리턴한다.
		----------------------------------------------------------
		
		1) name() 메소드
			- 열거 객체가 가지고 있는 문자열을 리턴한다.
			- 리턴되는 문자열은 열거 타입을 정의할 때 사용한 상수 이름과 동일하다.
			----------------------------------------------------------
				Week today = Week.SUNDAY;
				String name = today.name();		// SUNDAY를 리턴하고 name변수에 저장
			----------------------------------------------------------
		
		2) ordinal() 메소드
			- 전체 열거 객체 중 몇 번째 열거 객체인지 알려준다.
			- 열거 객체의 순분은 열거 타입을 정의할 때 주어진 순번을 말한다. (0번 부터 시작한다)
			----------------------------------------------------------
				Week today = Week.SUNDAY;	// 열거 상수 SUNDAY는 7번째로 선언하였다.
				int ordinal = today.ordinal();	// 숫자 6을 리턴하고(0번 부터 시작하므로) ordinal변수에 저장한다
			----------------------------------------------------------
			
		3) comapreTo() 메소드
			- 매개값으로 주어진 열거 객체를 기준으로 전후로 몇 번째 위치하는지를 비교한다.
			- 만약 열거 객체가 배개값의 열거 객체보다 순번이 빠르다면 음수가, 순번이 늦다면 양수가 리턴된다.
			----------------------------------------------------------
				Week day1 = Week.MONDAY;
				Week day2 = Week.WEDNESDAY;
				int result1 = day1.compareTo(day2);	// -2
				int result2 = day2.compareTo(day1);	//	2
			----------------------------------------------------------
			
		4) valueOf() 메소드
			- 매개값으로 주어지는 문자열과 동일한 문자열을 가지는 열거 객체를 리턴한다.
			- 외부로부터 문자열을 입력받아 열거 객체로 변환할 때 유용하게 사용할 수 있다.
			----------------------------------------------------------
				Week weekDay = Week.valueOf("SATURDAY");
				weekDay 변수는 Week.SATURDAY 열거 객체를 참조하게된다.
			----------------------------------------------------------
			
		5) values() 메소드
			- 열거 타입의 모든 열거 객체들을 배열로 만들어 리턴한다.
			- 즉, 힙 영역에 각 열거 객체들의 주소값을 저장하는(각 객체를 참조하는) 배열 객체를 만들고
			  배열 객체의 주소값을 리턴하여 열거 타입 배열 변수에 저장한다.
			----------------------------------------------------------
				Week[] days = Week.values();
				for(Week day : days){
					System.out.println(day); 
				}
			----------------------------------------------------------
			참조) EnumMethodExample.java