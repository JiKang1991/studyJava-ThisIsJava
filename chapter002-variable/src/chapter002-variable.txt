	chapter002 variable
	
	-- Table of contents --
		2.1 변수
		2.2 데이터 타입
		2.3 타입 변환
	-----------------------
	
	2.1 변수
	2.1.1 변수란?
		* 변수 : 하나의 값을 저장할 수 있는 메모리의 공간
		- 프로그램은 작업을 처리하는 과정에서 필요에 따라 데이터를 메모리에 저장할 때 변수를 사용한다.
		- 변수의 값은 프로그램에 의해서 수시로 값이 변동될 수 있다.
		- 하나의 값만 저장할 수 있다(복수개의 값을 저장 할 수 없다)
		- 한가지 타입의 값만 저장할 수 있다.
		
	2.1.2 변수의 선언
		- 변수를 사용하기 위해서는 먼저 변수를 선언해야 한다.
		* 변수 선언 : 데이터의 타입과 변수의 이름을 결정하는 것.
		----------------------------------------------------------
		타입		변수이름
		int		age;	// 정수(int)값을 저장할 수 있는 age 변수 선언
		double	value;	// 실수(double)값을 저장할 수 있는 value 변수 선언
		
		int x, y, z;	// 같은 타입의 변수는 콤마(,)를 이용해서 한꺼번에 선언할 수도 있다.
		----------------------------------------------------------
		* 타입 : 변수에 저장되는 값의 종류와 범위를 결정짓는 요소
		* 변수 이름 : 메모리 주소에 붙여진 이름, 프로그램은 변수 이름을 통해서 메모리 주소에 접근하고
					그것에 값을 저장하거나 그곳에 있는 값을 읽는다.
					자바 언어에서 정한 명명규칙(nameing convention)을 따라야한다.
					* 명명규칙
						(1) 첫 번째 글자는 문자이거나 '$', '_'이어야 하고 숫자로 싲가할 수 없다.
						(2) 영어 대소문자가 구분된다.
						(3) 첫 문자는 영어 소문자로 시작하되, 다른 단어가 붙을 경우 첫 문자를 대문자로 한다.
						(4) 문자 수(길이)의 제한은 없다.
						(5) 자바 예약어는 사용할 수 없다.
	
	2.1.3 변수의 사용
		* 변수의 사용 : 변수에 값을 저장하고 읽는 행위
		1) 변수값 저장
			- 대입 연산자(=)를 사용한다.
			* 대입 연산자 : 우측의 값을 좌측 변수에 저장한다는 의미를 갖는다.
			* 초기값 : 변수를 선언하고 처음 지정하는 값
			* 초기화 : 변수에 초기값을 주는 행위
			----------------------------------------------------------
			int score;	// 변수 선언
			score = 90;	// 값 저장
			
			int score = 90; // 선언과 동시에 초기값 부여도 가능하다.
			----------------------------------------------------------
			* 리터럴(literal)
				: 소스 코드 내에서 직접 입력된 값
				: 상수(constant)와 같은 의미지만, 프로그램에서는 상수를 "값을 한 번 저장하면 변경할 수 없는 변수"로 정의하기 때문에
				  이와 구분하기 위해 "리터럴"이라는 용어를 사용한다.
				- 정수 리터럴
					(1) 소수점이 없는 정수리터럴은 10진수로 간주한다. ex) 0, 75, -100
					(2) 0으로 시작되는 리터럴은 8진수로 간주한다. ex) 02, -04
					(3) 0x 또는 0X로 시작하고 0~9 숫자나 A, B, C, D, E, F 또는 a, b, c, d, e, f로 구성된 리터럴은 16진수로 간주한다.
						ex) 0x5, 0xA, 0xB3, 0xAC08
					- byte, char, short, int, long
				- 실수 리터럴
					(1) 소수점이 있는 리터럴은 10진수 실수로 간주한다. ex) 0.25, -3.14
					(2) 대문자 E또는 소문자 e가 있는 리터럴은 10진수 지수와 가수로 간주한다.	ex) 5E7, 0.12E-5
					- float, double
				- 문자 리터럴
					(1) 작은 따옴표(')로 묶은 텍스트는 하나의 문자 리터럴로 간주한다. ex) 'A', '한', '\t', '\n'
					(2) 역슬래쉬(\)가 붙은 문자 리터럴은 이스케이프(escape)문자라고도 하는데 특수한 용도로 사용된다.
					----------------------------------------------------------
					이스케이프 문자		용도						유니코드
					'\t'			수평 탭					0x0009
					'\n'			줄 바꿈					0x000a
					'\r'			리턴						0x000d
					'\"'			"(큰 따옴표)				0x0022
					'\''			'(작은 따옴표)				0x0027
					'\\'			\						0x005c
					'\u16진수'		16진수에 해당하는 유니코드	0x0000 ~ 0xffff
					----------------------------------------------------------
					- char
				- 문자열 리터럴
					- 큰 따옴표(")로 묶은 텍스트는 문자열 리터럴로 간주한다.
					- 큰 따옴표 안에는 텍스트가 없어도 문자열 리터럴로 간주된다.
					- 문자열 리터럴 내부에서도 이스케이프 문자를 사용할 수 있다.
					ex) "대한민국"	"탭 만큼 이동 \t 합니다."	"한 줄 내려 쓰기 \n 합니다."
					- String
				- 논리 리터럴
					- true, false
					- boolean
			
			2) 변수값 읽기
				- 변수는 초기화가 되어야 읽을 수 있다.
				----------------------------------------------------------
				int value;					// 변수 value 선언(초기화 안 됨)
				int result = value + 10;	// 변수 value 값을 읽고 10을 더한 결과값을 변수 result에 저장 (컴파일 에러 발생)
				
				int value;					// 변수 value가 30으로 초기화됨
				int result = value + 10;	// 변수 value 값을 읽고 10을 더한 결과값(40)을 변수 result에 저장 (ok)
				----------------------------------------------------------
				
	2.1.4 변수의 사용 범위
		- 변수는 중괄호 '{}' 블록 내에서 선언되고 사용된다.
		- 중괄호 블록을 사용하는 곳은 클래스, 생성자, 메소드이다.
		- 메소드 블록 내에서 선언된 변수를 특히 로컬 변수(local variable)라고 부른다
		- 로컬 변수는 메소드 실행이 끝나면 메모리에서 자동으로 없어진다.
		----------------------------------------------------------
		public class VariableExample { // 클래스 블록 시작
			public static void main(String[] args){ // 메소드 블록 시작
				// 변수(로컬 변수) 선언 및 초기값 저장
			} // 메소드 블록 끝
		} // 클래스 블록 끝
		----------------------------------------------------------
		- 변수는 선언된 블록 내에서만 사용이 가능하다.
		- 메소드 블록 내에서도 제어문(if(){}, for(){}, while(){} 등)이 중괄호를 가질 수 있다.
		- 제어문 블록 내에서 선언된 변순느 해당 제어문 블록 내에서만 사용이 가능하다.
		----------------------------------------------------------
		public static void main(String[] args){ // 메소드 블록 시작
			int var1;	// 메소드 블록에서 선언
			
			if(){ // if 조건문 블록 시작
				int var2;	// if 조건문 블록에서 선언
				// var1, var2 사용가능
			} // if 조건문 블록 끝
				
			for(){ // for 반복문 블록 시작
				int var3;	// for 반복문 블록에서 선언
				// var1, var3 사용가능
				// var2 사용 불가
			} // for 반복문 블록 끝
				
			// var1 사용가능
			// var2, var3 사용 불가
		} // 메소드 블록 끝
		----------------------------------------------------------		
	
	
	2.2 데이터 타입
		- 모든 변수에는 타입이 있다.
		- 타입에 따라 저장할 수 있는 값의 종류와 범위가 달라진다.
		- 변수를 선언할 때 주어진 타입은 변수를 사용하는 도중에 변경할 수 없다.
		
	2.2.1 기본(원시: primitive)타입
		* 기본(원시) 타입 : 정수, 실수, 문자, 논리 리터럴을 직접 저장하는 타입
		----------------------------------------------------------
		값의 종류		기본 타입		메모리 사용 크기		저장되는 값의 범위
		정수			byte		1byte	8bit		-2^7 ~ (2^7 - 1) (-128 ~ 127)
					char		2byte	16bit		0 ~ (2^16 - 1) (유니코드 : \u0000 ~ \uFFFF, 0 ~ 65535)
					short		2byte	16bit		-2^15 ~ (2^15 - 1) (-32,768 ~ 32,767)
					int			4byte 	32bit		-2^31 ~ (2^31 - 1) (-2,147,483,648 ~ 2,147,483,647)
					long		8byte	64bit		-2^63 ~ (2^63 - 1)
		실수			float		4byte	32bit		(+/-)1.4E - 45 ~ (+/-)3.4028235E38
					double		8byte	64bit		(+/-)4.9E - 324 ~ (+/-)1.7976931348623157E308
		논리			boolean		1byte	8bit		true, false
		----------------------------------------------------------
		- 정수타입일 경우 -2^(n-1) ~ (2^(n-1) - 1)의 값을 저장한다. (n은 메모리 사용크기(bit 수)이다.)
		
	2.2.2 정수타입(byte, char, short, int, long)
		----------------------------------------------------------
		정수 타입		byte	char	short	int		long
		바이트 수		1		2		2		4		8
		----------------------------------------------------------
		- 자바는 기본적으로 정수 연산을 int타입으로 수행한다
		
		1) byte 타입
			- 색상 정보 및 파일 또는 이미지 등의 이진(바이너리) 데이터를 처리할 때 주로 사용된다.
			- 표현할 수 있는 값의 범위는 -128 ~ -127 (-2^7 ~ (2^7 - 1))이다.
			- 범위를 초과하는 값이 저장될 경우 컴파일 에러("Type mismatch: cannot convert form int to byte)가 발생한다.
			----------------------------------------------------------
			이진수				십진수
			(좌측 첫번째 비트는 최상위 비트이다.)
			01111111			127
			01111110			126
			...					...
			00000001			1
			00000000			0
			11111111			-1
			11111110			-2
			...					...
			10000001			-127
			10000000			-128
			----------------------------------------------------------
			- 최상위 비트(MSB: Most Significant Bit)는 정수값의 부호를 결정한다.
			- 최상의 비트가 0이면 양의 정수, 1이면 음의 정수를 뜻한다.
			- 실제 정수값은 나머지 7개의 bit로 결정된다
			- 최상위 비트가 1인 음수의 경우에는 나머지 7개의 bit를 모두 1의 보수(1은 0으로, 0은 1로)로 바꾸고
			  1을 더한 값에 -를 붙여주면 10진수가 된다.
			- 코드에서 정상적으로 변수에 올바른 값을 저장하더라도 프로그램이 실행하는 도중에 변수의 값은 변경된다.
			  만약 실행중에 저장할 수 있는 값의 범위를 초과하면 최소값부터 다시 반복 저장되는데 byte일 경우
			  -128(최소값)부터 시작해서 127(최대값)을 넘으면 다시 -128부터 시작하게 된다.
			* 쓰레기값 : 저장할 수 있는 값의 범위를 초과해서 값이 저장된 경우
		2) char 타입
			* 유니코드(Unicode)
				: 세계 각국의 문자들을 코드값으로 매핑한 국제 표준 규약이다.
				: 하나의 문자에 대해 하나의 코드값을 부여한다.
				: 0 ~ 65535 범위의 2byte 크기를 가진 정수값이다.
				: 0 ~ 127까지는 아스키(ASCII) 문자(특수기호 및 영어 알파벳)가 할당되어있다.
				: 44032 ~ 55203까지는 한글 11172자가 할당되어있다.
			- 자바는 모든 문자를 유니코드로 처리한다.
			- 하나의 유니코드를 저장하기 위해 2byte 크기인 char타입을 제공한다.
			- 유니코드에는 음수가 없기 때문에 char타입의 변수에는 음수 값을 저장할 수 없다.
			- char 타입에 저장할 수 있는 값은 0 ~ 65535까지 2^16개 이다.
			- char 타입 변수에 작은 따옴표(')로 감싼 문자를 대입하면 해당 문자의 유니코드가 저장된다.
			----------------------------------------------------------
			char var1 = 'A';	// 유니코드 : 0x0041 -> 2진수 : 00000000 01000001
			char var2 = 'B';	// 유니코드 : 0x0042 -> 2진수 : 00000000 01000010
			char var3 = '가';	// 유니코드 : 0xAC00 -> 2진수 : 10101100 00000000
			char var4 = '각';	// 유니코드 : 0xAC01 -> 2진수 : 10101100 00000001
			----------------------------------------------------------
			- char 변수에 작은 따옴표(')로 감싼 문자가 아니라 직접 유니코드 정수값을 저장할 수도 있다.
			----------------------------------------------------------
			char c = 'A';	// A는 65(10진수), 0x41(16진수)이다.
			char c = 65;
			char c = '\u0041';
			----------------------------------------------------------
			- 프로그램 코드에서 char 변수에 저장된 유니코드를 알고 싶다면 char 타입 변수를 int 타입 변수에 저장하면 된다.
			----------------------------------------------------------
			char c = 'A';
			int uniCode = c;
			----------------------------------------------------------
			- char 타입 변수는 단 하나의 문자만 저장한다. 문자열을 저장하고 싶다면 String 타입을 사용해야 한다.
			- char 타입 변수에 어떤 문자를 대입하지 않고 단순히 초기화를 할 목적으로
			  작은 따옴표(') 두 개를 연달아 붙인 빈(empty) 문자를 대입하면 컴파일 에러가 발생한다.
			  공백(유니코드 : 32) 하나를 포함해서 초기화 하면 된다.
			  ----------------------------------------------------------
			  char c = ''; // 컴파일 에러
			  char c = ' '; // ok
			  ----------------------------------------------------------
		3) short 타입
			- 2byte(16bit)로 표현되는 정수값을 저장할 수 있다.
			- c언어와의 호환을 위해 사용되며 비교적 자바에서는 잘 사용되지 않는다.
		4) int 타입
			- 4byte(32bit)로 표현되는 정수값을 저장할 수 있다.
			- 정수를 연산하기 위한 기본타입(자바에서는 정수 연산을 4byte로 처리한다)
			- 정수를 저장할 때는 일반적으로 int타입을 사용한다.
			- 코드에서 정수값을 직접 입력할 경우 8진수, 10진수, 16진수를 사용할 수 있다. 어떤 진수로 입력하더라도 동일한 값의 2진수로 저장된다.
		5) long 타입
			- 8byte(64bit)로 표현되는 정수값을 저장할 수 있다.
			- 초기화 할때 정수값 뒤에 소문자 'l'이나 대문자 'L'을 붙일 수 있다.
			- int 타입의 범위를 넘어가는 큰 정수는 반드시 'l'이나 'L'을 붙여야 한다. 그렇지 않으면 컴파일 에러가 발생한다.
			
	2.2.3 실수타입(float, double)
		- 소수점이 있는 실수 데이터를 저장할 수 있는 타입
		----------------------------------------------------------
		실수 타입		float	bouble
		바이트 수		4		8
		----------------------------------------------------------
		- 정수 타입보다 훨 씬 더 큰 범위의 값을 저장할 수 있다.
		- 부동 소수점(floting-point) 방식으로 저장된다.
		* 부동 소수점 방식 : (부호) (가수) * 10^(지수)
			- 가수 : 0 <= 가수 < 1 범위의 실수
			ex) 1.2345 -> 0.12345 * 10^1
		- float : 부호(1bit) + 지수(8bit) + 가수(23bit) = 32bit = 4byte
		- double : 부호(1bit) + 지수(11bit) + 가수(52bit) = 64bit = 8byte
		- 자바는 실수 리터럴의 기본 타입을 double로 간주한다.
		- 실수 리터럴을 float 타입 변수에 저장하려면 리터럴 뒤에 소문자 'f'나 대문자 'F'를 붙여야한다.
		----------------------------------------------------------
		double var1 = 3.14;
		float var2 = 3.14;	// 컴파일 에러(Type missmatch: cannot convert from double to flaot)
		float var3 = 3.14F;
		----------------------------------------------------------
		- 정수 리터럴에 10의 지수를 나타내는 E 또는 e를 포함하고 있으면 정수 타입 변수에 저장할 수 없고 실수 타입에 저장해야 한다.
		----------------------------------------------------------
		int var6 = 3000000;		// 3000000
		double var7 = 3e6;		// 3000000 
		float var8 = 3e6f;		// 3000000
		double var9 = 2e-3		// 0.002
		----------------------------------------------------------
		- double 타입의 가수 bit 수가 float 타입의 가수  bit 수보다 약 두 배 정도 크기때문에
		  double 타입이 float타입보다 두 배 이상 정밀하다.
		  
	2.2.4 논리타입(boolean)
		- 1byte(8bit)로 표현되는 논리값(true/false)을 저장할 수 있는 데이터 타입이다.
		- 두 가지 상태값을 저장할 필요성이 있을 경우에 사용되며, 상태값에 따라 조건문과 제어문의 실행 흐름을 변경하는데 주로 이용한다.
		
	2.3 타입 변환
		* 타입 변환 : 데이터 타입을 다른 데이터 타입으로 변환하는 것
	
	2.3.1 자동 타입 변환(Promotion)
		* 자동 타입 변환 : 프로그램 실행 도중에 자동적으로 타입 변환이 일어나는 것
		- 작은 크기를 가지는 타입이 큰 크기를 가지는 타입에 저장될 때 발생한다.
		-  byte(1) < short(2) < int(4) < long(8) < float(4) < double(8)
		- long 타입 보다 float 타입이 표현할 수 있는 값의 범위가 더 크다
		----------------------------------------------------------
		byte byteValue = 10;
		int intValue = byteValue;	// 자동 타입 변형이 일어난다.
		----------------------------------------------------------
		- 자동 타입 변환이 발생되면 변환 이전의 값과 변호나 이후의 값은 동일하다.
		- 정수 타입이 실수 타입으로 변환하는 것은 무조건 자동 타입 변환이 된다.
		- 실수 타입으로 변환된 이후의 값은 정수값이 아닌 .0이 붙은 실수 값이 된다.
		----------------------------------------------------------
		int intValue = 200;
		double doubleValue = intValue;	// 200.0
		----------------------------------------------------------
		- char 타입의 경우 int 타입으로 자동 변환되면 유니코드 값이 int 타입에 저장된다.
		----------------------------------------------------------
		char charValue = 'A';
		int intValue = charValue;	// 65가 저장된다
		----------------------------------------------------------
		- char는 2byte의 크기를 가지지만, char의 범위는 0~65535이므로 음수가 저장될 수 없다.
		- 음수가 저장 될 수 있는 byte 타입을 char 타입으로 자동 변환 시킬 수 없다.
		----------------------------------------------------------
		byte = byteValue = 65;
		char charValue = byteVlaue;(x)		// 컴파일 에러
		char charData = (char)byteData;(o)	// 강제 타입 변환
		
	2.3.2 강제 타입 변환(캐스팅: Casting)
		- 큰 크기의 타입은 작은 크기의 타입으로 자동 타입 변환을 할 수 없다.
		* 강제 타입 변환 : 강제적으로 큰 데이터 타입을 작은 데이터 타입으로 쪼개어서 저장하는 것
		* 캐스팅 연산자 : 쪼개어지는 큰 데이터 타입의 앞에 '(작은 데이터타입)'의 형식으로 사용하며
					   큰 데이터 타입을 쪼개는 단위인 작은 데이터 타입을 괄호안에 적는다.
		----------------------------------------------------------
		int intValue = 103029770;
		byte byteValue = (byte)intValue;	// 강제 타입 변환(캐스팅)
		
		103029770 -> int에 2진수로 저장 -> 00000110 001000100 00011100 00001010
		-> byte로 캐스팅 -> 00001010(십진수: 10)
		----------------------------------------------------------  
		- 작은 데이터 타입의 크기 만큼만 담게 되므로 원래 큰 데이터 타입의 값은 보존되지 않는다.
		- 큰 데이터 타입의 값이 작은 데이터 타입의 크기 만으로 표현할 수 있다면 값이 유지된다.
		----------------------------------------------------------
		10 -> int에 2진수로 저장 -> 00000000 00000000 00000000 00001010
		-> byte로 캐스팅 -> 00001010(십진수: 10)
		
		long longValue = 300;
		intValue = (int)longValue;	// intValue는 300이 그대로 저장된다.
		----------------------------------------------------------
		- int 타입은 char 타입으로 자동 변환되지 않으므로 강제 타입 변환을 사용해야 한다.
		- int 타입에 저장된 값이 유니코드 범위(0 ~ 65535)라면 char 타입으로 변환할 수 있다.
		- char 타입으로 변환된 값을 출력하면 유니코드에 해당하는 문자가 출력된다.
		----------------------------------------------------------
		int intValue = 'A';		//  유니코드 값 65가 저장된다.
		char charValue = (char)intValue;
		System.out.println(charValue);		// A가 출력된다.
		----------------------------------------------------------
		- 실수타입(float, double)을 정수타입(byte, short, int, long)으로 자동 변환되지 않기 때문에
		  강제 타입 변환을 사용해야 한다. 소수점 이하 부분을 버려지고, 정수 부분만 저장된다.
	  	----------------------------------------------------------
	  	double doubleValue = 3.14;
	  	int intValue = (int)doubleValue;	// intValue는 정수 부분인 3만 저장된다.
	  	----------------------------------------------------------
	  	- 사용자로부터 입력받은 값을 변환할 때 값의 손실이 발생하지 않도록 주의해야 한다.
	  	- 강제 타입 변환을 하기전에 우선 안전하게 값이 보존될 수 있는지 검사하는 것이 좋다.
	  	----------------------------------------------------------
	  	int i = 128;
	  	if( (i < Byte.MIN_VALUE) || (i > Byte.MAX_VALUE) ) {
	  		System.out.println("byte 타입으로 변환할 수 없습니다.");
	  	} else {
	  		byte b = (byte)i;
	  		System.out.println(i);
	  	}
	  	----------------------------------------------------------
	  	----------------------------------------------------------
	  	기본타입		최대값 상수			최소값 상수
	  	byte		Byte.MAX_VALUE		Byte.MIN_VALUE
	  	short		Short.MAX_VALUE		Short.MIN_VALUE
	  	int			Integer.MAX_VALUE	Integer.MIN_VALUE
	  	long		Long.MAX_VALUE		Long.MIN_VALUE
	  	float		Float.MAX_VALUE		Float.MIN_VALUE
	  	double		Double.MAX_VALUE	Double.MIN_VALUE
		----------------------------------------------------------
		- 정수 타입을 실수타입으로 변환할 때 정밀도 손실을 피해야 한다.
		----------------------------------------------------------
		int num1 = 123456780;
		int num2 = 123456780;
		
		float num3 = num2;		// 정밀도 손실이 발생한다(123456780은 23bit로 표현할 수 없기 때문에 근사치로 변환된다)
		num2 = (int) num3;		// 원래의 123456780값으로 변환되지 않는다.
		
		int result = num1 - num2;
		System.out.println(result);		// 정밀도 손실로 인해 0이 아니라 -4가 출력된다.
		---------------------------------------------------------- 		
		- float 타입에는 '부호(1bit) + 지수(8bit) + 가수(23bit)'와 같이 비트가 할당되어있다.
		- int 값을 손실 없이 float값으로 변환하려면 가수 23bit로 표현 가능한 값이어야 한다.
		- 모든 int 값을 실수 타입으로 안전하게 변환 시키려면 double 타입을 쓰는것이 권장된다.
		 (int(32bit) < double's mentissa(52bit))
	
	2.3.3 연산식에서의 자동 타입 반환
		- 연산은 기본적으로 같은 타입의 피연산자(opreand)간에만 수행된다.
		- 서로 다른 타입의 피연ㅅ을 경우 두 피연산자 중 크기가 큰 타입으로 자동 변환된 후 연산을 수행한다.
		----------------------------------------------------------
		int intValue = 10;
		double doubleValue = 5.5;
		double result = intValue + doubleValue;		// result에 15.5가 저장
		----------------------------------------------------------
		- 만약 작은 데이터 타입으로 연산해야 할 필요가 있다면 캐스팅하여 연산을 수행하면 된다.
		----------------------------------------------------------
		int intValue = 10;
		double doubleValue = 5.5;
		int result = intValue + (int)doubleVlaue;	// result에 15가 저장
		----------------------------------------------------------
		- 자바는 정수 연산일 경우 int 타입을 기본으로 한다.
		- 피연산자가 int 타입보다 작은 타입이면 int 타입으로 변환된 후 연산이 수행된다. 연산의 결과도 int가 된다.
		----------------------------------------------------------
						byte								byte
						char								char
		int result =	short		연산자(+, -, *, /, %)		short 
						int									int
		----------------------------------------------------------
		ex) char 타입의 연산 결과는 int 타입으로 산출되므로 int 타입 변수에 결과를 저장해야한다.
			연산의 결과를 다시 문자로 출력하거나 저장하기 위해서는 int 결과값을 char 타입으로 캐스팅해야 한다.
		----------------------------------------------------------
		char ai = 'A';
		int result = ai + 1;		// 'A'의 유니코드 보다 1이 큰 유니코드가 저장
		char na = (char) result;	// 'B'가 저장됨
		----------------------------------------------------------
		- 피연산자 중 하나가 long 타입이라면 다른 피연산자도 long 타입으로 자동 타입변환되고 연산의 결과는 long타입이 된다.
		----------------------------------------------------------
														byte
														char		
		long result = 	long	연산자(+, -, *, /, %)		short
														int
		----------------------------------------------------------
		- float 타입과 float 타입 또는 정수 리터럴을 연산하면 연산의 결과는 float 타입으로 나온다.
		- 피연산자 중에 실수 리터럴이나 double 타입이 있다면
		  다른 피연산자도 double 타입으로 자동 타입 변환되어 연산되므로 결과는 double 타입이 된다.
		----------------------------------------------------------
															byte
															char		
		double result = 실수 리터럴	연산자(+, -, *, /, %)		short
						double								int
															float
															double										
		----------------------------------------------------------
		